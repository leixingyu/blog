{"meta":{"title":"Tech Art Learning","subtitle":"","description":"","author":"Xingyu Lei","url":"https://www.xingyulei.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.027Z","comments":false,"path":"/404.html","permalink":"https://www.xingyulei.com/404.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.030Z","comments":false,"path":"categories/index.html","permalink":"https://www.xingyulei.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.030Z","comments":false,"path":"books/index.html","permalink":"https://www.xingyulei.com/books/index.html","excerpt":"","text":""},{"title":"About Me","date":"2021-09-28T02:02:11.706Z","updated":"2021-09-28T02:02:11.706Z","comments":false,"path":"about/index.html","permalink":"https://www.xingyulei.com/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233Softwares &#x3D; [ &#39;Maya&#39;, &#39;Unity&#39;, &#39;Motion Builder&#39;, &#39;Houdini&#39;]Skills &#x3D; [ &#39;Python&#39;, &#39;C#&#39;, &#39;Qt&#39;, &#39;OpenGL, GLSL&#39;] Links &#x3D; &#123; &#39;Linkedin&#39;: &#39;https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;xingyu-lei&#x2F;&#39;, &#39;Github&#39;: &#39;https:&#x2F;&#x2F;github.com&#x2F;leixingyu&#39;, &#39;Youtube&#39;: &#39;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCyLd9tHXOtZDceAZyP8NC4g&#39;, &#39;Vimeo&#39;: &#39;https:&#x2F;&#x2F;vimeo.com&#x2F;techartlei&#39;,&#125;Education &#x3D; [ [Purdue University, M.S. in Computer Graphics Technology, 2018-2020], [University of Missouri, B.S. in Information Technology, 2016-2018], [Sichuan University, B.S. in Computer Science, 2014-2018],]Work Experience &#x3D; [ [PlayStation, Technical Artist, 2021], [Blur Studio, CFX TD, 2020], [Blur Studio, CFX Intern, 2019],]"},{"title":"友情链接","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.031Z","comments":true,"path":"links/index.html","permalink":"https://www.xingyulei.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.032Z","comments":false,"path":"tags/index.html","permalink":"https://www.xingyulei.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-23T03:34:50.419Z","updated":"2021-02-07T16:58:04.032Z","comments":false,"path":"repository/index.html","permalink":"https://www.xingyulei.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Three Ways to Find PID and End Process in Python","slug":"py-end-process","date":"2021-10-25T04:00:00.000Z","updated":"2021-12-05T23:47:45.231Z","comments":true,"path":"post/py-end-process/","link":"","permalink":"https://www.xingyulei.com/post/py-end-process/","excerpt":"","text":"Intro Interacting with Windows shell to end process is very common, there are many ways to do so, like through the traditional batch script but to gain more flexibility, using python is probably a better idea. os.system is not the most elegant way to use, and it is meant to be replaced by subprocess subprocess comes with Python standard library and allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes psutil (python system and process utilities) is a cross-platform library for retrieving information on running processes and system utilization. However, it is a third-party library Bare Minimum: the bare minimum command to kill process utilizes window’s taskkill; which doesn’t matter if you use os.system or subprocess 1234567import osPROCESS = &#x27;notepad.exe&#x27;STATUS = &#x27;running&#x27; # running or not respondingCMD = r&#x27;taskkill /fi &quot;IMAGENAME eq &#123;&#125;&quot; /fi &quot;STATUS eq &#123;&#125;&quot; &#x27;.format(PROCESS, STATUS)os.system(CMD) Using os.system Now consider a more flexible case where you want to gather information about the processes like its PID, and then proceed on ending the process. One of the downside of window shell command is that the output can’t be passed on to other command, the output is just text. Therefore, we output the text to a csv file which we will later process. 12345678910111213141516171819202122232425import csvimport osimport signalimport subprocessPROCESS = &#x27;notepad.exe&#x27;STATUS = &#x27;running&#x27; # running or not respondingTMP = r&#x27;&#123;&#125;/Desktop/tmp.txt&#x27;.format(os.environ[&#x27;userprofile&#x27;])CMD = r&#x27;tasklist /fi &quot;IMAGENAME eq &#123;&#125;&quot; /fi &quot;STATUS eq &#123;&#125;&quot; /fo &quot;csv&quot; &gt; &quot;&#123;&#125;&quot;&#x27;.format(PROCESS, STATUS, TMP)# output as csv formatos.system(CMD)with open(TMP, &#x27;r&#x27;) as temp: reader = csv.reader(temp) header = next(reader) pids = [int(row[1]) for row in reader]# kill processfor pid in pids: os.kill(pid, signal.SIGTERM) # or signal.SIGKILL print(&#x27;killed process with pid: &#123;&#125;&#x27;.format(pid))if os.path.exists(TMP): os.remove(TMP) Using subprocess With subprocess, we no longer need to create a temp file to store the output. Using psutil 12345678910111213141516171819import psutilPROGRAM = r&#x27;maya.exe&#x27;def findProcess(name): procs = list() #Iterate over the all the running process for proc in psutil.process_iter(): try: if proc.name() == name and proc.status() == psutil.STATUS_RUNNING: pid = proc.pid procs.append(pid) except: pass return procsprocesses = findProcess(PROGRAM) we can find process start time by using 12import timestartTime = time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;, time.localtime(proc.create_time())) to kill process, either kill() or terminate() will work respectfully, SIGKILL or SIGTERM 1234p = psutil.Process(PID)p.terminate()p.kill()p.wait Bonus: Find Open Port (for socket connection) 123456process = psutil.Process(pid=PID)connections = process.connections(kind=&#x27;tcp4&#x27;)for c in [x for x in connections if x.status == psutil.CONN_LISTEN]: # gets the port number print(&#x27;port opened: &#123;&#125;&#x27;.format(c.laddr[-1])) Bonus: Finding Main Window Title ctypes is a foreign function library for python, resulting a not-pythonic function Reference Microsoft Doc - tasklist ThisPointer - Python : Check if a process is running by name and find it’s Process ID (PID) Johannes Sasongko - Win32 Python: Getting all window titles Stack overflow - Obtain Active window using Python Microsoft Docs - winuser.h header","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"}]},{"title":"State Machine in Unity Scripting API","slug":"unity-api-statemachine","date":"2021-08-29T04:00:00.000Z","updated":"2021-09-28T02:04:39.254Z","comments":true,"path":"post/unity-api-statemachine/","link":"","permalink":"https://www.xingyulei.com/post/unity-api-statemachine/","excerpt":"","text":"Introduction This post is not about state machine basic, rather how we would setup/access state machine parameters. There is a higher level Animator class to access a part of the animator features, but we need to use Unity’s Animations package in order to dive deeper. 1using UnityEditor.Animations; There’s a lot of parts composing Unity’s Animator: Layer, Parameter, State machine (and everything inside it including states of different kind, transition between states), there are of course multiple parameters inside a single state. The examples in this post is only about accessing states and state machines, as the rest is translatable. We start from the root: Base layer, if you think about it, a layer is essentially a state machine. Inside this root state machine are sets of states (including blend tree/state/sub-state machine) 12// getting the base layer state machineAnimatorStateMachine rootStateMachine = controller.layers[0].stateMachine; (Base Layer) Next up, a very confusing part of the scripting process are the definition of AnimatorStateMachine vs. ChildAnimatorStateMachine and AnimatorState vs. ChildAnimatorState. I really wish Unity provides internal ways to cast these to each other. To summarize: ChildAnimatorStateMachine[] and ChildAnimatorState[] is used in conjunction with Arrays as AnimatorStateMachine.states and AnimatorStateMachine.stateMachines will return the previous mentioned type. Instead of casting, they have an internal property ChildAnimatorStateMachine.stateMachine and ChildAnimatorState.state which respectively returns AnimatorStateMachine and AnimatorState type object States All states (state or. state with blendtree inside) 1234567891011121314151617181920212223ChildAnimatorState[] childStates = rootStateMachine.states;foreach(var childState in childStates)&#123; AnimatorState state = childState.state; print(state.name); // state with blendtree try &#123; var blendTree = (BlendTree)state.motion; foreach (var child in blendTree.children) &#123; print(&quot;\\t&quot; + child.motion.name); &#125; &#125; // simple state catch &#123; print(&quot;\\t&quot; + state.motion.name); &#125;&#125; (Simple state only contains a single clip) (BlendTree nested in a state) Sub-state machine 12345678910111213141516ChildAnimatorStateMachine[] childSubStateMachines = rootStateMachine.stateMachines;foreach(var childSubStateMachine in childSubStateMachines)&#123; // Convert `ChildAnimatorStateMachine` to `AnimatorStateMachine` AnimatorStateMachine subStateMachine = childSubStateMachine.stateMachine; print(subStateMachine.name); // all states in idle sub state machine ChildAnimatorState[] states = subStateMachine.states; foreach (var childState in states) &#123; print(&quot;\\t&quot; + childState.state.name); &#125;&#125; (Essentially, another sub layer of state machine) Reference Unity Manual - State Machine Basics Unity Scripting API - AnimatorStateMachine Unity Scripting API - Animator.Play","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://www.xingyulei.com/tags/c/"},{"name":"unity","slug":"unity","permalink":"https://www.xingyulei.com/tags/unity/"}]},{"title":"How to Resize QPixmap","slug":"qt-pixmap-scale","date":"2021-08-22T04:00:00.000Z","updated":"2021-11-24T03:46:12.624Z","comments":true,"path":"post/qt-pixmap-scale/","link":"","permalink":"https://www.xingyulei.com/post/qt-pixmap-scale/","excerpt":"","text":"Intro During my attempts to create custom alignment push buttons, I encountered an issue with icon having jagged looking (even if with low resolution). I use a custom paintEvent() drawing QPixmap, and this happens when I use scaled() to resize my pixmap. I noticed the icon does not have the jagged look with the built-in setIcon() and setIconSize in QPushButton. So I know there’s some wrong with my approach. The Test To really show out the difference, I first reduce the resolution of my image. 12345low_rez = QtCore.QSize(40, 40)high_rez = QtCore.QSize(400, 400)pixmap = QtGui.QPixmap(path)pixmap = pixmap.scaled(low_rez) I then increase the resolution back to normal. The default scale uses FastTransformation 1pixmap = pixmap.scaled(high_rez) This is the result: The Solution I’ve searched many forums and people were all saying: enable the SmoothTransformation, I tried but didn’t work. Later on I found out that the Qt translation to Python has a mis-match keyword argument: so instead of transformMode=Qt.SmoothTransformation, it should actually be mode=Qt.SmoothTransformation So here’s the solution: 12345pixmap = pixmap.scaled( high_rez, aspectRatioMode=QtCore.Qt.KeepAspectRatio, mode=QtCore.Qt.SmoothTransformation) and result: Extra I also found post saying it might be some settings with the QPainter, but it is not the issue for me. 1234painter = QtGui.QPainter(self)painter.setRenderHint(QtGui.QPainter.Antialiasing, True)painter.setRenderHint(QtGui.QPainter.SmoothPixmapTransform, True)painter.drawPixmap(self.pixmap) Reference Qt Documentation - QPixmap Class","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Qt Left Align Icon, Center Align Text (Python)","slug":"qt-button-alignment","date":"2021-08-21T04:00:00.000Z","updated":"2021-12-05T23:44:04.729Z","comments":true,"path":"post/qt-button-alignment/","link":"","permalink":"https://www.xingyulei.com/post/qt-button-alignment/","excerpt":"","text":"I recently needed to display a series of buttons for my shelf tool, the problem I’m having with this is that although every button has an icon and text label, they are displayed as different width. Using center-align made it look not uniform. Should I go with left-align? Well, there are buttons with relatively longer label and some with shorter ones, so it doesn’t look nice either with empty spaces on the right side. So the solution is obvious, separate the alignment of the icon and the label: the icon stays left-align to give a clear sign of broader, and the label would be center-align to make the width look uniform. (Left: default center align, Center: left align, Right: custom align) In the following section, I will demonstrate three methods of achieving this custom alignment effect: Overriding QPushButton paintEvent Create a subclass from QPushButton called MyButton: With this method, we no longer use QIcon, we use pixmap instead. Custom layout inside pushbutton Remember to send setText signals to textLabel instead of pushButton since this is label within push button’s layout Use QProxyStyle I haven’t personally test it because I’m using a custom python Qt binding that doesn’t have QProxyStyle included but it’s worth putting it here in case someone is able to try it 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class ProxyStyle(QtWidgets.QProxyStyle): def drawControl(self, element, option, painter, widget=None): if element == QtWidgets.QStyle.CE_PushButtonLabel: icon = QtGui.QIcon(option.icon) option.icon = QtGui.QIcon() super(ProxyStyle, self).drawControl(element, option, painter, widget) if element == QtWidgets.QStyle.CE_PushButtonLabel: if not icon.isNull(): iconSpacing = 4 mode = ( QtGui.QIcon.Normal if option.state &amp; QtWidgets.QStyle.State_Enabled else QtGui.QIcon.Disabled ) if ( mode == QtGui.QIcon.Normal and option.state &amp; QtWidgets.QStyle.State_HasFocus ): mode = QtGui.QIcon.Active state = QtGui.QIcon.Off if option.state &amp; QtWidgets.QStyle.State_On: state = QtGui.QIcon.On window = widget.window().windowHandle() if widget is not None else None pixmap = icon.pixmap(window, option.iconSize, mode, state) pixmapWidth = pixmap.width() / pixmap.devicePixelRatio() pixmapHeight = pixmap.height() / pixmap.devicePixelRatio() iconRect = QtCore.QRect( QtCore.QPoint(), QtCore.QSize(pixmapWidth, pixmapHeight) ) iconRect.moveCenter(option.rect.center()) iconRect.moveLeft(option.rect.left() + iconSpacing) iconRect = self.visualRect(option.direction, option.rect, iconRect) iconRect.translate( self.proxy().pixelMetric( QtWidgets.QStyle.PM_ButtonShiftHorizontal, option, widget ), self.proxy().pixelMetric( QtWidgets.QStyle.PM_ButtonShiftVertical, option, widget ), ) painter.drawPixmap(iconRect, pixmap)if __name__ == &quot;__main__&quot;: app = QtWidgets.QApplication(sys.argv) app.setStyle(&#x27;fusion&#x27;) proxy_style = ProxyStyle(app.style()) app.setStyle(proxy_style) w = QtWidgets.QWidget() lay = QtWidgets.QVBoxLayout(w) icons = [ app.style().standardIcon(standardIcon) for standardIcon in ( QtWidgets.QStyle.SP_MediaPlay, QtWidgets.QStyle.SP_MediaPause, QtWidgets.QStyle.SP_MediaSeekBackward, QtWidgets.QStyle.SP_MediaSeekForward, ) ] for text, icon in zip(&quot;Play Pause Backward Forward&quot;.split(), (icons)): button = QtWidgets.QPushButton(text) button.setIcon(icon) lay.addWidget(button) w.show() sys.exit(app.exec_()) Reference Stack Overflow - QPushButton icon aligned left with text centered Stack Overflow - qpushbutton icon left alignment text center alignment","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Qt QPushButton Detect Double Click","slug":"qt-detect-click","date":"2021-08-08T04:00:00.000Z","updated":"2021-12-05T23:42:16.830Z","comments":true,"path":"post/qt-detect-click/","link":"","permalink":"https://www.xingyulei.com/post/qt-detect-click/","excerpt":"","text":"It’s not as easy as it looks Built-in Double Click Hey, I thought this would be easy, since Qt offers a built-in event QEvent.MouseButtonDblClick. But the issue is it couldn’t distinguish a single click vs. a double click. Which means, a single click event will also be called if double clicked. Solution? Custom click detection with timeout Subclass QPushButton and override eventFilter() Reference Qt Centre - Double Click Capturing Pyqt Mouse MouseButtonDblClick event","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Constant in Python","slug":"py-constant","date":"2021-07-16T04:00:00.000Z","updated":"2021-10-27T02:56:33.337Z","comments":true,"path":"post/py-constant/","link":"","permalink":"https://www.xingyulei.com/post/py-constant/","excerpt":"","text":"Introduction I recently saw some codes written by another tech artist, and he made a module called constant.py In it stored all the global variables and all the import modules, something like this: 12345678910111213141516#constant.pyimport module_aimport module_bimport module_cGLOBAL_VAR_MAX = 50GLOBAL_VAR_MIN = 10GLOBAL_VAR_TIMEOUT = 2000GLOBAL_NAME = r&#x27;random name&#x27;# or evenclass Constant(object): gravity = 9.8 is_true = True With this setup, all the module in the same project would just import the constant module and have access to all the imports and variable. I thought this was a neat way to make code cleaner by getting rid of all the duplicated imports that might happened. But turns out that there’s a lot of people against doing things like this. Constant in Python the root level where the constant lives actually matters: based on the style guide: Constants are usually defined on a module level and written in all capital letters with underscores separating words. Examples include MAX_OVERFLOW and TOTAL. also suggestions have mentioned to refrain from using class as it could be instantiated which makes no sense. (maybe a static class in another language would work) Separate module for import Despite the root level of constant this, is it a good practice to have a separate module for import? No, unless there’s a valid reason for all those modules to be collected under a common name. If not, then they should be kept separately. This is due to documentation, as other people open your file, they don’t get information on what is getting imported (what is needed) Same module import multiple times So if multiple files are importing the same module separately, does python optimize the import? Yes, python modules are considered as singletons, no matter how many times you import them they get initialized only once. unless reload is being called See my other blog in regards to python import Reference Stack Overflow - constants in Python: at the root of the module or in a namespace inside the module? Stack Overflow - in python, do you need to import modules in each split file? Stack Overflow - Python: Importing an “import file” Stack Overflow - Does python optimize modules when they are imported multiple times?","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"style","slug":"style","permalink":"https://www.xingyulei.com/tags/style/"}]},{"title":"Qt Connect Signal in For Loop","slug":"qt-signal-in-for-loop","date":"2021-04-17T04:00:00.000Z","updated":"2021-10-11T13:35:11.141Z","comments":true,"path":"post/qt-signal-in-for-loop/","link":"","permalink":"https://www.xingyulei.com/post/qt-signal-in-for-loop/","excerpt":"","text":"Introduction We often needs to create ui elements on the fly, sometimes we do it in something like a for loop. An example would be creating a series of QPushButton and connect them to a function through different argument values. A example is shown below: 1234567891011121314151617class Demo(QtWidgets.QWidget): def __init__(self, parent=None): super(Demo, self).__init__(parent) # initialization object layout = QtWidgets.QVBoxLayout() for index in range(6): pushbutton = QtWidgets.QPushButton(&#x27;button &#123;&#125;&#x27;.format(index)) pushbutton.clicked.connect(lambda: self.trigger(index)) layout.addWidget(pushbutton) self.setLayout(layout) @staticmethod def trigger(index): print(&#x27;button &#123;&#125; clicked&#x27;.format(index)) Here I created six QPushButton and when I click them it should output which button is being clicked. But if you run this script and try to click each button it will always output “button 5 clicked” (aka, the last button). It is safely to assume that the argument passed during the for loop always result in the last index. Explanation Based on a kind response from stackoverflow: lambdas do not store the value of button when it is defined. The code describing the lambda function is parsed and compiled but not executed until you actually call the lambda. Therefore, when a button is clicked, the current value of that variable is used (the last index). What’s the solution? Lambda with solid variable Passing solid variable to the lambda 1pushbutton.clicked.connect(lambda _, i=index: self.trigger(index=i)) Note that we created another temporary variable before index as the first argument passed in the lambda will always return as False. Because Qt defines the signal QAbstractButton.clicked to take a single argument with a default value of False. Since your lambda is handling that signal, it gets called with False. Partial approach Use functools.partial also works 12from functools import partialpushbutton.clicked.connect(partial(self.trigger, index)) Note that in some cases where wrappers are being used in trigger function, it could be trickier to use this as oppose to lambda Reference Stack Overflow - First lambda capture of local variable always False Stack Overflow - Connecting multiples signal/slot in a for loop in pyqt","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Qt Template without UI file","slug":"qt-template-no-ui","date":"2021-02-11T05:00:00.000Z","updated":"2021-12-05T23:41:04.523Z","comments":true,"path":"post/qt-template-no-ui/","link":"","permalink":"https://www.xingyulei.com/post/qt-template-no-ui/","excerpt":"","text":"UI Module without .ui file There is a different between inheriting from QWidget class vs QMainWindow Inheriting from QWidget: 12345678910111213141516class InheritQWidget(QtWidgets.QWidget): def __init__(self, parent=None): super(InheritQWidget, self).__init__(parent) # initialization object layout = QtWidgets.QGridLayout() listWidget = QtWidgets.QListWidget() #treeWidget = QtWidgets.QTreeWidget() # set # treeWidget.setParent(listWidget) layout.addWidget(listWidget) self.setLayout(layout) listWidget.addItem(&#x27;item A&#x27;) listWidget.addItem(&#x27;item B&#x27;) Inheriting from QMainWindow 123456789101112131415161718class InheritQMainWindow(QtWidgets.QMainWindow): # Window inherits from QMainWindow the layout is already defined # to accommodate any toolbars or any other QMainWindow component # use the setCentralWidget() to accommodate this def __init__(self, parent=None): super(InheritQMainWindow, self).__init__(parent) # initialization object widget = QtWidgets.QWidget() layout = QtWidgets.QGridLayout() # set self.setCentralWidget(widget) widget.setLayout(layout) label = QtWidgets.QLabel(&#x27;test&#x27;) layout.addWidget(label, 0, 0) Custom Dialog Sometimes you need a quick window to display some information, but the built-in qt message boxes aren’t suitable for the job. Custom Widget You can choose to create a widget class, but also for saving time, you can create a temporary custom widget example: Couple of things worth noting: correctly initialize the widget self.customWidget = QtWidgets.QWidget() will allow widget be child of the main window, thus allow widget to close when main window is closed so not customWidget = QtWidgets.QWidget() or self.customWidget = QtWidgets.QWidget(self) use getattr in combination with QStyle and name of the built-in icon use win.setAttribute(QtCore.Qt.WA_DeleteOnClose) to make sure the child widget is killed after main window is closed, because default close only hides window objects self.customWidget.show() is the core command to call it to display Custom QMessageBox add custom buttons to the QMessageBox layout 123456789101112131415dialog = QtWidgets.QMessageBox()dialog.setText(&quot;Overwrite?&quot;)dialog.setIcon(QtWidgets.QMessageBox.Critical)yes_btn = dialog.addButton(&quot;Yes!&quot;, QtWidgets.QMessageBox.YesRole)no_btn = dialog.addButton(&quot;No&quot;, QtWidgets.QMessageBox.NoRole)abort_btn = dialog.addButton(&quot;Abort&quot;, QtWidgets.QMessageBox.RejectRole)dialog.exec_()if dialog.clickedButton() == yes_btn: print(&quot;yes&quot;)elif dialog.clickedButton() == no_btn: print(&quot;no&quot;)elif dialog.clickedButton() == abort_btn: print(&quot;abort&quot;) Don’t use the return value of QMessageBox::exec, as it only makes sense for standard buttons. Also don’t rely on buttonRole as multiple buttons could be sharing the same role. Reference Programiz - Python getattr() GUIS - Q&amp;A: Are there any built-in QIcons?","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"},{"name":"template","slug":"template","permalink":"https://www.xingyulei.com/tags/template/"}]},{"title":"Qt Context Menu Template (Menu, Submenu and Action)","slug":"qt-template-context-menu","date":"2021-02-05T05:00:00.000Z","updated":"2021-12-05T23:33:18.502Z","comments":true,"path":"post/qt-template-context-menu/","link":"","permalink":"https://www.xingyulei.com/post/qt-template-context-menu/","excerpt":"","text":"Reference Stack Overflow - How to add submenu in Qt","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"},{"name":"template","slug":"template","permalink":"https://www.xingyulei.com/tags/template/"}]},{"title":"Error Handling in Python","slug":"py-error-handle","date":"2021-01-24T05:00:00.000Z","updated":"2021-11-24T03:42:30.893Z","comments":true,"path":"post/py-error-handle/","link":"","permalink":"https://www.xingyulei.com/post/py-error-handle/","excerpt":"","text":"finally is a guarantee finally will guarantee execution in try-exception-finally block even after return raise Passing on Exception Message usually just print(e) is enough 12345678def make_error(): try: output = 10 / 0 except ZeroDivisionError as e: if hasattr(e, &#x27;message&#x27;): print(e.message) else: print(e) raise error to parent 12345678910 / 0 # this will raise an ZeroDivision Error# catchdef make_error(): try: output = 10 / 0 except ZeroDivisionError: # error handling pass an error in a child function can be handled both from the child itself: 12345def child_error(): try: output = 10/0 except ZeroDivisionError: print(&#x27;error being handled in the child&#x27;) or the parent function that is calling it: 123456789def parent_error(): try: child_error() except ZeroDivisionError: # error handling print(&#x27;error being handled in the parent&#x27;) def child_error(): output = 10/0 we can also use raise to pass the error to the parent function the following example makes that whatever is calling make_error() getting custom error and messages, useful for debugging 123456def make_error(): try: output = 10 / 0 except ZeroDivisionError as e: message = &#x27;this is a custom message&#x27; raise AttributeError(message) Catch Traceback without halting Using maya’s built-in timer can be helpful measuring execution time when debugging, we need a guarantee start and end thus using finally, and a wild error handling with Exception. But doing so we can’t get the full stack traceback, unless we do something like this: 12345678910import tracebackcmds.timer(startTimer=1)try: make_error()except Exception: print(traceback.format_exc())finally: cmds.timer(endTimer=1) Reference Stack Overflow - Does ‘finally’ always execute in Python? Stack Overflow - How to get exception message in Python properly Stack Overflow - How to catch and print the full exception traceback without halting/exiting the program?","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"}]},{"title":"How to Underscore in Python","slug":"py-dunder","date":"2021-01-23T05:00:00.000Z","updated":"2021-10-12T01:15:23.936Z","comments":true,"path":"post/py-dunder/","link":"","permalink":"https://www.xingyulei.com/post/py-dunder/","excerpt":"","text":"Underscore Naming Single Leading Underscore: _var Indicating a name is protected, for internal use. Not enforced by python interpreter Double Leading Underscore: __var Indicating a name is private. Enforced by interpreter, attempt to call it will trigger AttributeError Double Leading Trailing Underscore: __var__ Special methods (magic methods) defined by python language, avoid naming your own attribute Single Trailing Underscore: var_ Avoid naming conflict with python keywords Single Underscore: _ Temporary variable name, variables that are never used Example: 1234a, b, c, d = ([] for _ in range(4))for _ in random_list: some_operation() Reference Dan Bader - The Meaning of Underscores in Python Tutorials Teacher - Python - Public, Protected, Private Members","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"}]},{"title":"Qt Custom Sorting","slug":"qt-sorting","date":"2021-01-23T05:00:00.000Z","updated":"2021-12-05T23:31:54.132Z","comments":true,"path":"post/qt-sorting/","link":"","permalink":"https://www.xingyulei.com/post/qt-sorting/","excerpt":"","text":"Sorting Overview Sorting happens a lot in qt viewports like list, table and tree. Using convenience class such as item-based widget provides limited sorting options. One common thing may occur when you are sorting items is the widget treats their value as string instead of int, which will result incorrect ordering 12345678910111213141516list = [&quot;3&quot;, &quot;1&quot;, &quot;2&quot;, &quot;20&quot;, &quot;92&quot;, &quot;89&quot;, &quot;40&quot;, &quot;10&quot;, &quot;11&quot;]if __name__ == &#x27;__main__&#x27;: app = QtWidgets.QApplication(sys.argv) mywidget = QtWidgets.QTableWidget() mywidget.insertColumn(0) for index in range(len(list)): mywidget.insertRow(index) value = list[index] item = QtWidgets.QTableWidgetItem(value) mywidget.setItem(index, 0, item) mywidget.sortItems(0, QtCore.Qt.AscendingOrder) mywidget.show() sys.exit(app.exec_()) This will sort the list of items based on their string, so the order will be: 1234- 1- 10- 11- 2 instead of 123- 1- 2- ... So naturally, you would need to specify the item value as integer type, but you cannot instantiate item with integer, but setData() will work 1234# intead of item = QtWidgets.QTableWidgetItem(int(value))# do thisitem.setData(QtCore.Qt.ItemDataRole, int(value)) Now everything will sort by numeric order Custom Sorting (Operator override) What if you need more than numeric value for your data, for example, when displaying frame number, you would like to include frame range too. Like frame 1, frame 2, frame 3-7, frame 8, frame 9-14. It looks like using string is the only option. This time you need to override value compare operator for these value, that is making your own item class like the following example the __lt__ is the less than operator (&lt;) Everything should behave correctly Custom Sorting (QSortFilterProxyModel Class) To be continued Reference Stack Overflow - Is it possible to sort numbers in a QTreeWidget column?","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Understand Python Imports","slug":"py-import","date":"2021-01-16T05:00:00.000Z","updated":"2021-10-11T02:35:31.812Z","comments":true,"path":"post/py-import/","link":"","permalink":"https://www.xingyulei.com/post/py-import/","excerpt":"","text":"from ... import vs. import Always avoid wildcard imports like such: 1from my_module import * # don&#x27;t use this Instead, use regular import like: 1import my_module # use this Why? using wildcard import will pollute namespaces Using wildcard import will not import names with a leading underscore (unless the module defines an __all__ list) PEP8 recommend using regular import What does __init__.py do? __init__.py is used to specify a package, when import is trying to find the modules, But it is not required: meaning a package without __init__.py, The system can still find the modules after configuring appropriate PYTHONPATH using sys.path.append. __init__.py is executed after importing the package, I’ve seen sub-directory being imported by appending as environment variable within __init__.py Example: so instead of using import project.foo.bar for the following structure: 123456project&#x2F; __init__.py foo&#x2F; __init__.py bar&#x2F; b.py inside the __init__.py, we could do a sys.path.append(PATH_TO_BAR) so with this file structure, you can just do import project they could even add the import statement for you in the __init__.py, although it is not transparent. 12345project&#x2F; __init__.py foo&#x2F; bar&#x2F; b.py Note: Whatever gets appended last overrides the previous env variable, so import to the same name module will find the latest append Dot notation (.) in Import 12345678910parent&#x2F; __init__.py file.py one&#x2F; __init__.py anotherfile.py two&#x2F; __init__.py three&#x2F; __init__.py Each dot in your import will refer to something inside the package, could be another package or a module. But it can’t be a class. Import python modules could look like: import parent.file or import parent.one.anotherfile From … import classes or functions look like this: from parent.file import class which gives you direct access to the class namespace, but not the example above. Import Order Based on PEP8, imports should be grouped by the following order: Standard library import Related third-party import Local application/library specific import What is Standard Library Imports? Standard library are installed automatically by Python installer, full documentation link is here: https://docs.python.org/3/library/ What is the order after grouping? There is no specific rules, but based on common preferences, use alphabetical order, with import first and from … import after 12345import abcimport defimport xfrom g import ggfrom x import xx Intra-Package In a structure like this, how would you do import from another directory? say from module-x.py import module-a 12345678910top-package&#x2F; __init__.py sub-package-a&#x2F; __init__.py module-x.py module-y.py sub-package-b&#x2F; __init__.py module-a.py module-b.py Here’s some examples doing relative imports in module-x 1234567891011import module-yfrom . import module-yfrom .module-y import classAfrom .. import sub-package-bfrom ..subpackage-b import module-afrom ..subpackage-b.module-a import classB Reference Stack Overflow - Why can I import successfully without init.py? Stack Overflow - relative path not working even with init.py","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"style","slug":"style","permalink":"https://www.xingyulei.com/tags/style/"}]},{"title":"List Comprehension, Next() and Conditional Expression","slug":"conditional-expression","date":"2021-01-06T05:00:00.000Z","updated":"2021-12-05T15:07:42.894Z","comments":true,"path":"post/conditional-expression/","link":"","permalink":"https://www.xingyulei.com/post/conditional-expression/","excerpt":"","text":"List Comprehension 123list = list()for item in items: list.append(item) which can be re-written as a one-liner 1list = [item for item in items] But, the use of list comprehension is usually combined with operation and statement, otherwise it doesn’t make sense. 1list = [operate_func(item) for item in items if condition] Note that list comprehension is meant for creating list, not executing multiple operations 123456# Wrong: as it creates a list which takes up memory[operation() for _ in steps]# Correct: it&#x27;s okay to have multi-line herefor _ in steps: operation() Next() In order to use next(), the object has to be iterator type. We can do so by converting it using iter(), or we can use generator expression (similar as the list comprehension above). 1234567list = [1, 2, 3, 4]# convert list into iteratoriter_list = iter(list)# generator expressioniter_list = (item for item in list) To get the next item of the iterator, simply use next(_iterator) 123next(iter_list) # output: 1next(iter_list) # output: 2 After each iteration (using next()), the iterator shortens, but not the original list 1234567print([item for item in iter_list])# output: [3, 4]print(list)# output: [1, 2, 3, 4] Common Usage Get the first element that matches condition of a list, if no element is found then returns a default value. 123456# no default valuenext(item for item in list if item &gt; 2)# with default value# generator expression must be parenthesized if not sole argumentnext((item for item in list if item &lt; 0), None) Get rid of the first element, such as title/header of .csv file and parse only the data in the body 12345678import csvreader = csv.reader(file)header = next(reader)# this only prints main bodyfor row in reader: print(row) Conditional Expression (or. Ternary Operators) 1234if condition: value = value_if_trueelse: value = value_if_false this can be re-written as: 1value = value_if_true if condition else value_if_false Reference Stack Overflow - Default value for next element in Python iterator if iterator is empty?","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"style","slug":"style","permalink":"https://www.xingyulei.com/tags/style/"}]},{"title":"Difference between Field and Property","slug":"field-property","date":"2020-12-20T05:00:00.000Z","updated":"2021-09-28T02:07:24.372Z","comments":true,"path":"post/field-property/","link":"","permalink":"https://www.xingyulei.com/post/field-property/","excerpt":"","text":"Example In C#: 1234567891011121314public class Person&#123; private string _name; // this is a field public string Name // this is a property &#123; get&#123; return _name; &#125; set&#123; _name = value; &#125; &#125; public int Age&#123; get;set; &#125; // AutoProperty generates private field for us&#125; In Python: 12345678910111213141516171819202122class Celsius(object): def __init__(self, temperature=0): self._temperature = temperature # this is a protected field @property def temperature(self): print(&quot;Getting value...&quot;) return self._temperature @temperature.setter def temperature(self, value): print(&quot;Setting value...&quot;) if value &lt; -273.15: raise ValueError(&quot;Temperature below -273 is not possible&quot;) self._temperature = value# in this case, access the protected temperature valuehuman = Celsius(37)# gettemperature = human.temperature # note that this is not calling a method# set/modifyhuman.temperature = 36.5 Summary Field which stores the internal data should almost always be private. Property gives access to field (or exposed field). Above provides an example of field and property as well as a short-hand for get &amp; set, and AutoProperty in C#. The python example, use the decorator @property for getting value, use @name.setter: name is the property name. In this case: @temperature.setter. There is also a deleter. Reference W3Schools - C# Properties Medium - Properties vs, Fields in C# FreeCodeCamp - The @property Decorator in Python: Its Use Cases, Advantages, and Syntax","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"c#","slug":"c","permalink":"https://www.xingyulei.com/tags/c/"}]},{"title":"Structure and Class in C#","slug":"structure-class","date":"2020-12-20T05:00:00.000Z","updated":"2021-10-14T01:44:19.530Z","comments":true,"path":"post/structure-class/","link":"","permalink":"https://www.xingyulei.com/post/structure-class/","excerpt":"","text":"Struct 12345678public struct Coord&#123; public Coord(float x, float y)&#123; X = x; Y = y; &#125; public float X &#123; get; &#125; public float Y &#123; get; &#125;&#125; Class 12345678public class Person&#123; public Person(string name, int age)&#123; Name = name; Age = age; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125;&#125; Structure types have value semantics. That is, a variable of a structure type contains an instance of the type. By default, variable values are copied on assignment, passing an argument to a method, and returning a method result. In the case of a structure-type variable, an instance of the type is copied Because structure type have value semantics, it is recommended using “readonly” to declare structure type as immutable. Class types have reference semantics. That is, a variable of a class type contains a reference to an instance of the type, not the instance itself. Therefore, the following example shows the different use cases. 12345678910111213Person Jack = new Person(&quot;Jack&quot;, 28);Jack.Name = &quot;Jackson&quot;;Console.WriteLine(Jack.Name);Coord origin = new Coord(0, 0);Console.WriteLine(origin.X);// error! the return value X is not a variable// it is actrually the copy of the instanceorigin.X = 5; // clear! can only set new X this way origin = new Coord(5, 0); Reference Stack Overflow - Error: “Cannot modify the return value” c# Microsoft - Structure types (C# reference)","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://www.xingyulei.com/tags/c/"}]},{"title":"Verlet Integration in Unity","slug":"verlet-integration","date":"2020-11-19T05:00:00.000Z","updated":"2021-10-11T03:54:37.481Z","comments":true,"path":"post/verlet-integration/","link":"","permalink":"https://www.xingyulei.com/post/verlet-integration/","excerpt":"","text":"Introduction When simulating a particle movement, we naturally think of Euler integration, where the position of the particle can be expressed as such: (free falling motion) x=0.5∗g∗t2x = 0.5*g*t^2 x=0.5∗g∗t2 This is an extremely easy use case. The position of the particle can be represented using a function of time. But in real life, a particle can be affected by multiple forces (and even unstabled force caused non-constant acceleration) and Euler integration also has inaccurate estimation when time step is very large. In my understanding, the use of Verlet is good for complex particle movement. What it essentially does is relate force with position rather than velocity. The process first calculate the current particle position and the position one step back: velocity=X current −X previous ;velocity = X~current~-X~previous~; velocity=X current −X previous ; X previous =X current ;X current =X current +velocityX~previous~ = X~current~; X~current~ = X~current~+velocity X previous =X current ;X current =X current +velocity This works magically, here’s some sample code to help understand it, and a Demo. 1234// without other influence, the following updates the particle positionvelocity = posNow - posOld;posOld = posNow;posNow += velocity; Calculate Force What if we want to add gravity to the particle like the free falling above? Just add the acceleration to the current position, and the change will add-up on the next integration. The following also applies to forces like friction. 1posNow += GRAVITY; // not sure if we should multipy Time.deltatime Constraint Constraint are usually in the form of constraining particles to a specific distance, like spring. When mulitple constraints acts on single particle, one constraint will affect the other. To solve this, loop the constraint multiple time for each time step. 123456789101112131415161718192021222324252627for (int count = 0; count &lt; ITERATION; count++)&#123; Constriants();&#125;// constraint on rope to make fixed distance between segmentsvoid Constriants()&#123; for(int index = 0; index &lt; segment-1; index++) &#123; float distance = (currentSeg.posNow - nextSeg.posNow).magnitude; float error = Mathf.Abs(distance - ropeDist); Vector2 changeDir = Vector2.zero; if (distance &gt; ropeDist) changeDir = (currentSeg.posNow - nextSeg.posNow).normalized; else if (distance &lt; ropeDist) changeDir = (nextSeg.posNow - currentSeg.posNow).normalized; Vector2 changeAmount = changeDir * error; if (index == 0) nextSeg.posNow += changeAmount; else&#123; currentSeg.posNow -= changeAmount * 0.5f; nextSeg.posNow += changeAmount * 0.5f; &#125; &#125;&#125; Collision Penalty based system or projection collision reaction 12345678910111213141516171819// example for bounding box collisionVector2 velocity = posNow - posOld;if (posNow.x &gt; screenWidth)&#123; posNow.x = screenWidth; posOld.x = posNow.x + velocity.x;&#125;else if (posNow.x &lt; 0)&#123; posNow.x = 0; posOld.x = posNow.x + velocity.x;&#125;if (posNow.y &gt; screenWidth)&#123; posNow.y = screenWidth; posOld.y = posNow.y + velocity.y;&#125;else if (posNow.y &lt; 0)&#123; posNow.y = 0; posOld.y = posNow.y + velocity.y;&#125; Resources Youtube - Coding Math: Episode 36 - Verlet Integration Part I Youtube - 2D Rope Tutorial - Make Swinging Rope in Unity (Verlet Integration) Wikipedia - Velocity Verlet","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://www.xingyulei.com/tags/c/"},{"name":"unity","slug":"unity","permalink":"https://www.xingyulei.com/tags/unity/"}]},{"title":"Learning Graphics Basics","slug":"graphics-learning","date":"2020-09-16T04:00:00.000Z","updated":"2021-12-05T15:06:58.459Z","comments":true,"path":"post/graphics-learning/","link":"","permalink":"https://www.xingyulei.com/post/graphics-learning/","excerpt":"","text":"Glossary Wikipedia - Computer Graphics Glossary Shader: programs running on gpu that describes general computation (vertex transformation: vertex shader; shading calculation: fragment shader) G-buffer: a screen space representation of geometry and material information (e.g. color, normal, position/depth) Fragment: is the corresponding pixel generated by geometric primitives, but a pixel on screen can be a product of more than one fragment due to Z-buffering, blending etc. Vertex lighting vs. Per-pixel lighting Vertex Lighting Lighting is computed per-vertex calculation happens in the vertex shader lighting/color information is then linearly interpolated across faces and rasterized it is cheaper, faster (since there are fewer vertices compared to pixels) but noticeable artifact with low-poly objects Per-Pixel Lighting Lighting is computed per-pixel/fragment (but what is this exactly? see the example below) Calculation happens in the fragment shader normal information (passed from vertex shader) is interpolated on the faces, lighting/color is calculated and rasterized. it is more expensive but less artifact Example of a per-pixel lighting shader Vertex Shader 123456789101112131415161718#version 330 corelayout (location &#x3D; 0) in vec3 aPos;layout (location &#x3D; 1) in vec3 aNormal;out vec3 FragPos;out vec3 Normal;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos &#x3D; vec3(model * vec4(aPos, 1.0)); Normal &#x3D; mat3(transpose(inverse(model))) * aNormal; gl_Position &#x3D; projection * view * vec4(FragPos, 1.0);&#125; Fragment Shader 123456789101112131415161718192021222324252627282930313233#version 330 coreout vec4 FragColor;in vec3 Normal; in vec3 FragPos; uniform vec3 lightPos; uniform vec3 viewPos; uniform vec3 lightColor;uniform vec3 objectColor;void main()&#123; &#x2F;&#x2F; ambient float ambientStrength &#x3D; 0.1; vec3 ambient &#x3D; ambientStrength * lightColor; &#x2F;&#x2F; diffuse vec3 norm &#x3D; normalize(Normal); vec3 lightDir &#x3D; normalize(lightPos - FragPos); float diff &#x3D; max(dot(norm, lightDir), 0.0); vec3 diffuse &#x3D; diff * lightColor; &#x2F;&#x2F; specular float specularStrength &#x3D; 0.5; vec3 viewDir &#x3D; normalize(viewPos - FragPos); vec3 reflectDir &#x3D; reflect(-lightDir, norm); float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), 32); vec3 specular &#x3D; specularStrength * spec * lightColor; vec3 result &#x3D; (ambient + diffuse + specular) * objectColor; FragColor &#x3D; vec4(result, 1.0);&#125; As you can see, fragment position and normal information are passed into the fragment shader from vertex shader (where the pre-compute happens), the lighting calculation (Phong lighting) is calculated per-fragment. On a related note: gpu cost are related to 1. how many vertices are passed in to the gpu from buffer and 2. how complex the lighting calculation is in the fragment shader (this could be the algorithm/model complexity, and the number of passes); Forward vs. Deferred Rendering Forward Rendering The standard, out-of-the-box rendering technique Geometries are passed to gpu, going through vertex shader and fragment shader, with each geometry and each light computed separately one at a time to form the final render. Render complexity: O(num of geometry fragments * num of lights) Deferred Rendering Render is deferred until all geometry has been processed Geometries are passed to gpu, going through vertex shader and fragment shader (without lighting pass), final rendering is computed/combined with multiple render passes (one pass for getting all geometry information to G-buffer, second pass for compute lighting based on the G-buffer). Render complexity: O(screen resolution * num of lights) Discussion Everything all comes down to lighting, as gpu can easily handle vertex information, but the most expensive are lighting calculation which can easily slow down the rendering. Forward rendering iterates and compute each fragments of each geometry, no matter if it overlaps or is hidden by other fragments. So for each pixel, we could have already run multiple fragment shaders. This is where deferred rendering come in handy, the G-buffer stores information such as color, normal and depth. The lighting later on can know how to produce the final render by combining all the information (For example: depth test can also cull out all the fragments that are being obscured). So essentially, each pixel only runs a single fragment shader. Rasterization vs. Ray tracing The forward, deferred rendering techniques are all in the realm of rasterization, which is the most popular and traditional real-time rendering technique. With the advance of hardware, ray tracing, which is computationally demanding (usually used in films/animation) can now be used in real-time video games. Rasterization We gather objects information and projects each one by one on screen (per fragment), fragment shader computes the final color of every fragments to form pixels on screen. The fundamental of rasterizing is that for each object/geometry, we look at (rasterize it) it’s verts/triangles to cover pixels. So, as discussed in deferred rendering, every object is drawn but not all of them are displayed on screen. This overdraw can be accelerated by using deferred shading’s depth test. Ray tracing We cast rays from our eyes (camera) for each pixel and gather information of those rays as they travel through/intersects with objects and interacts with lights to form the final render on screen. The fundamental of ray tracing is that for each pixel, we look at (shoot a ray) each object/geometry to see how they contribute to the color of that pixel. As for ray tracing, we need to shoot many rays for each pixel, and more when there are reflection and refraction. One way to accelerate this is to use bounding volume. Discussion The most significant difference in visual is that ray tracing is physically more accurate than rasterization, thus more realistic. Which is more apparent in dynamic environment with objects that reflects and refract. Rasterization needs many estimation techniques to handle lighting and shadowing such as more render passes, baked light map, cubemap reflection, but ray tracing gets all the results out of the box. Reference Envato tuts+ - Forward Rendering vs. Deferred Rendering Learn OpenGL - Deferred Shading Wikipedia - Deferred Lighting Learn OpenGL - Basic Lighting Knowww - Per-vertex vs. per-fragment lighting Unity Forum - What’s the difference between per-pixel and per-vertex lit in Forward Rendering? Youtube - OpenGL Fragment Shaders | How Do Fragment Shaders Work? Nvidia - Ray Tracing Essentials Stack Exchange - Mirror Reflections: Ray Tracing or Rasterization? Quora - What is the diferrence between ray tracing and very high shader details?","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"graphic programming","slug":"graphic-programming","permalink":"https://www.xingyulei.com/tags/graphic-programming/"}]},{"title":"CFX Cloth Pipeline","slug":"cfx-pipeline","date":"2020-09-05T04:00:00.000Z","updated":"2021-09-20T03:44:59.944Z","comments":true,"path":"post/cfx-pipeline/","link":"","permalink":"https://www.xingyulei.com/post/cfx-pipeline/","excerpt":"","text":"Me and CFX Dynamic simulation is such a cool thing, you place some geo in the scene, put in some parameters, and the machine will handle the rest. When I started learning dynamics, my first thought was: why do we even need artist? the algorithm seems to handle everything nicely. After some basic training with nCloth and Qualoth in Maya, I felt more comfortable but also more confused. I felt lack of control. The result out-of-the-box was very convincing for me at that time, and I struggled to figure out how to improve the look. Moreover, I had little idea on how anyone would spend their entire career on something that is pre-determined and so reliable on algorithms. My logic was that it’s difficult to have artistic control by adjusting physical parameters in the solver/cloth setting. And after each adjustment, you would wait for the solve which takes up a long time. Next, I started to mess around with Marvelous Designer, creating and stitching patterns to make virtual clothes. They even have real-time simulation. Later on, I found out that grooming or designing cloth is mostly done by modelers in character art/design department. Lesser work for cfx. Finally, I began my professional cfx career, stayed a lot of overtime to meet delivery deadlines, the experience was quite insane. Overview Below, I summarized what I learned on the overview of cfx pipeline, based off limited experience in the industry. Pre CFX Stage Character team creates the character model: including costume Rigging team rigs the character model: the rig can be easily extracted to joint and separated meshes (body and cloth) cloth is usually wrapped around the character body mesh Animation team finishes the body animation CFX Stage Cloth Rig Building Cloth Sim (explained further in here) Post CFX Stage Everything is sent to Scene Assembly department, including: Final body mesh is exported as cache (Note: body mesh under cloth can be modified from animation to avoid penetration to cloth) Clothes final cache Cloth Rig Building Each character has its own set of costumes, in different scenes and sequences. Sim is performed on a sequence level (need to pay extra attention to keep cloth continuity), same as animation. And cfx artists would bring in the corresponding cloth rig over and over, so the rig building part is very important. As the upstream dependency for cloth sim, the better cloth rig created, the easier down the line for other cfx artists to sim. The rig building contains the following part: Set Up LODs The full resolution geo that character team contains millions vertices/faces which is used for rendering. It is generally not a good idea to sim the full rez geo as the sim would take forever. Ideally, we want higher resolution geo, as the crease is more detail and collisions are more accurate. The first step is for cfx artist to create low/mid/high rez three levels of LODs to represent the original clothes. The same goes for character mesh, low/mid/high rez LODs for setting up collision purpose. Common techniques: give more poly count to higher deformed area single layer mesh for simulation. re-use meshes from previous project with similar clothes design Set Up Parameters The rig is being built up by setting cloth attributes such as density, compress/stretch, drag and so on. solver settings (as solver will get imported to separate sequences) such as max iteration and sub steps. These parameters are not fixed, they are roughly decided based on the material and complexity of the costume. There are also constraints, collider attribute and more, later version may include dynamics, more advance usage like wind or turbulence. Common technique: based on the material, parameters can be re-used Test and Iterate After the master cloth rig is set up for the costume for the character. Animation will provide the walk cycle to test the cloth sim result. Lead and sups will make feedbacks and artists will adjust the parameters. The testing and iterating master cloth rig is an ongoing process: as later on during production, the rig will be exposed to real action, and other artist will call out certain for more improvements. Cloth Simulation Pre-processing Animation Before starting the sim, character animation needs to be pre-process to start from T-pose and blend to the start of the sequence, the reason for this is character in T-pose or neutral pose have no intersecting body part, thus giving the most stabled start point. Pre-processing animation: the character will transition from T-pose to the start of the sequence animation using joint blending, there will be a transition time as a parameter the character will hold at the start of the sequence animation for a period of time, this hold time is an adjustable parameter as well. the character will go from start to finish the entire sequence animation. All the previous parts are stitched into one go and export as cache (pc2 or alembic) Also need to be mindful if body intersection is happening during the T-pose blending, since this is an automated transition. Body intersection may still happen during maya animation since not all parts are exposed to the camera angle. Areas that needs special attention: arm pit, arm and leg. T-Pose Transition The pre-processed animation cache, and the cloth rig both get imported during this stage, the file contains all the necessary cloth setup (cloth, collider, constraint, dynamics etc) which is the latest from the master cloth rig. The steps below would match the pre-processed animation in its order: the cloth rig is imported in the scene onto the character in relaxed T-pose. the cloth sim starts as the character transition (T-pose to animation) begins, cloth will slowly move along and begins to settle on the character as gravity kick in. the cloth would settle completely, as the character holds at the animation start frame. Then begins the actual sim, as all the steps mentioned above aren’t in the animation frame range. Sim, Evaluation; Adjust and Re-sim Depending on the sim file step up, frame range, complexity of the cloth rig, the quality of the sim setting, the sim time may vary. Usually it is acceptable to have 30 minutes of sim time for 1000 frames. The first thing to do no matter what is to let the sim run once, the sim cache is loaded when finished so you can playblast and evaluate in real-time. This first playblast is out of the box sim result, which will give you a general idea of the sequence. When the result is not ideal, it is always worth making adjustments and do a re-sim, rather than cleaning it up. If some sim takes exceptionally long and the result is still unusable no matter what, it could be issues related to master cloth rig not setup well. The rule of thumb is: consider which would cost less effort: change parameter and re-sim or use the current result and make clean up. Also need to consider how easy it is to implement changes after reviews. General Techniques: Even though body animation is adjusted prior to this stage, body and cloth penetration may still occur not for body intersecting, but due to the space between them aren’t enough for cloth to settle down. There could be cases where painting value maps are necessary. Adding scene specific constraint could help. Clean-up The acceptable result sim cache gets exported to this stage, where a cloth rig reads the cache and the original full rez costume is wrapped onto this cloth. The wrapping is important as it’s served as upscaling the resolution. The algorithm is essential as wrapping evaluation happens everyframe on high poly objects, which can greatly impact playback speed. Clean up tools mostly are related to deformer that could affect the shape of the cloth, for example: when small penetration happens, cloth can be pull out, or skin can be pushed down; there could be unwanted hard edges or creases, which can be smoothed. One of the tool that proves to be very helpful is when dealing cloth jittering and unstabled in a static scene, the tool would pick a frame and lock the cloth sim result, then wrap that result onto the body, which affects to all other frames. There’s always an option to blend back to animation cloth, as the origin costume is weight painted and animated. This is useful to tone down crazy movement, or blend back to animation cloth shape. Next would be submit and review, needless to say, proper lighting is important as it could expose/hide certain areas. Also camera focal point, effects can also play a huge role in the review. More Pipeline Ideas The above pipeline can be divided into three stages, with three seperate maya file/session handling each stage. Making each one of them cleaner, faster and easier to work with. The pre-sim stage deals with pre-processing and T-pose transition; The sim stage only are meant for siming and adjusting sim settings; The post-sim stage is for dealing with clean-up and export. One of the legacy workflow bundles all three stages into one file, and the sim process was really slow, this is due to multiple layers to the cloth rig, mainly the wrapping causing the evaluation to significantly slow down. Sim in batch mode: since we generally don’t care what happens during the sim, and care only the result after the sim went through, running the simulation without having the gui open makes sense and speed up the process. To record the sim output result, remember to add a snapshot function in the batch script to capture every frame. Cloth setting import/exporter: use for keep record of settings that worked well with scenes, this could be shared to other cfx artist, it can also be useful just for inspection all the parameters from leads and not having to open your chunky maya file and find all the nodes.","categories":[{"name":"pipeline discussion","slug":"pipeline-discussion","permalink":"https://www.xingyulei.com/categories/pipeline-discussion/"}],"tags":[{"name":"cfx","slug":"cfx","permalink":"https://www.xingyulei.com/tags/cfx/"}]},{"title":"Maya API (3. Custom Deformer)","slug":"maya-api-deformer","date":"2019-11-11T05:00:00.000Z","updated":"2021-12-05T23:28:18.700Z","comments":true,"path":"post/maya-api-deformer/","link":"","permalink":"https://www.xingyulei.com/post/maya-api-deformer/","excerpt":"","text":"API 1.0 custom deformer Example Note: MPxDeformerNode is only available in API 2.0 Custom Attribute vs. Built-in Attribute In the last chapter, we know how to create custom numeric type attribute using MFnNumericAttribute. Sometimes in our node, we want to access existing built-in attribute. We do so by using OpenMayaMPx.cvar.MPxDeformerNode_(attributeName) before Maya 2016, we use OpenMayaMPx.cvar.MPxGeometryFilter_(attributeName) after 2016. Obtain Input Geometry In the sample code, we define our custom function getDeformerInputGeom(self, dataBlock, geomIndex) to obtain the input mesh to the deformer node. We will discuss this later. Accessory Node Accessory node acts like a secondary driver node connected to our deformer so they can influence the deformation. In the sample code, our accessory node is a locator which when we connects its world matrix, it will change our mesh’s deformation when translating. Custom Dependency Node vs. Custom Deformer Node Registration: In our previous chapter, we register our node using registerNode() with node type: omMPx.MPxNode.kDependNode, in deformer node, we use omMPx.MPxNode.kDeformerNode as our node type. Inheritance: We now inherit our class from omMPx.MPxDeformerNode instead of omMPxNode there’s still compute() in MPxDeformerNode class, but we want to write our deformation algorithm in deform(). Accessory Node: accessoryNodeSetup(self, dagModifier) and accessoryAttribute(self) is override to allow us to control accessory node along with our deformer. Procedure Step 1: Declare attributes (Same as last chapter) Step 2: Initialize Node Node Creator 12def nodeCreator(): return mpx.asMPxPtr(MyDeformer()) Only API 1.0 is available. Node Initializer 12345678910111213141516171819202122232425262728def nodeInitializer(): # 1: create reference to numericAttribute and matrixAttribute function sets numericAttrFn = om.MFnNumericAttribute() matrixAttrFn = om.MFnMatrixAttribute() # 2: create attribute using the function set MyDeformer.inNumAttr = numericAttrFn.create(&#x27;num&#x27;, &#x27;n&#x27;, om.MFnNumericData.kFloat, 0.0) numericAttrFn.setMin(-1.0) numericAttrFn.setMax(1.0) numericAttrFn.setReadable(False) MyDeformer.inMatAttr = numericAttrFn.create(&#x27;matrix&#x27;, &#x27;m&#x27;) matrixAttrFn.setStorable(False) matrixAttrFn.setConnectable(True) # 2.5: access built-in attribute using OpenMayaMpx.cvar.MPxGeometryFilter_outputGeom outputGeom = mpx.cvar.MPxGeometryFilter_outputGeom # 3: attach attribute MyDeformer.addAttribute(MyDeformer.inNumAttr) MyDeformer.addAttribute(MyDeformer.inMatAttr) # 4: add circuit (relationship in-&gt;out) MyDeformer.attributeAffects(MyDeformer.inNumAttr, ouputGeom) MyDeformer.attributeAffects(MyDeformer.inMatAttr, ouputGeom) # 5: make attribute paintable cmds.makePaintable(nodeName, &#x27;weights&#x27;, attrType=&#x27;multiFloat&#x27;, shapeMode=&#x27;deformer&#x27;) we access the output Geometry attribute so we can later add relationship to it. RegisterNode 1mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDeformNode) De-registerNode 1mplugin.deregisterNode(nodeID) Step 3: Initialize Node （Actual Deform Algorithm） 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyNode(om.MPxDeformNode): inNumAttr = om.MObject() inMatAttr = om.MObject() def __init__(self): om.MPxDeformNode.__init__(self) def deform(self, dataBlock, geomIterator, localToWorldMatrix, geomIndex): # step 1: access built-in attribute value using attribute name and attribute handle envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope envelopeHandle = dataBlock.inputValue(envelopeAttr) envelopeValue = envelopeHandle.asFloat() # step 1.5: access custom attribute value inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr) inNumValue = inNumHandle.asFloat() # step 1.55: access custom translate value connected to an accessory node inMatHandle = dataBlock.inputValue(MyDeformer.inMatAttr) inMatValue = inNumHandle.asMatrix() transMatrix = om.MTransformationMatrix(inMatValue) # matrix type translateValue = transMatrix.getTranslation(om.MSpace.kObject) # vector type # step 2: access input mesh inputMesh = self.getDeformerInputGeom(dataBlock, geomIndex) # step 2.5: access mesh normals meshFn = om.MFnMesh(inputMesh) normalVectorArray = om.MFloatVectorArray() # create float vector array to store normal vector meshFn.getVertexNormals(False, normalVectorArray, om.MSpace.kObject) # (average normal or not?, the array to store, normal space) # step 3: iterate the mesh vertices and deform it newVertexPosArray = om.MPointArray() # to store new vertices position while not geomIterator.isDone(): vertexPos = geomIterator.position() vertexIndex = geomIterator.index() normalVector = om.MVector(normalVectorArray[vertexIndex]) # built-in function weightValue(dataBlock, geomIndex, vertexIndex) weight = self.weightValue(dataBlock, geomIndex, vertexIndex) # vertexPos.x = vertexPos.x + [calculation of normalVector.x and translateValue[0]] * envelopeValue * weight newVertexPosArray.append(vertexPos) geomIterator.next() geomIterator.setAllPositions(newVertexPosArray) To access a value from an attribute, we use handle = dataBlock.input/outputValue(MyNode.attr) if we have a custom attribute inNumAttr: inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr) inNumValue = inNumHandle.asFloat() if we have a built-in attribte envelope: we first get our attribute name envelope envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope envelopeHandle = dataBlock.inputValue(envelopeAttr) envelopeValue = envelopeHandle.asFloat() To get normal for individual vertices on our input mesh, we first need to obtain our input mesh using our own function: getDeformerInputGeom(self, dataBlock, geomIndex). And using mesh function set MeshFn’s getVertexNormals() we store the normal vector in om.MFloatVectorArray() type array. To deform our mesh: we use the geometry iterator to perform iteration on each mesh vertex and re-calculate its position. We combine the use of geoIterator.position() and geomIterator.setPosition(point) or geomIterator.setAllPositions(pointArray). To access weight value on each vertex, we use built-in function weightValue(dataBlock, geomIndex, vertexIndex). In which, geomIndex is provided in deform() and vertexIndex is from geomIterator. Step 3.1: Get in-Mesh 1234567891011def getDeformerInputGeom(self, dataBlock, geomIndex): inputAttr = mpx.cvar.MPxGeometryFilter_input inputHandle = dataBlock.outputArrayValue(inputAttr) # use outputArray instead of inputArray to avoid re-computation inputHandle.jumpToElement(geomIndex) inputElementHandle = inputHandle.outputValue() inputGeomAttr = mpx.cvar.MPxGeometryFilter_inputGeom inputGeomHandle = inputElementHandle.child(inputGeomAttr) # this is different from how we usually get handler inputGeomMesh = inputGeomHandle.asMesh() return inputGeomMesh At this point, I can’t fully interpret the meaning of this segment. Step 4: Accessory Node 1234567891011121314151617181920def accessoryNodeSetup(self, dagModifier): # step1: create the accessory node using the supplied dagModifier locator = dagModifier.createNode(&#x27;locator&#x27;) # step2: access accessory node&#x27;s attribute(can&#x27;t use mplug type, has to be mobject type) # access dependency node function set dependNodeFn = om.MFnDependencyNode(locator) matrixPlug = dependNodeFn.findPlug(&#x27;worldMatrix&#x27;) # this returns mplug type attribute, we need mobject type attribute matrixAttr = matrixPlug.attribute() # step3: connect mobject type(required) together # param: accessory node(mobject), accessory attr(mobject), deformer node(mobject: using self.thisMObject()), deformer attr(mobject) mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr) # now the accessory node&#x27;s worldMatrix is driving to the custom in-matrix of the deformer node return mConnectStatusdef accessoryAttribute(self): # returns the deformer node attribute connected return MyDeformer.inMatAttr The dagModifer is supplied in the accessory node. We use dagModifier’s connect function to connect the accessory node’s attribute to our deformer node’s attribute. In this case, we have accessory’s attribute: worldMatrix (a built-in attribute obtained from MFnDependencyNode.findPlug()) and our custom defined MyDeformer.inMatAttr. One thing to note is that, the .connect() only takes MObject which we cannot supply MPlug type object matrixPlug = ...findPlug('attributeName'), we perform an additional step matrixAttr = matrixPlug.attribute() to get the MObject type attribute. Now we supply .connect() with parameters: an accessory node (MObject type), accessory node’s attribute (MObject type), deformer node (MObject type) and deformer node’s attribute (MObject type) as follows: mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr)","categories":[{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Maya API (2. Custom Node)","slug":"maya-api-node","date":"2019-11-10T05:00:00.000Z","updated":"2021-12-05T23:22:52.622Z","comments":true,"path":"post/maya-api-node/","link":"","permalink":"https://www.xingyulei.com/post/maya-api-node/","excerpt":"","text":"API 2.0 custom node example Data block (MDataBlock) Data block refers the entire container of a node. This container stores all the values for each attribute of the node. The datablock of this node is provided in the compute() function. Plug (MPlug) Plug is the outer plug of the node which provides the connections to other node’s plug. The MPlug usually connects the plug from another node and the value of a certain attribute of this node. The plug is also provided in the compute() function Data handle (MDataHandle) Data handle usually stores an attribute’s value. We can set a value to an attribute using MDataHandle.setType(value), and get an attribute’s value using **value = MDataHandle.asType()**. Procedure Step 1: Declare attributes (MObject) in the class 123456789class MyNode(om.MPxNode): inAttr = om.MObject() outAttr = om.MObject() def __init__(self): om.MPxNode.__init__(self) def compute(self, plug, dataBlock): pass inAttr refers to the input attribute that we are creating, outAttr refers to the output attribute that we are creating. Both are declared as MObject() type. We will later access them using MyNode.inAttr and MyNode.outAttr. Step 2: Initialize Node Node Creator 12def nodeCreator(): return MyNode() Node Creator in API 2.0 directly returns an instance to the class, API 1.0 uses a pointer like in command plugin. Node Initializer 123456789101112131415161718def nodeInitializer(): &#x27;&#x27;&#x27;1: create reference to attribute function set such as numericAttribute&#x27;&#x27;&#x27; numericAttrFn = om.MFnNumericAttribute() &#x27;&#x27;&#x27; 2: create attribute using the function set&#x27;&#x27;&#x27; MyNode.inAttr = numericAttrFn.create(&#x27;in&#x27;, &#x27;i&#x27;, om.MFnNumericData.kFloat, 1.0) numericAttrFn.readable = True numericAttrFn.writable = True MyNode.outAttr = numericAttrFn.create(&#x27;out&#x27;, &#x27;o&#x27;, om.MFnNumericData.kFloat) numericAttrFn.readable = True numericAttrFn.writable = False &#x27;&#x27;&#x27; 3: attach attribute&#x27;&#x27;&#x27; MyNode.addAttribute(MyNode.inAttr) MyNode.addAttribute(MyNode.outAttr) &#x27;&#x27;&#x27; 4: add circuit (relationship in-&gt;out)&#x27;&#x27;&#x27; MyNode.attributeAffects(MyNode.inAttr, MyNode.outAttr) MFnNumericAttribute provides the function sets to create an attribute for numeric type attribute. There’s also MFnMatrixAttribute to create matrix type attribute and so on. Using the function set’s create() function, we add parameters for attribute’s long name, short name, data type, and default value (optional). This returns a MObject type attribute which is attached to the function set. We store it in the attribute declared earlier in the class. Set the attribute’s property using function set, such as readable, writable, hidden, storable, connectable (In API1.0, use like this numericAttrFn.setReadable(True)) Using the MyNode.addAttribute(MyNode.inAttr) to attach an attribute to the node Using the MyNode.attributeAffects(MyNode.inAttr, MyNode.outAttr) to design the affect relationship between attributes, in this case, change of inAttr will affect `outAttr. RegisterNode 1mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDependNode, nodeClassify) Parameters: name of the node, id of the node, node creator function, node initializer function, node type (DependNode or DeformNode…), node classification (utility, shading…) Example: nodeID = om.MTypeId(0x55555) nodeClassify = 'utility/general' De-registerNode 1mplugin.deregisterNode(nodeID) Step 3: Initialize Node 12345678910111213141516171819202122232425class MyNode(om.MPxNode): inAttr = om.MObject() outAttr = om.MObject() def __init__(self): om.MPxNode.__init__(self) def compute(self, plug, dataBlock): if plug == MyNode.outAttr: # 1: get datablock handle (inputValue returns MDataHandle type object) inHandle = dataBlock.inputValue(MyNode.inAttr) outHandle = dataBlock.outputValue(MyNode.outAttr) # 2: extract input value from the handle inValue = inHandle.asFloat() # 3: create logic and set output value outValue = inValue * 2 outHandle.setFloat(outValue) # 4: mark output plug as clean outHandle.setClean() else: return om.kUnknownParameter When MyNode.outAttr is dirty (meaning it needs to recompute), we use if plug == MyNode.outAttr: to identify this certain plug. (this if statement will work, even if plug is MPlug type and MyNode.outAttr is MObject type) We have already identified what input attribute is affecting this plug, in order to retrieve the value of this input, we need to attach a data handle on the data block specifying this certain input attribute we want to retrive. Therefore, we have handle = dataBlock.input/outputValue(MyNode.attr) Next, we use value = handle.asFloat() and handle.setFloat(value) to get and set the value from and to the attribute. (float type as example) Last, we mark the current plug as clean, by setClean() to the outHandle","categories":[{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Maya API (1. Command Plugin with Flags)","slug":"maya-api-command","date":"2019-11-09T05:00:00.000Z","updated":"2021-12-05T23:50:48.001Z","comments":true,"path":"post/maya-api-command/","link":"","permalink":"https://www.xingyulei.com/post/maya-api-command/","excerpt":"","text":"Definition: “Flags” vs “Argument” Take this as an example: cmds.group('circle1', 'sphere1', name='group1') circle1 and sphere1 are arguments name is the flag and group1 is the value Another example: cmds.polyCube(sx=10, axis=[0, 0, 1]) no argument is specified sx is the flag’s short name, subdivisionX is the flag’s long name [0, 0, 1] is axis flag’s value, each individual number is called parameters Procedure Step 1: Declare flag name outside the class 12345firstFlagShortName = &#x27;-f&#x27;firstFlagLongName = &#x27;-first&#x27;secondFlagShortName = &#x27;-s&#x27;secondFlagLongName = &#x27;-second&#x27;# more flags ... Step 2: Add flag and argument in syntax creator outside of class (this syntax creator will be further included in the plugin initialize function) 1234567891011121314151617def syntaxCreator(): &quot;&quot;&quot; create a OpenMaya.MSyntax object to store flags and argument &quot;&quot;&quot; syntax = om.MSyntax() # add flags with short name, long name, and value type syntax.addFlag(firstFlagShortName, firstFlagLongName, om.MSyntax.kDouble) syntax.addFlag(secondFlagShortName, secondFlagLongName, (om.MSyntax.kDouble, om.MSyntax.kDouble, om.MSyntax.kDouble)) # add more flags ... # add argument using MSyntax.addArg() function # add argument is not discussed, refer to document later return syntax Step 3: Parsing flags, called inside the class’s doIt function 123456789101112131415def parseArguments(self, args): &quot;&quot;&quot; instantiate MArgParser ojbect, self.syntax() refers to the syntax created in step 2 &quot;&quot;&quot; argData = om.MArgParser(self.syntax(), args) # check if certain flags are set if argData.isFlagSet(firstFlagShortName): firstValue = argData.flagArgumentString(firstFlagShortName, 0) if argData.isFlagSet(secondFlagShortName): secondParam0 = argData.flagArgumentInt(secondFlagShortName, 0) secondParam1 = argData.flagArgumentInt(secondFlagShortName, 1) secondParam2 = argData.flagArgumentInt(secondFlagShortName, 2) # parse more flags ...","categories":[{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Maya API (0. Introduction)","slug":"maya-api-intro","date":"2019-11-08T05:00:00.000Z","updated":"2021-12-05T23:51:17.231Z","comments":true,"path":"post/maya-api-intro/","link":"","permalink":"https://www.xingyulei.com/post/maya-api-intro/","excerpt":"","text":"Overview Different from Maya Command, Maya API offers more low level access to Maya’s feature. You can think of Maya in multiple layers: Bottom Layer: System OS Maya Core: The entire Maya program written in C++ Maya API: Designated API exposed to developers, which can access Maya Core Maya Command: Helper Functions calling multiple Maya API Maya GUI: User graphics interface While Maya Command (MEL/Python) is most commonly used to write scripts, because it has fast prototyping and easy to learn. The downside is that it is often slow and can’t offer low level access to Maya Core. Maya API on the other hand, is complicated, but offers faster speed and most flexibility. It comes with Python and C++. Python API has version 1.0 and 2.0. Difference Between Python API vs C++ API API1.0 vs 2.0 API 1.0 (Before 2012) has acess to more features offered in C++ API 2.0 faster and more pythonic, but some class such as OpenMayaFX, OpenMayaDeformerNode is not supported. General Format Difference import module 1.0 has a seperate maya.OpenMayaMPx along with maya.OpenMaya 2.0 has maya.api.OpenMaya including the original MPx command maya_useNewAPI 2.0 use this function to declare using API 2.0 cmd creator 1.0 uses a MPx pointer object to point to instance of the class 2.0 director returns the instance of the class other syntax difference will be discussed later","categories":[{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Tutorial - Run Maya in Batch Mode","slug":"maya-batch-mode","date":"2019-10-09T04:00:00.000Z","updated":"2021-12-05T23:10:30.443Z","comments":true,"path":"post/maya-batch-mode/","link":"","permalink":"https://www.xingyulei.com/post/maya-batch-mode/","excerpt":"","text":"Step 1. Import standalone module 12import maya.standalonemaya.standalone.initialize(name=&#x27;python&#x27;) sometimes, import error could occur 1ImportError: No module named maya.standalone Solution check your python interpreter, it should match the maya python2 version. I changed my project interpreter in my pycharm setting. setup system environment variable, like the following if error still occurs, please check your maya directory 1234567891011121314151617181920import sysimport osMAYA_LOCATION = &quot;C:/Program Files/Autodesk/Maya2018&quot;PYTHON_LOCATION = MAYA_LOCATION + &quot;/Python/Lib/site-packages&quot;os.environ[&quot;MAYA_LOCATION&quot;] = MAYA_LOCATIONos.environ[&quot;PYTHONPATH&quot;] = PYTHON_LOCATIONsys.path.append(MAYA_LOCATION)sys.path.append(PYTHON_LOCATION)sys.path.append(MAYA_LOCATION+&quot;/bin&quot;)sys.path.append(MAYA_LOCATION+&quot;/lib&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python/DLLs&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python/Lib&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python/Lib/plat-win&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python/Lib/lib-tk&quot;)print(&#x27;\\n&#x27;.join(sys.path)) Step 2. Add functions Let’s add a test function to our standalone script. 1234567891011121314def test(): import maya.cmds as cmds # full path to your Maya file to OPEN maya_file_to_open = r&quot;C:\\Users\\Lei\\Desktop\\test.ma&quot; # Open your file cmds.file(maya_file_to_open, o=True) # full path to your Maya file to IMPORT maya_file_to_import = r&quot;C:\\Users\\Lei\\Desktop\\import.ma&quot; # Import the file. the variable &quot;nodes&quot; will hold the names of all nodes imported, just in case. cmds.file(maya_file_to_import, i=True, type=&quot;mayaAscii&quot;) render = r&quot;C:\\Users\\Lei\\Desktop\\te.ma&quot; cmds.file(rename=render) cmds.file(force=True, save=True, options=&#x27;v=1;p=17&#x27;, type=&#x27;mayaBinary&#x27;) print(&#x27;a&#x27;) This test function opens a maya file on my desktop and import a maya file and save out as another file. Step 3. Executing through mayapy execute from command line to do so, make sure to add mayapy to your system environment variable. in system variable: add C:\\Program Files\\Autodesk\\Maya2018\\bin to Path open command prompt, and enter mayapy [directory/firstStandalone.py] execute using subprocess you can do it without going to command line, but by executing another .py using subprocess 1234567import subprocesscommand = &#x27;mayapy [directory/firstStandalone.py]&#x27;process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)process.wait()print(process.returncode) # this return the message from cmd Step 4. Standalone script with arguments Sometimes, we would want to pass arguments to our standalone script get argument as variable using sys.argv 1234import sysfile_path = sys.argv[1]file_name = sys.argv[2] Example from Toadstorm Nerdblog: 1234567891011121314151617181920212223242526272829import subprocessmaya_path = &#x27;directory/mayapy.exe&#x27; # mayapy or full path to mayapy.exescript_path = &#x27;directory/firstStandalone.py&#x27;def add_layer(file_names,layer_name): for file_name in file_names: command = r&#x27;mayapy &#123;&#125; &#123;&#125; &#123;&#125;&#x27;.format( script_path, file_name, layer_name ) process = subprocess.Popen( command, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) process.wait() print(process.returncode) # this return the message from cmd if __name__ == &#x27;__main__&#x27;: # define a list of filenames to iterate through files = [&#x27;file1&#x27;, &#x27;file2&#x27;, &#x27;file3&#x27;] render_layer = &#x27;a new render layer&#x27; # run procedure, assuming you&#x27;ve already defined it add_layer(files, render_layer) Reference Tech-Artist Org - Import maya.standalone problem Stack Overflow - use external python script to open maya and run another script inside maya Stack Overflow - How to use an external interpreter for Maya? Toadstorm Nerdblog - Python in Maya Standalone","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Qt Template for Maya","slug":"qt-template","date":"2019-01-16T05:00:00.000Z","updated":"2021-12-05T23:07:57.454Z","comments":true,"path":"post/qt-template/","link":"","permalink":"https://www.xingyulei.com/post/qt-template/","excerpt":"","text":"Import Qt Module Either using PyQt/PySide or a custom binding, but the import is similar 12from Qt import QtCore, QtGui, QtWidgetsfrom Qt import _loadUi Parented to Maya main window by default Qt window is not parented to Maya application 123456789101112from shiboken2 import wrapInstancedef get_maya_main_window(): import maya.OpenMayaUI main_window_ptr = maya.OpenMayaUI.MQtUtil.mainWindow() return wrapInstance(long(main_window_ptr), QtWidgets.QMainWindow)class ModuleUI(QtWidgets.QDialog): def __init__(self, parent=get_maya_main_window()): super(ModuleUI, self).__init__(parent) _loadUi(UI_PATH, self) self.setWindowFlags(QtCore.Qt.Window) Using QApplication Launch as standalone application using QApplication, or if a QApplication exist, there’s no need to instantiate it. use QtWidgets.QApplication.instance() to check 12345678910if __name__ == &#x27;__main__&#x27;: import sys if QtWidgets.QApplication.instance(): window = ConfigEditor() window.show() else: app = QtWidgets.QApplication(sys.argv) window = ConfigEditor() window.show() sys.exit(app.exec_()) Make Window Dockable Instantiate Widget When the UI has no parent (Maya main window), it will get instantly destroyed by the garbage collector, unless you keep an instance: 12345678# in the show functiondef show(): window = ModuleUI() window.show() return window# in maya script editorwin = moduleName.show() or using global variable to store the instance 1234567def show(): global window window = ModuleUI() window.show()# in maya script editormoduleName.show() Default Close Widget by default, closing the widget is hiding it not destroying the object 12345678def show(): window = ModuleUI() try: window.close() except: pass window.setAttribute(QtCore.Qt.WA_DeleteOnClose) window.show() Error in PyCharm When this error occurs, it is due to MayaDevKit environment MayaDevKit allows maya python command auto-completion, remove it from PyCharm 12app &#x3D; QtWidgets.QApplication(sys.argv)TypeError: &#39;NoneType&#39; object is not callable Reference Reddit - PyQt5 - Why do I get an Empty Window? Stack Overflow - pycharm use pyside2 TypeError: ‘NoneType’ object is not callable","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"},{"name":"template","slug":"template","permalink":"https://www.xingyulei.com/tags/template/"}]}],"categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"},{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"},{"name":"pipeline discussion","slug":"pipeline-discussion","permalink":"https://www.xingyulei.com/categories/pipeline-discussion/"},{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"c#","slug":"c","permalink":"https://www.xingyulei.com/tags/c/"},{"name":"unity","slug":"unity","permalink":"https://www.xingyulei.com/tags/unity/"},{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"},{"name":"style","slug":"style","permalink":"https://www.xingyulei.com/tags/style/"},{"name":"template","slug":"template","permalink":"https://www.xingyulei.com/tags/template/"},{"name":"graphic programming","slug":"graphic-programming","permalink":"https://www.xingyulei.com/tags/graphic-programming/"},{"name":"cfx","slug":"cfx","permalink":"https://www.xingyulei.com/tags/cfx/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]}