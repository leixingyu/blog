{"meta":{"title":"Tech Art Learning","subtitle":"","description":"","author":"Xingyu Lei","url":"http://xingyulei.xyz","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.027Z","comments":false,"path":"/404.html","permalink":"http://xingyulei.xyz/404.html","excerpt":"","text":""},{"title":"About Me","date":"2021-08-27T23:38:19.986Z","updated":"2021-08-27T23:38:19.986Z","comments":false,"path":"about/index.html","permalink":"http://xingyulei.xyz/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233Softwares &#x3D; [ &#39;Maya&#39;, &#39;Unity&#39;, &#39;Motion Builder&#39;, &#39;Houdini&#39;]Skills &#x3D; [ &#39;Python&#39;, &#39;C#&#39;, &#39;Qt&#39;, &#39;OpenGL, GLSL&#39;] Links &#x3D; &#123; &#39;Linkedin&#39;: &#39;https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;xingyu-lei&#x2F;&#39;, &#39;Github&#39;: &#39;https:&#x2F;&#x2F;github.com&#x2F;leixingyu&#39;, &#39;Youtube&#39;: &#39;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCyLd9tHXOtZDceAZyP8NC4g&#39;, &#39;Vimeo&#39;: &#39;https:&#x2F;&#x2F;vimeo.com&#x2F;techartlei&#39;,&#125;Education &#x3D; [ [Sichuan University, B.S. in Computer Science, 2014-2018], [University of Missouri, B.S. in Information Technology, 2016-2018], [Purdue University, M.S. in Computer Graphics Technology, 2018-2020]]Work Experience &#x3D; [ [Blur Studio, CFX Intern, 2019] [Blur Studio, CFX TD, 2020] [PlayStation Visual Arts, Technical Artist, 2021]]"},{"title":"分类","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.030Z","comments":false,"path":"categories/index.html","permalink":"http://xingyulei.xyz/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.030Z","comments":false,"path":"books/index.html","permalink":"http://xingyulei.xyz/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.031Z","comments":true,"path":"links/index.html","permalink":"http://xingyulei.xyz/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.032Z","comments":false,"path":"tags/index.html","permalink":"http://xingyulei.xyz/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-23T03:34:50.419Z","updated":"2021-02-07T16:58:04.032Z","comments":false,"path":"repository/index.html","permalink":"http://xingyulei.xyz/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"State Machine Unity Scripting API","slug":"unity-api-statemachine","date":"2021-08-29T04:00:00.000Z","updated":"2021-09-01T03:41:35.270Z","comments":true,"path":"post/unity-api-statemachine/","link":"","permalink":"http://xingyulei.xyz/post/unity-api-statemachine/","excerpt":"","text":"Introduction This post is not about state machine basic, rather how we would setup/access state machine parameters. There is a higher level Animator class to access a part of the animator features, but we need to use Unity’s Animations package in order to dive deeper. 1using UnityEditor.Animations; There’s a lot of parts composing Unity’s Animator: Layer, Parameter, State machine (and everything inside it including states of different kind, transition between states), there are of course multiple parameters inside a single state. The examples in this post is only about accessing states and state machines, as the rest is translatable. We start from the root: Base layer, if you think about it, a layer is essentially a state machine. Inside this root state machine are sets of states (including blend tree/state/sub-state machine) 12// getting the base layer state machineAnimatorStateMachine rootStateMachine = controller.layers[0].stateMachine; (Base Layer) Next up, a very confusing part of the scripting process are the definition of AnimatorStateMachine vs. ChildAnimatorStateMachine and AnimatorState vs. ChildAnimatorState. I really wish Unity provides internal ways to cast these to each other. To summarize: ChildAnimatorStateMachine[] and ChildAnimatorState[] is used in conjunction with Arrays as AnimatorStateMachine.states and AnimatorStateMachine.stateMachines will return the previous mentioned type. Instead of casting, they have an internal property ChildAnimatorStateMachine.stateMachine and ChildAnimatorState.state which respectively returns AnimatorStateMachine and AnimatorState type object States All states (state or. state with blendtree inside) 1234567891011121314151617181920212223ChildAnimatorState[] childStates = rootStateMachine.states;foreach(var childState in childStates)&#123; AnimatorState state = childState.state; print(state.name); // state with blendtree try &#123; var blendTree = (BlendTree)state.motion; foreach (var child in blendTree.children) &#123; print(&quot;\\t&quot; + child.motion.name); &#125; &#125; // simple state catch &#123; print(&quot;\\t&quot; + state.motion.name); &#125;&#125; (Simple state only contains a single clip) (BlendTree nested in a state) Sub-state machine 12345678910111213141516ChildAnimatorStateMachine[] childSubStateMachines = rootStateMachine.stateMachines;foreach(var childSubStateMachine in childSubStateMachines)&#123; // Convert `ChildAnimatorStateMachine` to `AnimatorStateMachine` AnimatorStateMachine subStateMachine = childSubStateMachine.stateMachine; print(subStateMachine.name); // all states in idle sub state machine ChildAnimatorState[] states = subStateMachine.states; foreach (var childState in states) &#123; print(&quot;\\t&quot; + childState.state.name); &#125;&#125; (Essentially, another sub layer of state machine) Reference https://docs.unity3d.com/Manual/StateMachineBasics.html https://docs.unity3d.com/ScriptReference/Animations.AnimatorStateMachine.html https://docs.unity3d.com/ScriptReference/Animator.Play.html","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://xingyulei.xyz/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"http://xingyulei.xyz/tags/Unity/"}]},{"title":"How to Resize QPixmap","slug":"qt-pixmap-scale","date":"2021-08-22T04:00:00.000Z","updated":"2021-09-01T03:41:35.220Z","comments":true,"path":"post/qt-pixmap-scale/","link":"","permalink":"http://xingyulei.xyz/post/qt-pixmap-scale/","excerpt":"","text":"Intro During my attempts to create custom alignment push buttons, I encountered an issue with icon having jagged looking (even if with low resolution). I use a custom paintEvent() drawing QPixmap, and this happens when I use scaled() to resize my pixmap. I noticed the icon does not have the jagged look with the built-in setIcon() and setIconSize in QPushButton. So I know there’s some wrong with my approach. The Test To really show out the difference, I first reduce the resolution of my image. 12345low_rez = QtCore.QSize(40, 40)high_rez = QtCore.QSize(400, 400)pixmap = QtGui.QPixmap(path)pixmap = pixmap.scaled(low_rez) I then increase the resolution back to normal. The default scale uses FastTransformation 1pixmap = pixmap.scaled(high_rez) This is the result: The Solution I’ve searched many forums and people were all saying: enable the SmoothTransformation, I tried but didn’t work. Later on I found out that the Qt translation to Python has a mis-match keyword argument: so instead of transformMode=Qt.SmoothTransformation, it should actually be mode=Qt.SmoothTransformation So here’s the solution: 12345pixmap = pixmap.scaled( high_rez, aspectRatioMode=QtCore.Qt.KeepAspectRatio, mode=QtCore.Qt.SmoothTransformation) and result: Extra I also found post saying it might be some settings with the QPainter, but it is not the issue for me. 1234painter = QtGui.QPainter(self)painter.setRenderHint(QtGui.QPainter.Antialiasing, True)painter.setRenderHint(QtGui.QPainter.SmoothPixmapTransform, True)painter.drawPixmap(self.pixmap) Reference https://doc.qt.io/qt-5/qpixmap.html","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"}]},{"title":"Qt Left Align Icon, Center Align Text (Python)","slug":"qt-button-alignment","date":"2021-08-21T04:00:00.000Z","updated":"2021-09-01T03:41:35.248Z","comments":true,"path":"post/qt-button-alignment/","link":"","permalink":"http://xingyulei.xyz/post/qt-button-alignment/","excerpt":"","text":"I recently needed to display a series of buttons for my shelf tool, the problem I’m having with this is that although every button has an icon and text label, they are displayed as different width. Using center-align made it look not uniform. Should I go with left-align? Well, there are buttons with relatively longer label and some with shorter ones, so it doesn’t look nice either with empty spaces on the right side. So the solution is obvious, separate the alignment of the icon and the label: the icon stays left-align to give a clear sign of broader, and the label would be center-align to make the width look uniform. (Left: default center align, Center: left align, Right: custom align) In the following section, I will demonstrate three methods of achieving this custom alignment effect: Overriding QPushButton paintEvent Create a subclass from QPushButton called MyButton: 123456789101112131415161718192021class MyButton(QtWidgets.QPushButton): def __init__(self, *args, **kwargs): super(MyButton, self).__init__(*args, **kwargs) def setPixmap(self, pixmap): self.pixmap = pixmap def sizeHint(self): parent_size = QtWidgets.QPushButton.sizeHint(self) return QtCore.QSize(parent_size.width() + self.pixmap.width(), max(parent_size.height(), self.pixmap.height())) def paintEvent(self, event): QtWidgets.QPushButton.paintEvent(self, event) pos_x = 5 # hardcoded horizontal margin pos_y = (self.height() - self.pixmap.height()) / 2 painter = QtGui.QPainter(self) painter.setRenderHint(QtGui.QPainter.Antialiasing, True) painter.setRenderHint(QtGui.QPainter.SmoothPixmapTransform, True) painter.drawPixmap(pos_x, pos_y, self.pixmap) With this method, we no longer use QIcon, we use pixmap instead. 123456789101112131415class TestUI(QtWidgets.QWidget): def __init__(self, parent=None): super(MethodTwo, self).__init__(parent) # initialization object layout = QtWidgets.QGridLayout() pb = MyButton(&#x27;test&#x27;) path = r&quot;xxx&quot; pixmap = QtGui.QPixmap(path).scaled(40, 40, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation) pb.setPixmap(pixmap) layout.addWidget(pb) self.setLayout(layout) Custom layout inside pushbutton Remember to send setText signals to textLabel instead of pushButton since this is label within push button’s layout 123456789101112131415161718192021222324class TestUI(QtWidgets.QWidget): def __init__(self, parent=None): super(MethodThree, self).__init__(parent) # initialization object layout = QtWidgets.QGridLayout() pb = QtWidgets.QPushButton() name = &quot;SP_MessageBoxCritical&quot; icon = self.style().standardIcon(getattr(QtWidgets.QStyle, name)) pb.setIcon(icon) pb.setStyleSheet(&#x27;text-align: left;&#x27;) pb.setLayout(QtWidgets.QGridLayout()) label = QtWidgets.QLabel(&#x27;test&#x27;) label.setAlignment(QtCore.Qt.AlignHCenter | QtCore.Qt.AlignVCenter) label.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents, 1) pb_layout = pb.layout() pb_layout.addWidget(label) layout.addWidget(pb) self.setLayout(layout) Use QProxyStyle I haven’t personally test it because I’m using a custom python Qt binding that doesn’t have QProxyStyle included but it’s worth putting it here in case someone is able to try it 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class ProxyStyle(QtWidgets.QProxyStyle): def drawControl(self, element, option, painter, widget=None): if element == QtWidgets.QStyle.CE_PushButtonLabel: icon = QtGui.QIcon(option.icon) option.icon = QtGui.QIcon() super(ProxyStyle, self).drawControl(element, option, painter, widget) if element == QtWidgets.QStyle.CE_PushButtonLabel: if not icon.isNull(): iconSpacing = 4 mode = ( QtGui.QIcon.Normal if option.state &amp; QtWidgets.QStyle.State_Enabled else QtGui.QIcon.Disabled ) if ( mode == QtGui.QIcon.Normal and option.state &amp; QtWidgets.QStyle.State_HasFocus ): mode = QtGui.QIcon.Active state = QtGui.QIcon.Off if option.state &amp; QtWidgets.QStyle.State_On: state = QtGui.QIcon.On window = widget.window().windowHandle() if widget is not None else None pixmap = icon.pixmap(window, option.iconSize, mode, state) pixmapWidth = pixmap.width() / pixmap.devicePixelRatio() pixmapHeight = pixmap.height() / pixmap.devicePixelRatio() iconRect = QtCore.QRect( QtCore.QPoint(), QtCore.QSize(pixmapWidth, pixmapHeight) ) iconRect.moveCenter(option.rect.center()) iconRect.moveLeft(option.rect.left() + iconSpacing) iconRect = self.visualRect(option.direction, option.rect, iconRect) iconRect.translate( self.proxy().pixelMetric( QtWidgets.QStyle.PM_ButtonShiftHorizontal, option, widget ), self.proxy().pixelMetric( QtWidgets.QStyle.PM_ButtonShiftVertical, option, widget ), ) painter.drawPixmap(iconRect, pixmap)if __name__ == &quot;__main__&quot;: app = QtWidgets.QApplication(sys.argv) app.setStyle(&#x27;fusion&#x27;) proxy_style = ProxyStyle(app.style()) app.setStyle(proxy_style) w = QtWidgets.QWidget() lay = QtWidgets.QVBoxLayout(w) icons = [ app.style().standardIcon(standardIcon) for standardIcon in ( QtWidgets.QStyle.SP_MediaPlay, QtWidgets.QStyle.SP_MediaPause, QtWidgets.QStyle.SP_MediaSeekBackward, QtWidgets.QStyle.SP_MediaSeekForward, ) ] for text, icon in zip(&quot;Play Pause Backward Forward&quot;.split(), (icons)): button = QtWidgets.QPushButton(text) button.setIcon(icon) lay.addWidget(button) w.show() sys.exit(app.exec_()) Reference https://stackoverflow.com/questions/44091339/qpushbutton-icon-aligned-left-with-text-centered https://stackoverflow.com/questions/56129402/qpushbutton-icon-left-alignment-text-center-alignment","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"}]},{"title":"How to Organize Custom Python Library","slug":"py-organize-module","date":"2021-08-14T04:00:00.000Z","updated":"2021-09-01T03:41:35.227Z","comments":true,"path":"post/py-organize-module/","link":"","permalink":"http://xingyulei.xyz/post/py-organize-module/","excerpt":"","text":"I saw this post on stack overflow and thought it is something worth summarizing How should we organize our own library? Method One Stack everything inside one root package, each module contains many functions, one utility module containing all the generic functions 1234567root (package) animation.py (module) audio.py (module) modelling.py (module) rigging.py (module) library.py (module) util.py (module) Method Two Have multiple separated packages, and split the code into smaller modules 1234567891011121314151617181920212223root (package) animation (package) __init__.py (module) core.py (module) utils.py (module) ui.py (module bar.py (module) audio (package) __init__.py (module) core.py (module) utils.py (module) ui.py (module foo.py (module) rigging (package) __init__.py (module) core.py (module) utils.py (module) ui.py (module foo.py (module) etc The __init__.py inside of each package would import all the necessary functions Conclusion Either are okay, but there are certain rules/recommendation to follow: Functions in the same module are closely connected Having fewer but bigger modules could be difficult to navigate Try to make each module standalone Having many separated modules makes import efficient, but the module should not be too small Reference https://stackoverflow.com/questions/52082078/best-way-to-keep-python-modules-organised","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"Style","slug":"Style","permalink":"http://xingyulei.xyz/tags/Style/"}]},{"title":"Qt QPushButton Detect Double Click","slug":"qt-detect-click","date":"2021-08-08T04:00:00.000Z","updated":"2021-09-01T03:41:35.195Z","comments":true,"path":"post/qt-detect-click/","link":"","permalink":"http://xingyulei.xyz/post/qt-detect-click/","excerpt":"","text":"It’s not as easy as it looks Built-in Double Click Hey, I thought this would be easy, since Qt offers a built-in event QEvent.MouseButtonDblClick. But the issue is it couldn’t distinguish a single click vs. a double click. Which means, a single click event will also be called if double clicked. Solution? Custom click detection with timeout Subclass QPushButton and override eventFilter() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MyButton(QtWidgets.QPushButton): right_clicked = QtCore.Signal() left_clicked = QtCore.Signal() double_clicked = QtCore.Signal() def __init__(self, *args, **kwargs): super(MyButton, self).__init__(*args, **kwargs) self.timer = QtCore.QTimer() self.timer.setSingleShot(True) self.timer.setInterval(250) self.timer.timeout.connect(self.timeout) self.is_double = False self.is_left_click = True self.installEventFilter(self) self.double_clicked.connect(self.double_click_event) self.left_clicked.connect(self.left_click_event) self.right_clicked.connect(self.right_click_event) def eventFilter(self, obj, event): if event.type() == QtCore.QEvent.MouseButtonPress: if not self.timer.isActive(): self.timer.start() if event.button() == QtCore.Qt.LeftButton: self.is_left_click = True else: self.is_left_click = False return True elif event.type() == QtCore.QEvent.MouseButtonDblClick: self.is_double = True return True return False def timeout(self): if self.is_double: self.double_clicked.emit() else: if self.is_left_click: self.left_clicked.emit() else: self.right_clicked.emit() self.is_double = False def left_click_event(self): print(&#x27;left clicked&#x27;) def right_click_event(self): print(&#x27;right clicked&#x27;) def double_click_event(self): print(&#x27;double clicked&#x27;) Reference https://www.qtcentre.org/threads/7858-Double-Click-Capturing https://stackoverflow.com/questions/19247436/pyqt-mouse-mousebuttondblclick-event","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"}]},{"title":"Constant in Python","slug":"py-constant","date":"2021-07-16T04:00:00.000Z","updated":"2021-09-01T03:41:35.285Z","comments":true,"path":"post/py-constant/","link":"","permalink":"http://xingyulei.xyz/post/py-constant/","excerpt":"","text":"Intro I recently saw some codes written by another tech artist, and he made a module called constant.py In it stored all the global variables and all the import modules, something like this: 12345678910111213141516#constant.pyimport module_aimport module_bimport module_cGLOBAL_VAR_MAX = 50GLOBAL_VAR_MIN = 10GLOBAL_VAR_TIMEOUT = 2000GLOBAL_NAME = r&#x27;random name&#x27;# or evenclass Constant(object): gravity = 9.8 is_true = True With this setup, all the module in the same project would just import the constant module and have access to all the imports and variable. I thought this was a neat way to make code cleaner by getting rid of all the duplicated imports that might happened. But turns out that there’s a lot of people against doing things like this. Constant in Python the root level where the constant lives actually matters: based on the style guide: Constants are usually defined on a module level and written in all capital letters with underscores separating words. Examples include MAX_OVERFLOW and TOTAL. also suggestions have mentioned to refrain from using class as it could be instantiated which makes no sense. (maybe a static class in another language would work) Separate module for import Despite the root level of constant this, is it a good practice to have a separate module for import? No, unless there’s a valid reason for all those modules to be collected under a common name. If not, then they should be kept separately. This is due to documentation, as other people open your file, they don’t get information on what is getting imported (what is needed) Same module import multiple times So if multiple files are importing the same module separately, does python optimize the import? Yes, python modules are considered as singletons, no matter how many times you import them they get initialized only once. unless reload is being called Reference https://stackoverflow.com/questions/5027400/constants-in-python-at-the-root-of-the-module-or-in-a-namespace-inside-the-modu https://stackoverflow.com/questions/40419582/in-python-do-you-need-to-import-modules-in-each-split-file https://stackoverflow.com/questions/6206204/python-importing-an-import-file https://stackoverflow.com/questions/296036/does-python-optimize-modules-when-they-are-imported-multiple-times","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"Style","slug":"Style","permalink":"http://xingyulei.xyz/tags/Style/"}]},{"title":"Qt Connect Signal in For Loop","slug":"qt-signal-in-for-loop","date":"2021-04-17T04:00:00.000Z","updated":"2021-09-01T03:41:35.252Z","comments":true,"path":"post/qt-signal-in-for-loop/","link":"","permalink":"http://xingyulei.xyz/post/qt-signal-in-for-loop/","excerpt":"","text":"Introduction We often needs to create ui elements on the fly, sometimes we do it in something like a for loop. An example would be creating a series of QPushButton and connect them to a function through different argument values. A example is shown below: 1234567891011121314151617class Demo(QtWidgets.QWidget): def __init__(self, parent=None): super(Demo, self).__init__(parent) # initialization object layout = QtWidgets.QVBoxLayout() for index in range(6): pushbutton = QtWidgets.QPushButton(&#x27;button &#123;&#125;&#x27;.format(index)) pushbutton.clicked.connect(lambda: self.trigger(index)) layout.addWidget(pushbutton) self.setLayout(layout) @staticmethod def trigger(index): print(&#x27;button &#123;&#125; clicked&#x27;.format(index)) Here I created six QPushButton and when I click them it should output which button is being clicked. But if you run this script and try to click each button it will always output “button 5 clicked” (aka, the last button). It is safely to assume that the argument passed during the for loop always result in the last index. Explanation Based on a kind response from stackoverflow: lambdas do not store the value of button when it is defined. The code describing the lambda function is parsed and compiled but not executed until you actually call the lambda. Therefore, when a button is clicked, the current value of that variable is used (the last index). What’s the solution? Lambda with solid variable Passing solid variable to the lambda 1pushbutton.clicked.connect(lambda _, i=index: self.trigger(index=i)) Note that we created another temporary variable before index as the first argument passed in the lambda will always return as False. Because Qt defines the signal QAbstractButton.clicked to take a single argument with a default value of False. Since your lambda is handling that signal, it gets called with False. Partial approach Use functools.partial also works 12from functools import partialpushbutton.clicked.connect(partial(self.trigger, index)) Note that in some cases where wrappers are being used in trigger function, it could be trickier to use this as oppose to lambda ###Reference https://stackoverflow.com/questions/27953895/first-lambda-capture-of-local-variable-always-false https://stackoverflow.com/questions/46300229/connecting-multiples-signal-slot-in-a-for-loop-in-pyqt","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"}]},{"title":"QWidget Template (without .ui file)","slug":"qt-widget-template","date":"2021-02-18T05:00:00.000Z","updated":"2021-09-01T03:41:35.266Z","comments":true,"path":"post/qt-widget-template/","link":"","permalink":"http://xingyulei.xyz/post/qt-widget-template/","excerpt":"","text":"Sometimes you need a quick window to display some information, but the built-in qt message boxes aren’t suitable for the job. Temporary Widget You can choose to create a widget class, but also for saving time, you can create a temporary custom widget example: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MainWidget(QtWidgets.QMainWindow): def __init__(self, parent=None): self.connectSignal() def connectSignal(self): self.someBtn.clicked.connect(self.openCustomWidget) def openCustomWidget(self): # initialize with a widget and a layout self.customWidget = QtWidgets.QWidget() layout = QtWidgets.QHBoxLayout(self.customWidget) # title self.customWidget.setWindowTitle(&#x27;Error Log&#x27;) # set window display behavior self.customWidget.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint) # set window icon (using a built-in icon) name = &quot;SP_MessageBoxCritical&quot; style = self.customWidget.style() icon = style.standardIcon(getattr(QtWidgets.QStyle, name)) self.customWidget.setWindowIcon(icon) # add custom elements here message = &quot;happy new year&quot; errorLabel = QtWidgets.QLabel(messages) scrollArea = QtWidgets.QScrollArea() scrollArea.setWidgetResizable(True) scrollArea.setWidget(errorLabel) # finalize layout.addWidget(scrollArea) self.customWidget.show()def showWindow(): win = MainWidget() try: win.close() except: pass win.setAttribute(QtCore.Qt.WA_DeleteOnClose) win.show() Couple of things worth noting: correctly initialize the widget self.customWidget = QtWidgets.QWidget() will allow widget be child of the main window, thus allow widget to close when main window is closed so not customWidget = QtWidgets.QWidget() or self.customWidget = QtWidgets.QWidget(self) use getattr in combination with QStyle and name of the built-in icon use win.setAttribute(QtCore.Qt.WA_DeleteOnClose) to make sure the child widget is killed after main window is closed, because default close only hides window objects self.customWidget.show() is the core command to call it to display Reference https://www.programiz.com/python-programming/methods/built-in/getattr https://forum.learnpyqt.com/t/are-there-any-built-in-qicons/185/2","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"},{"name":"Template","slug":"Template","permalink":"http://xingyulei.xyz/tags/Template/"}]},{"title":"QDialog Template (without .ui file)","slug":"qt-dialog-template","date":"2021-02-11T05:00:00.000Z","updated":"2021-09-01T03:41:35.262Z","comments":true,"path":"post/qt-dialog-template/","link":"","permalink":"http://xingyulei.xyz/post/qt-dialog-template/","excerpt":"","text":"Main Window 1234567891011121314151617class AttrConnectWindow(QtWidgets.QMainWindow): def __init__(self, parent=getMainWindow()): super(AttrConnectWindow, self).__init__(parent) list = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;] dialog = NamespaceEditDialog() dialog.setNamespaceCBox(list) # only when self.accept() is returned if dialog.exec_(): print &#x27;accepted&#x27; text = dialog.getText() option = dialog.getCombo() print text, option Dialog 123456789101112131415161718192021222324252627282930class NamespaceEditDialog(QtWidgets.QDialog): def __init__(self, parent=None): super(NamespaceEditDialog, self).__init__(parent) # Create widgets self.namespaceCBox = QtWidgets.QComboBox() self.namespaceEdit = QtWidgets.QLineEdit() self.acceptButton = QtWidgets.QPushButton(&quot;Confirm&quot;) # Create layout and add widgets layout = QtWidgets.QGridLayout() layout.addWidget(self.namespaceCBox, 0, 0) layout.addWidget(self.namespaceEdit, 0, 1) layout.addWidget(self.acceptButton, 1, 1) # Set dialog layout self.setLayout(layout) self.acceptButton.clicked.connect(self.onClickAccept) def onClickAccept(self): self.accept() def getNamespaceEdit(self): return self.namespaceEdit.text() def getNamespaceCBox(self): return self.namespaceCBox.currentText() def setNamespaceCBox(self, items): self.namespaceCBox.addItems(items)","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"},{"name":"Template","slug":"Template","permalink":"http://xingyulei.xyz/tags/Template/"}]},{"title":"Qt Model View List Model","slug":"qt-mv-list","date":"2021-02-07T05:00:00.000Z","updated":"2021-09-01T03:45:29.434Z","comments":true,"path":"post/qt-mv-list/","link":"","permalink":"http://xingyulei.xyz/post/qt-mv-list/","excerpt":"","text":"The following example demonstrates how to create custom list model for displaying list-like data 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from Qt import QtGui, QtCore, QtWidgetsimport sysclass PaletteListModel(QtCore.QAbstractListModel): def __init__(self, colors=[], parent=None): QtCore.QAbstractListModel.__init__(self, parent) self.__colors = colors def headerData(self, section, orientation, role): # orientation: indicates horizontal or vertical header # section: indicates which index on the header if role == QtCore.Qt.DisplayRole: if orientation == QtCore.Qt.Horizontal: return &#x27;Palette&#x27; else: return &#x27;Color &#123;&#125;&#x27;.format(section+1) def rowCount(self, parent): # parent: are for tree view with hierarchical structure return len(self.__colors) def data(self, index, role): # display data for each index, of each data role if role == QtCore.Qt.EditRole: return self.__colors[index.row()].name() if role == QtCore.Qt.ToolTipRole: return &quot;Hex code: &quot;+self.__colors[index.row()].name() if role == QtCore.Qt.DecorationRole: row = index.row() value = self.__colors[row] pixmap = QtGui.QPixmap(26, 26) pixmap.fill(value) icon = QtGui.QIcon(pixmap) return icon if role == QtCore.Qt.DisplayRole: row = index.row() value = self.__colors[row] return value.name() def flags(self, index): return QtCore.Qt.ItemIsEditable | QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable def setData(self, index, value, role=QtCore.Qt.EditRole): # set data for each index of the value, data role is set to edit role default if role == QtCore.Qt.EditRole: row = index.row() color = QtGui.QColor(value) if color.isValid(): self.__colors[row] = color # have to emit and dataChanged signal to sync with display self.dataChanged.emit(index, index) return True return False def insertRows(self, position, rows, parent=QtCore.QModelIndex()): self.beginInsertRows(parent, position, position+rows-1) for i in range(rows): self.__colors.insert(position, QtGui.QColor(&quot;#000000&quot;)) self.endInsertRows() return True def removeRows(self, position, rows, parent=QtCore.QModelIndex()): self.beginRemoveRows(parent, position, position+rows-1) for i in range(rows): value = self.__colors[position] self.__colors.remove(value) self.endRemoveRows() return Trueif __name__ == &#x27;__main__&#x27;: app = QtWidgets.QApplication(sys.argv) red = QtGui.QColor(255, 0, 0) green = QtGui.QColor(0, 255, 0) blue = QtGui.QColor(0, 0, 255) model = PaletteListModel([red, green, blue]) model.insertRows(0, 5) listView = QtWidgets.QListView() listView.show() listView.setModel(model) sys.exit(app.exec_()) Note Since parent is used for hierarchical structure, it is not set or set to null index in this example. index is a QModelIndex instance to locate data in model In setData(), make sure to add self.dataChanged.emit(index, index) for syncing data change For inserting and removing rows always starts with insertRows/removeRows and close with endInsertRows/endRemoveRows so that view and model is in-sync no parent in list view so pass a null index: QModelIndex() essentially, it is modifying the self.__colors which is displayed in data() Source https://www.youtube.com/watch?v=mCHVI8OXDxw&amp;list=PLG4y4w32mF3qmweFe59P_8INlVNOm_IHo https://doc.qt.io/qtforpython-5.12/PySide2/QtCore/QModelIndex.html#PySide2.QtCore.QModelIndex","categories":[{"name":"Qt Model View Programming","slug":"Qt-Model-View-Programming","permalink":"http://xingyulei.xyz/categories/Qt-Model-View-Programming/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"}]},{"title":"Qt Model View Intro","slug":"qt-mv-intro","date":"2021-02-06T05:00:00.000Z","updated":"2021-09-01T03:45:24.377Z","comments":true,"path":"post/qt-mv-intro/","link":"","permalink":"http://xingyulei.xyz/post/qt-mv-intro/","excerpt":"","text":"The following example demonstrated how same data is accessed through a Model and shared across Views 1234567891011121314151617181920from Qt import QtGui, QtCore, QtWidgetsimport sysif __name__ == &#x27;__main__&#x27;: app = QtWidgets.QApplication(sys.argv) # no QString needed in Qt5, use python string instead data = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;] listView = QtWidgets.QListView() listView.show() model = QtCore.QStringListModel(data) listView.setModel(model) combobox = QtWidgets.QComboBox() combobox.setModel(model) combobox.show() sys.exit(app.exec_()) In Qt 5, the QtCore.QStringList() is replaced by python’s built-in string type 123456# qt 4data = QtCore.QStringList()data &lt;&lt; &quot;one&quot; &lt;&lt; &quot;two&quot; &lt;&lt; &quot;three&quot; &lt;&lt; &quot;four&quot; &lt;&lt; &quot;five&quot;# qt 5data = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;] Source https://www.youtube.com/watch?v=mCHVI8OXDxw&amp;list=PLG4y4w32mF3qmweFe59P_8INlVNOm_IHo https://stackoverflow.com/questions/27757678/importerror-cannot-import-name-qstringlist-in-pyqt5","categories":[{"name":"Qt Model View Programming","slug":"Qt-Model-View-Programming","permalink":"http://xingyulei.xyz/categories/Qt-Model-View-Programming/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"}]},{"title":"Qt Custom Context Menu Template (Menu, Submenu and Action)","slug":"qt-context-menu","date":"2021-02-05T05:00:00.000Z","updated":"2021-09-01T03:43:27.390Z","comments":true,"path":"post/qt-context-menu/","link":"","permalink":"http://xingyulei.xyz/post/qt-context-menu/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243class MainWindow(): def __init__(self): pass def setup(self): self.widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu) def connectionSignal(self): self.widget.customContextMenuRequested.connect(self.openContextMenu) def openContextMenu(self): contextMenu = QtWidgets.QMenu() # Enable options when only certain number of row is selected (typically one) selectedIndexes = list(set([item.row() for item in self.widget.selectedIndexes()])) if len(selectedIndexes) == 1: item = self.widget.currentItem() # menu option functionAction = contextMenu.addAction(&#x27;Menu Text go here&#x27;) functionAction.triggered.connect(lambda: self.execFunctionWithArgs(item)) # menu option with sub-menu functionMenu = contextMenu.addMenu(&#x27;More options here!&#x27;) submenu = functionMenu.addAction(&#x27;Sub Menu here&#x27;) submenu.triggered.connect(lambda: self.execFunctionWithArgs(item)) else: items = self.widget.selectedItems() # Enable options for other senarios anotherAction = contextMenu.addAction(&#x27;Menu Text go here&#x27;) anotherAction.triggered.connect(self.execFunction) cursor = QtGui.QCursor() contextMenu.exec_(cursor.pos()) def execFunctionWithArgs(self, argument): pass def execFunction(self): pass Reference https://stackoverflow.com/questions/13799033/how-to-add-submenu-in-qt","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"},{"name":"Template","slug":"Template","permalink":"http://xingyulei.xyz/tags/Template/"}]},{"title":"Qt QMessageBox Template","slug":"qt-messagebox","date":"2021-01-28T05:00:00.000Z","updated":"2021-09-01T03:41:35.231Z","comments":true,"path":"post/qt-messagebox/","link":"","permalink":"http://xingyulei.xyz/post/qt-messagebox/","excerpt":"","text":"Templates You could use the following as class method, static method or a function 1234567def messageBoxCritical(message, title=&#x27;Error&#x27;): msgBox = QtWidgets.QMessageBox() msgBox.setIcon(QtWidgets.QMessageBox.Critical) msgBox.setWindowTitle(title) msgBox.setText(message) msgBox.setStandardButtons(QtWidgets.QMessageBox.Ok) return msgBox.exec_() 12345678def messageBoxYesNo(message, title=&#x27;&#x27;): msgBox = QtWidgets.QMessageBox() msgBox.setIcon(QtWidgets.QMessageBox.Question) msgBox.setWindowTitle(title) msgBox.setText(message) msgBox.setStandardButtons(QtWidgets.QMessageBox.Yes|QtWidgets.QMessageBox.No) userChoice = msgBox.exec_() return userChoice 1234567def messageBoxOk(message, title=&#x27;&#x27;): msgBox = QtWidgets.QMessageBox() msgBox.setIcon(QtWidgets.QMessageBox.Information) msgBox.setWindowTitle(title) msgBox.setText(message) msgBox.setStandardButtons(QtWidgets.QMessageBox.Ok) return msgBox.exec_() Example 12345678910111213msg = &quot;Did you recieve this message?&quot;# within classuserChoice = self._messageBoxYesNo(msg, title=&#x27;Test Title&#x27;)# static methoduserChoice = MainWindow._messageBoxYesNo(msg, title=&#x27;Test Title&#x27;)# call outside classuserChoice = messageBoxYesNo(msg, title=&#x27;Test Title&#x27;)if userChoice == QtWidgets.QMessageBox.Yes: function() Reference “Self” as parameter in PyQt5 PyQt5 self reference","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"},{"name":"Template","slug":"Template","permalink":"http://xingyulei.xyz/tags/Template/"}]},{"title":"Error Handling in Python","slug":"py-error-handle","date":"2021-01-24T05:00:00.000Z","updated":"2021-09-01T03:41:35.199Z","comments":true,"path":"post/py-error-handle/","link":"","permalink":"http://xingyulei.xyz/post/py-error-handle/","excerpt":"","text":"Error Handling finally will guarantee execution in try-exception-finally block even after return raise Raise error back to parent function 12345678910111213141516171819202122232425262728# eg. this line will give an ZeroDivision Error10 / 0# what if this belongs to a function and we want to raise the# error code to let whatever calls it to handle instead of itself# so instead ofdef occur_error(): try: output = 10 / 0 except ZeroDivisionError: # error handling pass# we do thisdef handle_error(): try: occur_error() except ZeroDivisionError: # error handling passdef occur_error(): try: output = 10 / 0 except ZeroDivisionError: raise ZeroDivisionError Reference https://stackoverflow.com/questions/49262379/does-finally-always-execute-in-python","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"}]},{"title":"How to Underscore in Python","slug":"py-dunder","date":"2021-01-23T05:00:00.000Z","updated":"2021-09-01T03:41:35.274Z","comments":true,"path":"post/py-dunder/","link":"","permalink":"http://xingyulei.xyz/post/py-dunder/","excerpt":"","text":"Underscore Naming Single Leading Underscore: _var Indicating a name is protected, for internal use. Not enforced by python interpreter Double Leading Underscore: __var Indicating a name is private. Enforced by interpreter, attempt to call it will trigger AttributeError Double Leading Trailing Underscore: __var__ Special methods (magic methods) defined by python language, avoid naming your own attribute Single Trailing Underscore: var_ Avoid naming conflict with python keywords Single Underscore: _ Temporary variable name, variables that are never used Example: 1234a, b, c, d = ([] for _ in range(4))for _ in random_list: some_operation() Reference https://dbader.org/blog/meaning-of-underscores-in-python# https://www.tutorialsteacher.com/python/public-private-protected-modifiers","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"}]},{"title":"Qt Custom Sorting","slug":"qt-sorting","date":"2021-01-23T05:00:00.000Z","updated":"2021-09-01T03:41:35.289Z","comments":true,"path":"post/qt-sorting/","link":"","permalink":"http://xingyulei.xyz/post/qt-sorting/","excerpt":"","text":"Sorting Overview Sorting happens a lot in qt viewports like list, table and tree. Using convenience class such as item-based widget provides limited sorting options. One common thing may occur when you are sorting items is the widget treats their value as string instead of int, which will result incorrect ordering 12345678910111213141516list = [&quot;3&quot;, &quot;1&quot;, &quot;2&quot;, &quot;20&quot;, &quot;92&quot;, &quot;89&quot;, &quot;40&quot;, &quot;10&quot;, &quot;11&quot;]if __name__ == &#x27;__main__&#x27;: app = QtWidgets.QApplication(sys.argv) mywidget = QtWidgets.QTableWidget() mywidget.insertColumn(0) for index in range(len(list)): mywidget.insertRow(index) value = list[index] item = QtWidgets.QTableWidgetItem(value) mywidget.setItem(index, 0, item) mywidget.sortItems(0, QtCore.Qt.AscendingOrder) mywidget.show() sys.exit(app.exec_()) This will sort the list of items based on their string, so the order will be: 1234- 1- 10- 11- 2 instead of 123- 1- 2- ... So naturally, you would need to specify the item value as integer type, but you cannot instantiate item with integer, but setData() will work 1234# intead of item = QtWidgets.QTableWidgetItem(int(value))# do thisitem.setData(QtCore.Qt.ItemDataRole, int(value)) Now everything will sort by numeric order Custom Sorting (Operator override) What if you need more than numeric value for your data, for example, when displaying frame number, you would like to include frame range too. Like frame 1, frame 2, frame 3-7, frame 8, frame 9-14. It looks like using string is the only option. This time you need to override value compare operator for these value, that is making your own item class like the following example 123456789class MyTableWidgetItem(QtWidgets.QTableWidgetItem): def __init__(self, parent=None): QtWidgets.QTableWidgetItem.__init__(self, parent) def __lt__(self, otherItem): try: return int(self.text().split(&#x27;-&#x27;)[0]) &lt; int(otherItem.text().split(&#x27;-&#x27;)[0]) except ValueError: return self.text() &lt; otherItem.text() the __lt__ is the less than operator&lt; 12345678910111213141516list = [&quot;1&quot;, &quot;2&quot;, &quot;10&quot;, &quot;11&quot;, &quot;14-15&quot;, &quot;120&quot;, &quot;100-115&quot;, &quot;59-62&quot;]if __name__ == &#x27;__main__&#x27;: app = QtWidgets.QApplication(sys.argv) mywidget = QtWidgets.QTableWidget() mywidget.insertColumn(0) for index in range(len(list)): mywidget.insertRow(index) value = list[index] item = MyTableWidgetItem(value) mywidget.setItem(index, 0, item) mywidget.sortItems(0, QtCore.Qt.AscendingOrder) mywidget.show() sys.exit(app.exec_()) Everything should behave correctly Custom Sorting (QSortFilterProxyModel Class) To be continued Reference https://stackoverflow.com/questions/363200/is-it-possible-to-sort-numbers-in-a-qtreewidget-column","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"}]},{"title":"Override and Overload","slug":"override-overload","date":"2021-01-17T05:00:00.000Z","updated":"2021-09-01T03:41:35.212Z","comments":true,"path":"post/override-overload/","link":"","permalink":"http://xingyulei.xyz/post/override-overload/","excerpt":"","text":"Overload Overload sounds like a hearthstone term to me, I should really stop playing it. Overloading occurs when two or more methods in one class have the same method name but different parameters. Python supports the following: Built-in function overloading User defined function overloading Operator overloading Override Overriding means having two methods with the same method name and parameters (i.e., method signature). One of the methods is in the parent class and the other is in the child class. Overriding allows a child class to provide a specific implementation of a method that is already provided its parent class. Overwrite Overwrite can be confusing, but it means destroying (replacing) the thing it is overwriting. Reference https://www.programcreek.com/2009/02/overriding-and-overloading-in-java-with-examples/ https://stackabuse.com/overloading-functions-and-operators-in-python/","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"}]},{"title":"Understand Python Imports","slug":"py-import","date":"2021-01-16T05:00:00.000Z","updated":"2021-09-01T03:41:35.203Z","comments":true,"path":"post/py-import/","link":"","permalink":"http://xingyulei.xyz/post/py-import/","excerpt":"","text":"from ... import vs. import Always avoid wildcard imports like such: 1from my_module import * # don&#x27;t use this Instead, use regular import like: 1import my_module # use this Why? using wildcard import will pollute namespaces Using wildcard import will not import names with a leading underscore (unless the module defines an __all__ list) PEP8 recommend using regular import What does __init__.py do? __init__.py is used to specify a package, when import is trying to find the modules, But it is not required: meaning a package without __init__.py, The system can still find the modules after configuring appropriate PYTHONPATH using sys.path.append. __init__.py is executed after importing the package, I’ve seen sub-directory being imported by appending as environment variable within __init__.py Example: so instead of using import project.foo.bar for the following structure: 123456project&#x2F; __init__.py foo&#x2F; __init__.py bar&#x2F; b.py inside the __init__.py, we could do a sys.path.append(PATH_TO_BAR) so with this file structure, you can just do import project they could even add the import statement for you in the __init__.py, although it is not transparent. 12345project&#x2F; __init__.py foo&#x2F; bar&#x2F; b.py Note: Whatever gets appended last overrides the previous env variable, so import to the same name module will find the latest append Dot notation (.) in Import 12345678910parent&#x2F; __init__.py file.py one&#x2F; __init__.py anotherfile.py two&#x2F; __init__.py three&#x2F; __init__.py Each dot in your import will refer to something inside the package, could be another package or a module. But it can’t be a class. Import python modules could look like: import parent.file or import parent.one.anotherfile From … import classes or functions look like this: from parent.file import class which gives you direct access to the class namespace, but not the example above. Import Order Based on PEP8, imports should be grouped by the following order: Standard library import Related third-party import Local application/library specific import What is Standard Library Imports? Standard library are installed automatically by Python installer, full documentation link is here: https://docs.python.org/3/library/ What is the order after grouping? There is no specific rules, but based on common preferences, use alphabetical order, with import first and from … import after 12345import abcimport defimport xfrom g import ggfrom x import xx Intra-Package In a structure like this, how would you do import from another directory? say from module-x.py import module-a 12345678910top-package&#x2F; __init__.py sub-package-a&#x2F; __init__.py module-x.py module-y.py sub-package-b&#x2F; __init__.py module-a.py module-b.py Here’s some examples doing relative imports in module-x 1234567891011import module-yfrom . import module-yfrom .module-y import classAfrom .. import sub-package-bfrom ..subpackage-b import module-afrom ..subpackage-b.module-a import classB ##Reference https://docs.python.org/3/tutorial/modules.html https://stackoverflow.com/questions/37974843/why-can-i-import-successfully-without-init-py https://stackoverflow.com/questions/9427037/relative-path-not-working-even-with-init-py","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"Style","slug":"Style","permalink":"http://xingyulei.xyz/tags/Style/"}]},{"title":"List Comprehension and Conditional Expression in Python","slug":"conditional-expression","date":"2021-01-06T05:00:00.000Z","updated":"2021-09-01T03:41:48.139Z","comments":true,"path":"post/conditional-expression/","link":"","permalink":"http://xingyulei.xyz/post/conditional-expression/","excerpt":"","text":"List Comprehension Example 123list = []for item in items: list.append(item) this can be re-written as: 1list = [item for item in items] it can also be combined with statements and operations 1list = [operate_func(item) for item in items if condition] However, list comprehension is meant for creating list, not executing multiple operations 1234[operation() for _ in steps] # Wrongfor _ in steps: # Do this instead operation() Conditional Expression Conditional Expression (also known as Ternary Operators) Example: 1234if condition: value = value_if_trueelse: value = value_if_false this can be re-written as: 1value = value_if_true if condition else value_if_false","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"Style","slug":"Style","permalink":"http://xingyulei.xyz/tags/Style/"}]},{"title":"Learning Git","slug":"git-learning","date":"2020-12-22T05:00:00.000Z","updated":"2021-09-01T03:41:35.278Z","comments":true,"path":"post/git-learning/","link":"","permalink":"http://xingyulei.xyz/post/git-learning/","excerpt":"","text":"DVCS vs. CVCS DVCS (distributed version control system), for example: Git. Each developer are getting a complete copy of the entire history of that project. This allows developer works offline without connecting to the master repo. Git has an additional staging phase which allows you to break down changes into seperate commits with its own comments. CVCS (centralized version control system), for example: SVN. One central repository, gives manager more top down approach to control, security permission. No staging phase means one less step. Note: today, more teams are using a Centralized Git Model, where changes intended to be a part of a project are submitted as pull or merge request to the master branch. GitHub vs. GitLab They are completely different web-based Git repositories. On the surface, it looks like GitHub is really community friendly, hosting the largest version control platform, while GitLab offers great deal for enterprise professional use (equally, or better features like tracking, project import, with cheaper prices) Git SSH protocol Git Key Commands git init vs. git clone git init is a setup process where you initialize a bare local repo git clone obtain a local development clone repo from an already setup central repository, which can be treated as combining git init and git remote add git pull (or git push) vs. pull request (or push request) git pull pull the changes from the remote repo to your local repo, which is effectively a git fetch followed by a git merge pull request is you requesting another repo to pull your change (more or less asking them to git pull from your repo). A push request is the other way around, where the target repo ask you to git push your changes git config this command allows you to configure your Git configuration on a global or local project level, some common usage includes setting up name and email, configure text color or editor choice. There are three configuration level: --local, --global, --system 123# examplegit --global user.name &quot;John Doh&quot;git --system core.editor vim Note: most config only need to be set once, email is an exception where you will want to use personal email for personal project and professional email for work-related project Reference https://blog.hackbrightacademy.com/blog/svn-vs-git/#:~:text=The%20difference%20between%20Git%20and%20SVN%20version%20control%20systems%20is,well%20as%20some%20local%20repositories. https://www.atlassian.com/git/tutorials/what-is-git https://www.perforce.com/blog/vcs/git-vs-perforce-how-choose-and-when-use-both https://usersnap.com/blog/gitlab-github/ https://stackoverflow.com/questions/22585407/git-pull-vs-pull-request","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://xingyulei.xyz/tags/Git/"},{"name":"Version control","slug":"Version-control","permalink":"http://xingyulei.xyz/tags/Version-control/"}]},{"title":"Difference between Field and Property","slug":"field-property","date":"2020-12-20T05:00:00.000Z","updated":"2021-09-01T03:41:35.207Z","comments":true,"path":"post/field-property/","link":"","permalink":"http://xingyulei.xyz/post/field-property/","excerpt":"","text":"Example In C#: 1234567891011121314public class Person&#123; private string _name; // this is a field public string Name // this is a property &#123; get&#123; return _name; &#125; set&#123; _name = value; &#125; &#125; public int Age&#123; get;set; &#125; // AutoProperty generates private field for us&#125; In Python: 12345678910111213141516171819202122class Celsius(object): def __init__(self, temperature=0): self._temperature = temperature # this is a protected field @property def temperature(self): print(&quot;Getting value...&quot;) return self._temperature @temperature.setter def temperature(self, value): print(&quot;Setting value...&quot;) if value &lt; -273.15: raise ValueError(&quot;Temperature below -273 is not possible&quot;) self._temperature = value# in this case, access the protected temperature valuehuman = Celsius(37)# gettemperature = human.temperature # note that this is not calling a method# set/modifyhuman.temperature = 36.5 Summary Field which stores the internal data should almost always be private. Property gives access to field (or exposed field). Above provides an example of field and property as well as a short-hand for get &amp; set, and AutoProperty in C#. The python example, use the decorator @property for getting value, use @name.setter: name is the property name. In this case: @temperature.setter. There is also a deleter. Reference https://www.w3schools.com/cs/cs_properties.asp https://medium.com/omarelgabrys-blog/properties-vs-fields-in-c-6cec86c59dc9 https://www.freecodecamp.org/news/python-property-decorator/","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"C#","slug":"C","permalink":"http://xingyulei.xyz/tags/C/"}]},{"title":"Structure and Class in Unity","slug":"structure-class","date":"2020-12-20T05:00:00.000Z","updated":"2021-09-01T03:41:35.308Z","comments":true,"path":"post/structure-class/","link":"","permalink":"http://xingyulei.xyz/post/structure-class/","excerpt":"","text":"Struct 12345678public struct Coord&#123; public Coord(float x, float y)&#123; X = x; Y = y; &#125; public float X &#123; get; &#125; public float Y &#123; get; &#125;&#125; Class 12345678public class Person&#123; public Person(string name, int age)&#123; Name = name; Age = age; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125;&#125; Structure types have value semantics. That is, a variable of a structure type contains an instance of the type. By default, variable values are copied on assignment, passing an argument to a method, and returning a method result. In the case of a structure-type variable, an instance of the type is copied Because structure type have value semantics, it is recommended using “readonly” to declare structure type as immutable. Class types have reference semantics. That is, a variable of a class type contains a reference to an instance of the type, not the instance itself. Therefore, the following example shows the different use cases. 123456789Person Jack = new Person(&quot;Jack&quot;, 28);Jack.Name = &quot;Jackson&quot;;Console.WriteLine(Jack.Name);Coord origin = new Coord(0, 0);Console.WriteLine(origin.X);origin.X = 5; // error! the return value X is not a variable // it is actrually the copy of the instanceorigin = new Coord(5, 0); // clear! can only set new X this way Reference https://stackoverflow.com/questions/1747654/error-cannot-modify-the-return-value-c-sharp https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct","categories":[{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://xingyulei.xyz/tags/C/"}]},{"title":"Verlet Integration in Unity","slug":"verlet-integration","date":"2020-11-19T05:00:00.000Z","updated":"2021-09-01T03:41:35.304Z","comments":true,"path":"post/verlet-integration/","link":"","permalink":"http://xingyulei.xyz/post/verlet-integration/","excerpt":"","text":"Introduction When simulating a particle movement, I naturally think of Euler integration, where the position of the particle can be expressed as such: (free falling motion) x=0.5∗g∗t2x = 0.5*g*t^2 x=0.5∗g∗t2 This is an extremly easy use case. The position of the particle can be represented using a function of time. But in real life, a particle can be affected by multiple forces (and even unstabled force caused non-constant acceleration) and Euler integration also has inaccurate estimation when time step is very large. In my understanding, the use of Verlet is good for complex particle movement. What it essentially does is relate force with position rather than velocity. The process first calculate the current particle position and the position one step back: velocity=Xcurrent−Xprevious;velocity = Xcurrent-Xprevious; velocity=Xcurrent−Xprevious; Xprevious=Xcurrent;Xcurrent=Xcurrent+velocityXprevious = Xcurrent; Xcurrent = Xcurrent+velocity Xprevious=Xcurrent;Xcurrent=Xcurrent+velocity This works magically, here’s some sample code to help understand it. 1234// without other influence, the following updates the particle positionvelocity = posNow - posOld;posOld = posNow;posNow += velocity; Calculate Force What if we want to add gravity to the particle like the free falling above? Just add the acceleration to the current position, and the change will add-up on the next integration. The following also applies to forces like friction. 1posNow += GRAVITY; // not sure if we should multipy Time.deltatime Constraint Constraint are usually in the form of constraining particles to a specific distance, like spring. When mulitple constraints acts on single particle, one constraint will affect the other. To solve this, loop the constraint multiple time for each time step. 123456789101112131415161718192021222324252627for (int count = 0; count &lt; ITERATION; count++)&#123; Constriants();&#125;// constraint on rope to make fixed distance between segmentsvoid Constriants()&#123; for(int index = 0; index &lt; segment-1; index++) &#123; float distance = (currentSeg.posNow - nextSeg.posNow).magnitude; float error = Mathf.Abs(distance - ropeDist); Vector2 changeDir = Vector2.zero; if (distance &gt; ropeDist) changeDir = (currentSeg.posNow - nextSeg.posNow).normalized; else if (distance &lt; ropeDist) changeDir = (nextSeg.posNow - currentSeg.posNow).normalized; Vector2 changeAmount = changeDir * error; if (index == 0) nextSeg.posNow += changeAmount; else&#123; currentSeg.posNow -= changeAmount * 0.5f; nextSeg.posNow += changeAmount * 0.5f; &#125; &#125;&#125; Collision Penalty based system or projection collision reaction 12345678910111213141516171819// example for bounding box collisionVector2 velocity = posNow - posOld;if (posNow.x &gt; screenWidth)&#123; posNow.x = screenWidth; posOld.x = posNow.x + velocity.x;&#125;else if (posNow.x &lt; 0)&#123; posNow.x = 0; posOld.x = posNow.x + velocity.x;&#125;if (posNow.y &gt; screenWidth)&#123; posNow.y = screenWidth; posOld.y = posNow.y + velocity.y;&#125;else if (posNow.y &lt; 0)&#123; posNow.y = 0; posOld.y = posNow.y + velocity.y;&#125; Demo https://leixingyu.itch.io/rope-simulation Resources https://youtu.be/3HjO_RGIjCU https://www.youtube.com/watch?v=FcnvwtyxLds https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://xingyulei.xyz/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"http://xingyulei.xyz/tags/Unity/"}]},{"title":"Maya API (3. Custom Deformer)","slug":"maya-api-deformer","date":"2019-11-11T05:00:00.000Z","updated":"2021-09-01T03:44:25.746Z","comments":true,"path":"post/maya-api-deformer/","link":"","permalink":"http://xingyulei.xyz/post/maya-api-deformer/","excerpt":"","text":"API 1.0 custom deformer Example 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import sysimport mathimport maya.cmds as cmdsimport maya.OpenMaya as omimport maya.OpenMayaMPx as mpxnodeName = &#x27;myFirstDeformer&#x27;nodeID = om.MTypeId(0x55555)class MyDeformer(mpx.MPxDeformerNode): amplitudeAttr = om.MObject() displacementAttr = om.MObject() matrixAttr = om.MObject() def __init__(self): mpx.MPxDeformerNode.__init__(self) def deform(self, dataBlock, geomIterator, localToWorldMatrix, geomIndex): # step 1: access built-in attribute value using attribute name and attribute handle envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope envelopeHandle = dataBlock.inputValue(envelopeAttr) envelopeValue = envelopeHandle.asFloat() # step 1.5: access custom attribute value amplitudeHandle = dataBlock.inputValue(MyDeformer.amplitudeAttr) amplitudeValue = amplitudeHandle.asFloat() displacementHandle = dataBlock.inputValue(MyDeformer.displacementAttr) displacementValue = displacementHandle.asFloat() # step 1.55: access custom attribute value connected to an accessory node matrixHandle = dataBlock.inputValue(MyDeformer.matrixAttr) matrixValue = matrixHandle.asMatrix() transMatrix = om.MTransformationMatrix(matrixValue) # matrix type translateValue = transMatrix.getTranslation(om.MSpace.kObject) # vector type # step 2: access input mesh inputMesh = self.getDeformerInputGeom(dataBlock, geomIndex) # step 2.5: access mesh normals meshFn = om.MFnMesh(inputMesh) normalVectorArray = om.MFloatVectorArray() # create float vector array to store normal vector meshFn.getVertexNormals(False, normalVectorArray, om.MSpace.kObject) # (average normal or not?, the array to store, normal space) # step 3: iterate the mesh vertices and deform it newVertexPosArray = om.MPointArray() # to store new vertices position while not geomIterator.isDone(): vertexPos = geomIterator.position() vertexIndex = geomIterator.index() normalVector = om.MVector(normalVectorArray[vertexIndex]) # get weight from weightPainting and multiply it to the deform, this is done inside # built-in function weightValue(dataBlock, geomIndex, vertexIndex) weight = self.weightValue(dataBlock, geomIndex, vertexIndex) vertexPos.x = vertexPos.x + math.sin(vertexIndex + displacementValue + translateValue[0]) * normalVector.x * amplitudeValue * envelopeValue * weight vertexPos.y = vertexPos.y + math.sin(vertexIndex + displacementValue + translateValue[0]) * normalVector.y * amplitudeValue * envelopeValue * weight vertexPos.z = vertexPos.z + math.sin(vertexIndex + displacementValue + translateValue[0]) * normalVector.z * amplitudeValue * envelopeValue * weight newVertexPosArray.append(vertexPos) geomIterator.next() geomIterator.setAllPositions(newVertexPosArray) # override built-in function that allows to create accessory node along with deformer def accessoryNodeSetup(self, dagModifier): # step1: create the accessory node using the supplied dagModifier locator = dagModifier.createNode(&#x27;locator&#x27;) # step2: access accessory node&#x27;s attribute(can&#x27;t use mplug type, has to be mobject type) # access dependency node function set dependNodeFn = om.MFnDependencyNode(locator) matrixPlug = dependNodeFn.findPlug(&#x27;worldMatrix&#x27;) # this returns mplug type attribute, we need mobject type attribute matrixAttr = matrixPlug.attribute() # step3: connect mobject type(required) together # param: accessory node(mobject), accessory attr(mobject), deformer node(mobject: using self.thisMObject()), deformer attr(mobject) mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.matrixAttr) &#x27;&#x27;&#x27;now the accessory node&#x27;s worldMatrix is driving to the in-matrix of the deformer node&#x27;&#x27;&#x27; return mConnectStatus def accessoryAttribute(self): # returns the deformer node attribute connected return MyDeformer.matrixAttr def getDeformerInputGeom(self, dataBlock, geomIndex): inputAttr = mpx.cvar.MPxGeometryFilter_input inputHandle = dataBlock.outputArrayValue(inputAttr) # use outputArray instead of inputArray to avoid re-computation inputHandle.jumpToElement(geomIndex) inputElementHandle = inputHandle.outputValue() inputGeomAttr = mpx.cvar.MPxGeometryFilter_inputGeom inputGeomHandle = inputElementHandle.child(inputGeomAttr) # this is different from how we usually get handler inputGeomMesh = inputGeomHandle.asMesh() return inputGeomMeshdef nodeCreator(): # return pointer to instance of our deformer node class return mpx.asMPxPtr(MyDeformer())def nodeInitializer(): # step1: define attribute function set (numericAttr &amp; matrixAttr) numericAttrFn = om.MFnNumericAttribute() matrixAttrFn = om.MFnMatrixAttribute() # step2: create custom attribute and set its property MyDeformer.amplitudeAttr = numericAttrFn.create(&#x27;ampplitude&#x27;, &#x27;amp&#x27;, om.MFnNumericData.kFloat, 0.0) numericAttrFn.setMin(-1.0) numericAttrFn.setMax(1.0) numericAttrFn.setReadable(False) MyDeformer.displacementAttr = numericAttrFn.create(&#x27;displacement&#x27;, &#x27;dis&#x27;, om.MFnNumericData.kFloat, 0.0) numericAttrFn.setMin(-5.0) numericAttrFn.setMax(5.0) numericAttrFn.setReadable(False) MyDeformer.matrixAttr = matrixAttrFn.create(&#x27;matrix&#x27;, &#x27;m&#x27;) matrixAttrFn.setStorable(False) matrixAttrFn.setConnectable(True) # step2.5: access built-in attribute using OpenMayaMpx.cvar.MPxGeometryFilter_outputGeom outputGeom = mpx.cvar.MPxGeometryFilter_outputGeom # step3: attach attribute MyDeformer.addAttribute(MyDeformer.amplitudeAttr) MyDeformer.addAttribute(MyDeformer.displacementAttr) MyDeformer.addAttribute(MyDeformer.matrixAttr) # step4: add circuit (relationship) MyDeformer.attributeAffects(MyDeformer.amplitudeAttr, outputGeom) MyDeformer.attributeAffects(MyDeformer.displacementAttr, outputGeom) MyDeformer.attributeAffects(MyDeformer.matrixAttr, outputGeom) cmds.makePaintable(nodeName, &#x27;weights&#x27;, attrType=&#x27;multiFloat&#x27;, shapeMode=&#x27;deformer&#x27;)def initializePlugin(mobject): mplugin = mpx.MFnPlugin(mobject) try: # Parameter: node_name, node_id, node_creatorFunc, node_initFuc, nodeType(common type include-kDeformerNode, kDependNode) mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, mpx.MPxNode.kDeformerNode) except: sys.stderr(&#x27;fail to register node: &#x27; + nodeName) raisedef uninitializePlugin(mobject): mplugin = mpx.MFnPlugin(mobject) try: mplugin.deregisterNode(nodeID) except: sys.stderr(&#x27;fail to de-register node: &#x27; + nodeName) raise Note: MPxDeformerNode is only available in API 2.0 Custom Attribute vs. Built-in Attribute In the last chapter, we know how to create custom numeric type attribute using MFnNumericAttribute. Sometimes in our node, we want to access existing built-in attribute. We do so by using OpenMayaMPx.cvar.MPxDeformerNode_(attributeName) before Maya 2016, we use OpenMayaMPx.cvar.MPxGeometryFilter_(attributeName) after 2016. Obtain Input Geometry In the sample code, we define our custom function getDeformerInputGeom(self, dataBlock, geomIndex) to obtain the input mesh to the deformer node. We will discuss this later. Accessory Node Accessory node acts like a secondary driver node connected to our deformer so they can influence the deformation. In the sample code, our accessory node is a locator which when we connects its world matrix, it will change our mesh’s deformation when translating. Custom Dependency Node vs. Custom Deformer Node Registration: In our previous chapter, we register our node using registerNode() with node type: omMPx.MPxNode.kDependNode, in deformer node, we use omMPx.MPxNode.kDeformerNode as our node type. Inheritance: We now inherit our class from omMPx.MPxDeformerNode instead of omMPxNode there’s still compute() in MPxDeformerNode class, but we want to write our deformation algorithm in deform(). Accessory Node: accessoryNodeSetup(self, dagModifier) and accessoryAttribute(self) is override to allow us to control accessory node along with our deformer. Procedure Step 1: Declare attributes (Same as last chapter) Step 2: Initialize Node Node Creator 12def nodeCreator(): return mpx.asMPxPtr(MyDeformer()) Only API 1.0 is available. Node Initializer 12345678910111213141516171819202122232425262728def nodeInitializer(): &#x27;&#x27;&#x27;1: create reference to numericAttribute and matrixAttribute function sets&#x27;&#x27;&#x27; numericAttrFn = om.MFnNumericAttribute() matrixAttrFn = om.MFnMatrixAttribute() &#x27;&#x27;&#x27; 2: create attribute using the function set&#x27;&#x27;&#x27; MyDeformer.inNumAttr = numericAttrFn.create(&#x27;num&#x27;, &#x27;n&#x27;, om.MFnNumericData.kFloat, 0.0) numericAttrFn.setMin(-1.0) numericAttrFn.setMax(1.0) numericAttrFn.setReadable(False) MyDeformer.inMatAttr = numericAttrFn.create(&#x27;matrix&#x27;, &#x27;m&#x27;) matrixAttrFn.setStorable(False) matrixAttrFn.setConnectable(True) &#x27;&#x27;&#x27; 2.5: access built-in attribute using OpenMayaMpx.cvar.MPxGeometryFilter_outputGeom&#x27;&#x27;&#x27; outputGeom = mpx.cvar.MPxGeometryFilter_outputGeom &#x27;&#x27;&#x27; 3: attach attribute&#x27;&#x27;&#x27; MyDeformer.addAttribute(MyDeformer.inNumAttr) MyDeformer.addAttribute(MyDeformer.inMatAttr) &#x27;&#x27;&#x27; 4: add circuit (relationship in-&gt;out)&#x27;&#x27;&#x27; MyDeformer.attributeAffects(MyDeformer.inNumAttr, ouputGeom) MyDeformer.attributeAffects(MyDeformer.inMatAttr, ouputGeom) &#x27;&#x27;&#x27; 5: make attribute paintable&#x27;&#x27;&#x27; cmds.makePaintable(nodeName, &#x27;weights&#x27;, attrType=&#x27;multiFloat&#x27;, shapeMode=&#x27;deformer&#x27;) we access the output Geometry attribute so we can later add relationship to it. RegisterNode 1mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDeformNode) De-registerNode 1mplugin.deregisterNode(nodeID) Step 3: Initialize Node （Actual Deform Algorithm） 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyNode(om.MPxDeformNode): inNumAttr = om.MObject() inMatAttr = om.MObject() def __init__(self): om.MPxDeformNode.__init__(self) def deform(self, dataBlock, geomIterator, localToWorldMatrix, geomIndex): # step 1: access built-in attribute value using attribute name and attribute handle envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope envelopeHandle = dataBlock.inputValue(envelopeAttr) envelopeValue = envelopeHandle.asFloat() # step 1.5: access custom attribute value inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr) inNumValue = inNumHandle.asFloat() # step 1.55: access custom translate value connected to an accessory node inMatHandle = dataBlock.inputValue(MyDeformer.inMatAttr) inMatValue = inNumHandle.asMatrix() transMatrix = om.MTransformationMatrix(inMatValue) # matrix type translateValue = transMatrix.getTranslation(om.MSpace.kObject) # vector type # step 2: access input mesh inputMesh = self.getDeformerInputGeom(dataBlock, geomIndex) # step 2.5: access mesh normals meshFn = om.MFnMesh(inputMesh) normalVectorArray = om.MFloatVectorArray() # create float vector array to store normal vector meshFn.getVertexNormals(False, normalVectorArray, om.MSpace.kObject) # (average normal or not?, the array to store, normal space) # step 3: iterate the mesh vertices and deform it newVertexPosArray = om.MPointArray() # to store new vertices position while not geomIterator.isDone(): vertexPos = geomIterator.position() vertexIndex = geomIterator.index() normalVector = om.MVector(normalVectorArray[vertexIndex]) # built-in function weightValue(dataBlock, geomIndex, vertexIndex) weight = self.weightValue(dataBlock, geomIndex, vertexIndex) # vertexPos.x = vertexPos.x + [calculation of normalVector.x and translateValue[0]] * envelopeValue * weight newVertexPosArray.append(vertexPos) geomIterator.next() geomIterator.setAllPositions(newVertexPosArray) To access a value from an attribute, we use handle = dataBlock.input/outputValue(MyNode.attr) if we have a custom attribute inNumAttr: inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr) inNumValue = inNumHandle.asFloat() if we have a built-in attribte envelope: we first get our attribute name envelope envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope envelopeHandle = dataBlock.inputValue(envelopeAttr) envelopeValue = envelopeHandle.asFloat() To get normal for individual vertices on our input mesh, we first need to obtain our input mesh using our own function: getDeformerInputGeom(self, dataBlock, geomIndex). And using mesh function set MeshFn’s getVertexNormals() we store the normal vector in om.MFloatVectorArray() type array. To deform our mesh: we use the geometry iterator to perform iteration on each mesh vertex and re-calculate its position. We combine the use of geoIterator.position() and geomIterator.setPosition(point) or geomIterator.setAllPositions(pointArray). To access weight value on each vertex, we use built-in function weightValue(dataBlock, geomIndex, vertexIndex). In which, geomIndex is provided in deform() and vertexIndex is from geomIterator. Step 3.1: Get in-Mesh 1234567891011def getDeformerInputGeom(self, dataBlock, geomIndex): inputAttr = mpx.cvar.MPxGeometryFilter_input inputHandle = dataBlock.outputArrayValue(inputAttr) # use outputArray instead of inputArray to avoid re-computation inputHandle.jumpToElement(geomIndex) inputElementHandle = inputHandle.outputValue() inputGeomAttr = mpx.cvar.MPxGeometryFilter_inputGeom inputGeomHandle = inputElementHandle.child(inputGeomAttr) # this is different from how we usually get handler inputGeomMesh = inputGeomHandle.asMesh() return inputGeomMesh At this point, I can’t fully interpret the meaning of this segment. Step 4: Accessory Node 1234567891011121314151617181920def accessoryNodeSetup(self, dagModifier): # step1: create the accessory node using the supplied dagModifier locator = dagModifier.createNode(&#x27;locator&#x27;) # step2: access accessory node&#x27;s attribute(can&#x27;t use mplug type, has to be mobject type) # access dependency node function set dependNodeFn = om.MFnDependencyNode(locator) matrixPlug = dependNodeFn.findPlug(&#x27;worldMatrix&#x27;) # this returns mplug type attribute, we need mobject type attribute matrixAttr = matrixPlug.attribute() # step3: connect mobject type(required) together # param: accessory node(mobject), accessory attr(mobject), deformer node(mobject: using self.thisMObject()), deformer attr(mobject) mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr) &#x27;&#x27;&#x27;now the accessory node&#x27;s worldMatrix is driving to the custom in-matrix of the deformer node&#x27;&#x27;&#x27; return mConnectStatusdef accessoryAttribute(self): # returns the deformer node attribute connected return MyDeformer.inMatAttr The dagModifer is supplied in the accessory node. We use dagModifier’s connect function to connect the accessory node’s attribute to our deformer node’s attribute. In this case, we have accessory’s attribute: worldMatrix (a built-in attribute obtained from MFnDependencyNode.findPlug()) and our custom defined MyDeformer.inMatAttr. One thing to note is that, the .connect() only takes MObject which we cannot supply MPlug type object matrixPlug = ...findPlug('attributeName'), we perform an additional step matrixAttr = matrixPlug.attribute() to get the MObject type attribute. Now we supply .connect() with parameters: an accessory node (MObject type), accessory node’s attribute (MObject type), deformer node (MObject type) and deformer node’s attribute (MObject type) as follows: mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr)","categories":[{"name":"Maya API Series","slug":"Maya-API-Series","permalink":"http://xingyulei.xyz/categories/Maya-API-Series/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"Maya","slug":"Maya","permalink":"http://xingyulei.xyz/tags/Maya/"}]},{"title":"Maya API (2. Custom Node)","slug":"maya-api-node","date":"2019-11-10T05:00:00.000Z","updated":"2021-09-01T03:44:15.331Z","comments":true,"path":"post/maya-api-node/","link":"","permalink":"http://xingyulei.xyz/post/maya-api-node/","excerpt":"","text":"API 2.0 custom node example 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import maya.api.OpenMaya as omimport sysdef maya_useNewAPI(): passnodeName = &#x27;myFirstNode&#x27;nodeID = om.MTypeId(0x55555)nodeClassify = &#x27;utility/general&#x27;class MyNode(om.MPxNode): inRadiusAttr = om.MObject() inTranslateAttr = om.MObject() outRotateAttr = om.MObject() def __init__(self): om.MPxNode.__init__(self) # plug is MPlug type object, dataBlock is MDataBlock type object, refers to the entire datablock of the node def compute(self, plug, dataBlock): if plug == MyNode.outRotateAttr: # step one: get datablock handle (inputValue returns MDataHandle type object) inRadiusHandle = dataBlock.inputValue(MyNode.inRadiusAttr) inTranslateHandle = dataBlock.inputValue(MyNode.inTranslateAttr) outRotateHandle = dataBlock.outputValue(MyNode.outRotateAttr) # step two: extract input value from the handle inRadius = inRadiusHandle.asFloat() inTranslate = inTranslateHandle.asFloat() # step three: create logic and set output value outRotate = inTranslate/(6.18*inRadius) * -360 outRotateHandle.setFloat(outRotate) # step four: mark output plug as clean outRotateHandle.setClean() # unknown plug, unknown error else: return om.kUnknownParameterdef nodeCreator(): return MyNode()def nodeInitializer(): defaultRadius = 2.0 defaultTranslate = 0.0 # step one: create reference to attribute function set such as numericAttribute numericAttrFn = om.MFnNumericAttribute() # step two: create attribute using the function set MyNode.inRadiusAttr = numericAttrFn.create(&#x27;radius&#x27;, &#x27;r&#x27;, om.MFnNumericData.kFloat, defaultRadius) numericAttrFn.readable = True # API1.0: numericAttrFn.setReadable(True) numericAttrFn.writable = True numericAttrFn.storable = True numericAttrFn.hidden = False numericAttrFn.keyable = True MyNode.inTranslateAttr = numericAttrFn.create(&#x27;translate&#x27;, &#x27;t&#x27;, om.MFnNumericData.kFloat, defaultTranslate) numericAttrFn.readable = True numericAttrFn.writable = True numericAttrFn.storable = True numericAttrFn.hidden = False numericAttrFn.keyable = True MyNode.outRotateAttr = numericAttrFn.create(&#x27;rotation&#x27;, &#x27;rot&#x27;, om.MFnNumericData.kFloat) numericAttrFn.readable = True numericAttrFn.writable = False numericAttrFn.storable = False numericAttrFn.hidden = False # step three: attach attribute MyNode.addAttribute(MyNode.inRadiusAttr) MyNode.addAttribute(MyNode.inTranslateAttr) MyNode.addAttribute(MyNode.outRotateAttr) # step four: add circuit (relationship in-&gt;out) MyNode.attributeAffects(MyNode.inRadiusAttr, MyNode.outRotateAttr) MyNode.attributeAffects(MyNode.inTranslateAttr, MyNode.outRotateAttr)def initializePlugin(mobject): mplugin = om.MFnPlugin(mobject) try: mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDependNode, nodeClassify) except: sys.stderr.write(&#x27;fail to register node: &#x27; + nodeName) raisedef uninitializePlugin(mobject): mplugin = om.MFnPlugin(mobject) try: mplugin.deregisterNode(nodeID) except: sys.stderr.write(&#x27;fail to de-register node: &#x27; + nodeName) raise Data block (MDataBlock) Data block refers the entire container of a node. This container stores all the values for each attribute of the node. The datablock of this node is provided in the compute() function. Plug (MPlug) Plug is the outer plug of the node which provides the connections to other node’s plug. The MPlug usually connects the plug from another node and the value of a certain attribute of this node. The plug is also provided in the compute() function Data handle (MDataHandle) Data handle usually stores an attribute’s value. We can set a value to an attribute using MDataHandle.setType(value), and get an attribute’s value using **value = MDataHandle.asType()**. Procedure Step 1: Declare attributes (MObject) in the class 123456789class MyNode(om.MPxNode): inAttr = om.MObject() outAttr = om.MObject() def __init__(self): om.MPxNode.__init__(self) def compute(self, plug, dataBlock): pass inAttr refers to the input attribute that we are creating, outAttr refers to the output attribute that we are creating. Both are declared as MObject() type. We will later access them using MyNode.inAttr and MyNode.outAttr. Step 2: Initialize Node Node Creator 12def nodeCreator(): return MyNode() Node Creator in API 2.0 directly returns an instance to the class, API 1.0 uses a pointer like in command plugin. Node Initializer 123456789101112131415161718def nodeInitializer(): &#x27;&#x27;&#x27;1: create reference to attribute function set such as numericAttribute&#x27;&#x27;&#x27; numericAttrFn = om.MFnNumericAttribute() &#x27;&#x27;&#x27; 2: create attribute using the function set&#x27;&#x27;&#x27; MyNode.inAttr = numericAttrFn.create(&#x27;in&#x27;, &#x27;i&#x27;, om.MFnNumericData.kFloat, 1.0) numericAttrFn.readable = True numericAttrFn.writable = True MyNode.outAttr = numericAttrFn.create(&#x27;out&#x27;, &#x27;o&#x27;, om.MFnNumericData.kFloat) numericAttrFn.readable = True numericAttrFn.writable = False &#x27;&#x27;&#x27; 3: attach attribute&#x27;&#x27;&#x27; MyNode.addAttribute(MyNode.inAttr) MyNode.addAttribute(MyNode.outAttr) &#x27;&#x27;&#x27; 4: add circuit (relationship in-&gt;out)&#x27;&#x27;&#x27; MyNode.attributeAffects(MyNode.inAttr, MyNode.outAttr) MFnNumericAttribute provides the function sets to create an attribute for numeric type attribute. There’s also MFnMatrixAttribute to create matrix type attribute and so on. Using the function set’s create() function, we add parameters for attribute’s long name, short name, data type, and default value (optional). This returns a MObject type attribute which is attached to the function set. We store it in the attribute declared earlier in the class. Set the attribute’s property using function set, such as readable, writable, hidden, storable, connectable (In API1.0, use like this numericAttrFn.setReadable(True)) Using the MyNode.addAttribute(MyNode.inAttr) to attach an attribute to the node Using the MyNode.attributeAffects(MyNode.inAttr, MyNode.outAttr) to design the affect relationship between attributes, in this case, change of inAttr will affect `outAttr. RegisterNode 1mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDependNode, nodeClassify) Parameters: name of the node, id of the node, node creator function, node initializer function, node type (DependNode or DeformNode…), node classification (utility, shading…) Example: nodeID = om.MTypeId(0x55555) nodeClassify = 'utility/general' De-registerNode 1mplugin.deregisterNode(nodeID) Step 3: Initialize Node 12345678910111213141516171819202122232425class MyNode(om.MPxNode): inAttr = om.MObject() outAttr = om.MObject() def __init__(self): om.MPxNode.__init__(self) def compute(self, plug, dataBlock): if plug == MyNode.outAttr: # 1: get datablock handle (inputValue returns MDataHandle type object) inHandle = dataBlock.inputValue(MyNode.inAttr) outHandle = dataBlock.outputValue(MyNode.outAttr) # 2: extract input value from the handle inValue = inHandle.asFloat() # 3: create logic and set output value outValue = inValue * 2 outHandle.setFloat(outValue) # 4: mark output plug as clean outHandle.setClean() else: return om.kUnknownParameter When MyNode.outAttr is dirty (meaning it needs to recompute), we use if plug == MyNode.outAttr: to identify this certain plug. (this if statement will work, even if plug is MPlug type and MyNode.outAttr is MObject type) We have already identified what input attribute is affecting this plug, in order to retrieve the value of this input, we need to attach a data handle on the data block specifying this certain input attribute we want to retrive. Therefore, we have handle = dataBlock.input/outputValue(MyNode.attr) Next, we use value = handle.asFloat() and handle.setFloat(value) to get and set the value from and to the attribute. (float type as example) Last, we mark the current plug as clean, by setClean() to the outHandle","categories":[{"name":"Maya API Series","slug":"Maya-API-Series","permalink":"http://xingyulei.xyz/categories/Maya-API-Series/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"Maya","slug":"Maya","permalink":"http://xingyulei.xyz/tags/Maya/"}]},{"title":"Maya API (1. Command Plugin with Flags)","slug":"maya-api-command","date":"2019-11-09T05:00:00.000Z","updated":"2021-09-01T03:44:30.526Z","comments":true,"path":"post/maya-api-command/","link":"","permalink":"http://xingyulei.xyz/post/maya-api-command/","excerpt":"","text":"Definition: “Flags” vs “Argument” Take this as an example: cmds.group('circle1', 'sphere1', name='group1') circle1 and sphere1 are arguments name is the flag and group1 is the value Another example: cmds.polyCube(sx=10, axis=[0, 0, 1]) no argument is specified sx is the flag’s short name, subdivisionX is the flag’s long name [0, 0, 1] is axis flag’s value, each individual number is called parameters Procedure Step 1: Declare flag name outside the class 12345firstFlagShortName = &#x27;-f&#x27;firstFlagLongName = &#x27;-first&#x27;secondFlagShortName = &#x27;-s&#x27;secondFlagLongName = &#x27;-second&#x27;# more flags ... Step 2: Add flag and argument in syntax creator outside of class (this syntax creator will be further included in the plugin initialize function) 12345678910111213def syntaxCreator(): &quot;&quot;&quot;create a OpenMaya.MSyntax object to store flags and argument&quot;&quot;&quot; syntax = om.MSyntax() # add flags with short name, long name, and value type syntax.addFlag(firstFlagShortName, firstFlagLongName, om.MSyntax.kDouble) syntax.addFlag(secondFlagShortName, secondFlagLongName, (om.MSyntax.kDouble, om.MSyntax.kDouble, om.MSyntax.kDouble)) # add more flags ... &#x27;&#x27;&#x27;add argument using MSyntax.addArg() function&#x27;&#x27;&#x27; &#x27;&#x27;&#x27;add argument is not discussed, refer to document later&#x27;&#x27;&#x27; return syntax Step 3: Parsing flags, called inside the class’s doIt function 123456789101112 def parseArguments(self, args): &quot;&quot;&quot; instantiate MArgParser ojbect, self.syntax() refers to the syntax created in step 2&quot;&quot;&quot; argData = om.MArgParser(self.syntax(), args)# check if certain flags are set if argData.isFlagSet(firstFlagShortName): firstValue = argData.flagArgumentString(firstFlagShortName, 0) if argData.isFlagSet(secondFlagShortName): secondParam0 = argData.flagArgumentInt(secondFlagShortName, 0) secondParam1 = argData.flagArgumentInt(secondFlagShortName, 1) secondParam2 = argData.flagArgumentInt(secondFlagShortName, 2) # parse more flags ...","categories":[{"name":"Maya API Series","slug":"Maya-API-Series","permalink":"http://xingyulei.xyz/categories/Maya-API-Series/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"Maya","slug":"Maya","permalink":"http://xingyulei.xyz/tags/Maya/"}]},{"title":"Maya API (0. Introduction)","slug":"maya-api-intro","date":"2019-11-08T05:00:00.000Z","updated":"2021-09-01T03:44:20.298Z","comments":true,"path":"post/maya-api-intro/","link":"","permalink":"http://xingyulei.xyz/post/maya-api-intro/","excerpt":"","text":"Overview Different from Maya Command, Maya API offers more low level access to Maya’s feature. You can think of Maya in multiple layers: Bottom Layer: System OS Maya Core: The entire Maya program written in C++ Maya API: Designated API exposed to developers, which can access Maya Core Maya Command: Helper Functions calling multiple Maya API Maya GUI: User graphics interface While Maya Command (MEL/Python) is most commonly used to write scripts, because it has fast prototyping and easy to learn. The downside is that it is often slow and can’t offer low level access to Maya Core. Maya API on the other hand, is complicated, but offers faster speed and most flexibility. It comes with Python and C++. Python API has version 1.0 and 2.0. Difference Between Python API vs C++ API API1.0 vs 2.0 API 1.0 (Before 2012) has acess to more features offered in C++ API 2.0 faster and more pythonic, but some class such as OpenMayaFX, OpenMayaDeformerNode is not supported. General Format API 1.0 Example 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import sysimport maya.OpenMayaMPx as mpximport maya.OpenMaya as ompluginName = &#x27;pyTemplate&#x27;sampleShortFlagName = &#x27;-s&#x27;sampleLongFlagName = &#x27;-sample&#x27;class PyTemplate(mpx.MPxCommand): def __init__(self): mpx.MPxCommand.__init__(self) def doIt(self, args): print &#x27;doIt&#x27; self.parseArgument(args) self.redoIt() def redoIt(self): # this is optional print &#x27;redoIt&#x27; def undoIt(self): # this is also optional print &#x27;undoIt&#x27; def parseArgument(self, args): argData = om.MArgParser(self.syntax(), args) if argData.isFlagSet(sampleShortFlag): self.sample = argData.flagArgumentDouble(sampleShortFlag, 0) print self.sample def isUndoable(self): # this is required when undo and redo is available return Truedef cmdCreator(): return mpx.asMPxPtr(PyParticle())def syntaxCreator(): # use this only when custom argument is defined syntax = om.MSyntax() syntax.addFlag(sampleShortName, sampleLongName, om.MSyntax.kDouble) return syntaxdef initializePlugin(mobject): mplugin = mpx.MFnPlugin(mobject) try: mplugin.registerCommand(pluginName, cmdCreator, syntaxCreator) except: sys.stderr.write(&#x27;fail to register: &#x27; + pluginName) raisedef uninitializePlugin(mobject): mplugin = mpx.MFnPlugin(mobject) try: mplugin.deregisterCommand(pluginName) except: sys.stderr.write(&#x27;fail to de-register: &#x27; + pluginName) raise ###API 2.0 Example 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import sysimport maya.OpenMaya as ompluginName = &#x27;pyTemplate&#x27;sampleShortFlagName = &#x27;-s&#x27;sampleLongFlagName = &#x27;-sample&#x27;def maya_useNewAPI(): passclass PyTemplate(mpx.MPxCommand): def __init__(self): mpx.MPxCommand.__init__(self) def doIt(self, args): print &#x27;doIt&#x27; self.parseArgument(args) def parseArgument(self, args): argData = om.MArgParser(self.syntax(), args) if argData.isFlagSet(sampleShortFlag): self.sample = argData.flagArgumentDouble(sampleShortFlag, 0) print self.sampledef cmdCreator(): return PyTemplate()def syntaxCreator(): syntax = om.MSyntax() syntax.addFlag(sampleShortName, sampleLongName, om.MSyntax.kDouble) return syntaxdef initializePlugin(mobject): mplugin = mpx.MFnPlugin(mobject) try: mplugin.registerCommand(pluginName, cmdCreator, syntaxCreator) except: sys.stderr.write(&#x27;fail to register: &#x27; + pluginName) raisedef uninitializePlugin(mobject): mplugin = mpx.MFnPlugin(mobject) try: mplugin.deregisterCommand(pluginName) except: sys.stderr.write(&#x27;fail to de-register: &#x27; + pluginName) raise Difference import module 1.0 has a seperate maya.OpenMayaMPx along with maya.OpenMaya 2.0 has maya.api.OpenMaya including the original MPx command maya_useNewAPI 2.0 use this function to declare using API 2.0 cmd creator 1.0 uses a MPx pointer object to point to instance of the class 2.0 director returns the instance of the class other syntax difference will be discussed later","categories":[{"name":"Maya API Series","slug":"Maya-API-Series","permalink":"http://xingyulei.xyz/categories/Maya-API-Series/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"Maya","slug":"Maya","permalink":"http://xingyulei.xyz/tags/Maya/"}]},{"title":"Using Qt Template","slug":"qt-template","date":"2019-01-16T05:00:00.000Z","updated":"2021-09-01T03:42:06.691Z","comments":true,"path":"post/qt-template/","link":"","permalink":"http://xingyulei.xyz/post/qt-template/","excerpt":"","text":"Import Qt Module You could be using PyQt/PySide or a custom binding, but the import is similar 12from Qt import QtCore, QtGui, QtWidgetsfrom Qt import _loadUi System App Template 123456789101112# appName.pyclass AppUI(QtWidgets.QDialog): def __init__(self): super(AppUI, self).__init__() _loadUi(UI_PATH, self) if __name__ == &#x27;__main__&#x27;: import sys app = QtWidgets.QApplication(sys.argv) window = AppUI() window.show() sys.exit(app.exec_()) Maya Template 123456789# moduleName.pyclass ModuleUI(QtWidgets.QDialog): def __init__(self): super(ModuleUI, self).__init__() _loadUi(UI_PATH, self)def show(): window = ModuleUI() window.show() Note: this Qt window is not parented to Maya application by default, closing the widget is hiding not destroying the object Parented to Maya main window 12345678910111213# moduleName.pyfrom shiboken2 import wrapInstancedef get_maya_main_window(): import maya.OpenMayaUI main_window_ptr = maya.OpenMayaUI.MQtUtil.mainWindow() return wrapInstance(long(main_window_ptr), QtWidgets.QMainWindow)class ModuleUI(QtWidgets.QDialog): def __init__(self, parent=get_maya_main_window()): super(ModuleUI, self).__init__(parent) _loadUi(UI_PATH, self) self.setWindowFlags(QtCore.Qt.Window) Destroy window instance when closed 12345678def show(): window = ModuleUI() try: window.close() except: pass window.setAttribute(QtCore.Qt.WA_DeleteOnClose) window.show() Maya Script Editor To call the open window function, use script editor 1moduleName.show() When the UI has no parent (Maya main window), it will get instantly destroyed by the garbage collector, unless you keep an instance: 12345678# in the show functiondef show(): window = ModuleUI() window.show() return window# in maya script editorwin = moduleName.show() No .ui file There is a different between inheriting from QWidget class vs QMainWindow Inheriting from QWidget: 12345678910111213141516class InheritQWidget(QtWidgets.QWidget): def __init__(self, parent=None): super(InheritQWidget, self).__init__(parent) # initialization object layout = QtWidgets.QGridLayout() listWidget = QtWidgets.QListWidget() #treeWidget = QtWidgets.QTreeWidget() # set # treeWidget.setParent(listWidget) layout.addWidget(listWidget) self.setLayout(layout) listWidget.addItem(&#x27;item A&#x27;) listWidget.addItem(&#x27;item B&#x27;) Inheriting from QMainWindow 1234567891011121314151617class InheritQMainWindow(QtWidgets.QMainWindow): # Window inherits from QMainWindow the layout is already defined # to accommodate any toolbars or any other QMainWindow component # use the setCentralWidget() to accommodate this def __init__(self, parent=None): super(InheritQMainWindow, self).__init__(parent) # initialization object widget = QtWidgets.QWidget() layout = QtWidgets.QGridLayout() # set self.setCentralWidget(widget) widget.setLayout(layout) label = QtWidgets.QLabel(&#x27;test&#x27;) layout.addWidget(label, 0, 0) Error in PyCharm When this error occurs, it is due to MayaDevKit environment MayaDevKit allows maya python command auto-completion, remove it from PyCharm 12app &#x3D; QtWidgets.QApplication(sys.argv)TypeError: &#39;NoneType&#39; object is not callable Reference https://www.reddit.com/r/learnpython/comments/jyw8z1/pyqt5_why_do_i_get_an_empty_window/ https://stackoverflow.com/questions/58925453/pycharm-use-pyside2-typeerror-nonetype-object-is-not-callable","categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"},{"name":"Template","slug":"Template","permalink":"http://xingyulei.xyz/tags/Template/"}]}],"categories":[{"name":"Tech Summary","slug":"Tech-Summary","permalink":"http://xingyulei.xyz/categories/Tech-Summary/"},{"name":"Learning Log","slug":"Learning-Log","permalink":"http://xingyulei.xyz/categories/Learning-Log/"},{"name":"Qt Model View Programming","slug":"Qt-Model-View-Programming","permalink":"http://xingyulei.xyz/categories/Qt-Model-View-Programming/"},{"name":"Maya API Series","slug":"Maya-API-Series","permalink":"http://xingyulei.xyz/categories/Maya-API-Series/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://xingyulei.xyz/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"http://xingyulei.xyz/tags/Unity/"},{"name":"PyQt","slug":"PyQt","permalink":"http://xingyulei.xyz/tags/PyQt/"},{"name":"Python","slug":"Python","permalink":"http://xingyulei.xyz/tags/Python/"},{"name":"Style","slug":"Style","permalink":"http://xingyulei.xyz/tags/Style/"},{"name":"Template","slug":"Template","permalink":"http://xingyulei.xyz/tags/Template/"},{"name":"Git","slug":"Git","permalink":"http://xingyulei.xyz/tags/Git/"},{"name":"Version control","slug":"Version-control","permalink":"http://xingyulei.xyz/tags/Version-control/"},{"name":"Maya","slug":"Maya","permalink":"http://xingyulei.xyz/tags/Maya/"}]}