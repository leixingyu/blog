<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Xingyu Lei, wzaxzt@gmail.com"><title>Maya Python API (3. Custom Deformer) Â· Xingyu Lei</title><meta name="description" content="General FormatCustom deformer SampleAPI 1.0
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575"><meta name="keywords" content="Tech, Art"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Xingyu Lei</a></h3><div class="description"><p>Personal Blog</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/sheldonlei"><i class="fa fa-github"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Maya Python API (3. Custom Deformer)</a></h3></div><div class="post-content"><h1 id="General-Format"><a href="#General-Format" class="headerlink" title="General Format"></a>General Format</h1><h3 id="Custom-deformer-Sample"><a href="#Custom-deformer-Sample" class="headerlink" title="Custom deformer Sample"></a>Custom deformer Sample</h3><p>API 1.0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> maya.cmds <span class="keyword">as</span> cmds</span><br><span class="line"><span class="keyword">import</span> maya.OpenMaya <span class="keyword">as</span> om</span><br><span class="line"><span class="keyword">import</span> maya.OpenMayaMPx <span class="keyword">as</span> mpx</span><br><span class="line"></span><br><span class="line">nodeName = <span class="string">&#x27;myFirstDeformer&#x27;</span></span><br><span class="line">nodeID = om.MTypeId(<span class="number">0x55555</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDeformer</span>(<span class="params">mpx.MPxDeformerNode</span>):</span></span><br><span class="line">    amplitudeAttr = om.MObject()</span><br><span class="line">    displacementAttr = om.MObject()</span><br><span class="line">    matrixAttr = om.MObject()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        mpx.MPxDeformerNode.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deform</span>(<span class="params">self, dataBlock, geomIterator, localToWorldMatrix, geomIndex</span>):</span></span><br><span class="line">        <span class="comment"># step 1: access built-in attribute value using attribute name and attribute handle</span></span><br><span class="line">        envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope</span><br><span class="line">        envelopeHandle = dataBlock.inputValue(envelopeAttr)</span><br><span class="line">        envelopeValue = envelopeHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.5: access custom attribute value</span></span><br><span class="line">        amplitudeHandle = dataBlock.inputValue(MyDeformer.amplitudeAttr)</span><br><span class="line">        amplitudeValue = amplitudeHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        displacementHandle = dataBlock.inputValue(MyDeformer.displacementAttr)</span><br><span class="line">        displacementValue = displacementHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.55: access custom attribute value connected to an accessory node</span></span><br><span class="line">        matrixHandle = dataBlock.inputValue(MyDeformer.matrixAttr)</span><br><span class="line">        matrixValue = matrixHandle.asMatrix()</span><br><span class="line">        transMatrix = om.MTransformationMatrix(matrixValue)  <span class="comment"># matrix type</span></span><br><span class="line">        translateValue = transMatrix.getTranslation(om.MSpace.kObject)  <span class="comment"># vector type</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2: access input mesh</span></span><br><span class="line">        inputMesh = self.getDeformerInputGeom(dataBlock, geomIndex)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2.5: access mesh normals</span></span><br><span class="line">        meshFn = om.MFnMesh(inputMesh)</span><br><span class="line">        normalVectorArray = om.MFloatVectorArray()  <span class="comment"># create float vector array to store normal vector</span></span><br><span class="line">        meshFn.getVertexNormals(<span class="literal">False</span>, normalVectorArray, om.MSpace.kObject)  <span class="comment"># (average normal or not?, the array to store, normal space)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 3: iterate the mesh vertices and deform it</span></span><br><span class="line">        newVertexPosArray = om.MPointArray()  <span class="comment"># to store new vertices position</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> geomIterator.isDone():</span><br><span class="line">            vertexPos = geomIterator.position()</span><br><span class="line">            vertexIndex = geomIterator.index()</span><br><span class="line">            normalVector = om.MVector(normalVectorArray[vertexIndex])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># get weight from weightPainting and multiply it to the deform, this is done inside</span></span><br><span class="line">            <span class="comment"># built-in function weightValue(dataBlock, geomIndex, vertexIndex)</span></span><br><span class="line">            weight = self.weightValue(dataBlock, geomIndex, vertexIndex)</span><br><span class="line"></span><br><span class="line">            vertexPos.x = vertexPos.x + math.sin(vertexIndex + displacementValue + translateValue[<span class="number">0</span>]) * normalVector.x * amplitudeValue * envelopeValue * weight</span><br><span class="line">            vertexPos.y = vertexPos.y + math.sin(vertexIndex + displacementValue + translateValue[<span class="number">0</span>]) * normalVector.y * amplitudeValue * envelopeValue * weight</span><br><span class="line">            vertexPos.z = vertexPos.z + math.sin(vertexIndex + displacementValue + translateValue[<span class="number">0</span>]) * normalVector.z * amplitudeValue * envelopeValue * weight</span><br><span class="line">            newVertexPosArray.append(vertexPos)</span><br><span class="line">            geomIterator.<span class="built_in">next</span>()</span><br><span class="line">        geomIterator.setAllPositions(newVertexPosArray)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># override built-in function that allows to create accessory node along with deformer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accessoryNodeSetup</span>(<span class="params">self, dagModifier</span>):</span></span><br><span class="line">        <span class="comment"># step1: create the accessory node using the supplied dagModifier</span></span><br><span class="line">        locator = dagModifier.createNode(<span class="string">&#x27;locator&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step2: access accessory node&#x27;s attribute(can&#x27;t use mplug type, has to be mobject type)</span></span><br><span class="line">        <span class="comment"># access dependency node function set</span></span><br><span class="line">        dependNodeFn = om.MFnDependencyNode(locator)</span><br><span class="line">        matrixPlug = dependNodeFn.findPlug(<span class="string">&#x27;worldMatrix&#x27;</span>)  <span class="comment"># this returns mplug type attribute, we need mobject type attribute</span></span><br><span class="line">        matrixAttr = matrixPlug.attribute()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step3: connect mobject type(required) together</span></span><br><span class="line">        <span class="comment"># param: accessory node(mobject), accessory attr(mobject), deformer node(mobject: using self.thisMObject()), deformer attr(mobject)</span></span><br><span class="line">        mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.matrixAttr)</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;now the accessory node&#x27;s worldMatrix is driving to the in-matrix of the deformer node&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> mConnectStatus</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accessoryAttribute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># returns the deformer node attribute connected</span></span><br><span class="line">        <span class="keyword">return</span> MyDeformer.matrixAttr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDeformerInputGeom</span>(<span class="params">self, dataBlock, geomIndex</span>):</span></span><br><span class="line">        inputAttr = mpx.cvar.MPxGeometryFilter_input</span><br><span class="line">        inputHandle = dataBlock.outputArrayValue(inputAttr)  <span class="comment"># use outputArray instead of inputArray to avoid re-computation</span></span><br><span class="line">        inputHandle.jumpToElement(geomIndex)</span><br><span class="line">        inputElementHandle = inputHandle.outputValue()</span><br><span class="line"></span><br><span class="line">        inputGeomAttr = mpx.cvar.MPxGeometryFilter_inputGeom</span><br><span class="line">        inputGeomHandle = inputElementHandle.child(inputGeomAttr)  <span class="comment"># this is different from how we usually get handler</span></span><br><span class="line">        inputGeomMesh = inputGeomHandle.asMesh()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputGeomMesh</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nodeCreator</span>():</span></span><br><span class="line">    <span class="comment"># return pointer to instance of our deformer node class</span></span><br><span class="line">    <span class="keyword">return</span> mpx.asMPxPtr(MyDeformer())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nodeInitializer</span>():</span></span><br><span class="line">    <span class="comment"># step1: define attribute function set (numericAttr &amp; matrixAttr)</span></span><br><span class="line">    numericAttrFn = om.MFnNumericAttribute()</span><br><span class="line">    matrixAttrFn = om.MFnMatrixAttribute()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2: create custom attribute and set its property</span></span><br><span class="line">    MyDeformer.amplitudeAttr = numericAttrFn.create(<span class="string">&#x27;ampplitude&#x27;</span>, <span class="string">&#x27;amp&#x27;</span>, om.MFnNumericData.kFloat, <span class="number">0.0</span>)</span><br><span class="line">    numericAttrFn.setMin(-<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setMax(<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setReadable(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    MyDeformer.displacementAttr = numericAttrFn.create(<span class="string">&#x27;displacement&#x27;</span>, <span class="string">&#x27;dis&#x27;</span>, om.MFnNumericData.kFloat, <span class="number">0.0</span>)</span><br><span class="line">    numericAttrFn.setMin(-<span class="number">5.0</span>)</span><br><span class="line">    numericAttrFn.setMax(<span class="number">5.0</span>)</span><br><span class="line">    numericAttrFn.setReadable(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    MyDeformer.matrixAttr = matrixAttrFn.create(<span class="string">&#x27;matrix&#x27;</span>, <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">    matrixAttrFn.setStorable(<span class="literal">False</span>)</span><br><span class="line">    matrixAttrFn.setConnectable(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2.5: access built-in attribute using OpenMayaMpx.cvar.MPxGeometryFilter_outputGeom</span></span><br><span class="line">    outputGeom = mpx.cvar.MPxGeometryFilter_outputGeom</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step3: attach attribute</span></span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.amplitudeAttr)</span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.displacementAttr)</span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.matrixAttr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step4: add circuit (relationship)</span></span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.amplitudeAttr, outputGeom)</span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.displacementAttr, outputGeom)</span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.matrixAttr, outputGeom)</span><br><span class="line"></span><br><span class="line">    cmds.makePaintable(nodeName, <span class="string">&#x27;weights&#x27;</span>, attrType=<span class="string">&#x27;multiFloat&#x27;</span>, shapeMode=<span class="string">&#x27;deformer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initializePlugin</span>(<span class="params">mobject</span>):</span></span><br><span class="line">    mplugin = mpx.MFnPlugin(mobject)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Parameter: node_name, node_id, node_creatorFunc, node_initFuc, nodeType(common type include-kDeformerNode, kDependNode)</span></span><br><span class="line">        mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, mpx.MPxNode.kDeformerNode)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        sys.stderr(<span class="string">&#x27;fail to register node: &#x27;</span> + nodeName)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uninitializePlugin</span>(<span class="params">mobject</span>):</span></span><br><span class="line">    mplugin = mpx.MFnPlugin(mobject)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mplugin.deregisterNode(nodeID)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        sys.stderr(<span class="string">&#x27;fail to de-register node: &#x27;</span> + nodeName)</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<p><br/></br></p>
<h2 id="Node-MPxDeformerNode-is-only-available-in-API-2-0"><a href="#Node-MPxDeformerNode-is-only-available-in-API-2-0" class="headerlink" title="Node: MPxDeformerNode is only available in API 2.0"></a>Node: MPxDeformerNode is only available in API 2.0</h2><p><br/></br></p>
<h2 id="Custom-Attribute-vs-Built-in-Attribute"><a href="#Custom-Attribute-vs-Built-in-Attribute" class="headerlink" title="Custom Attribute vs. Built-in Attribute"></a>Custom Attribute vs. Built-in Attribute</h2><p>In the last chapter, we know how to create custom numeric type attribute using <strong>MFnNumericAttribute</strong>. Sometimes in our node, we want to access existing built-in attribute. We do so by using <strong>OpenMayaMPx.cvar.MPxDeformerNode_(attributeName)</strong> before Maya 2016, we use <strong>OpenMayaMPx.cvar.MPxGeometryFilter_(attributeName)</strong> after 2016.</p>
<h2 id="Obtain-Input-Geometry"><a href="#Obtain-Input-Geometry" class="headerlink" title="Obtain Input Geometry"></a>Obtain Input Geometry</h2><p>In the sample code, we define our custom function <strong>getDeformerInputGeom(self, dataBlock, geomIndex)</strong> to obtain the input mesh to the deformer node. We will discuss this later.</p>
<h2 id="Accessory-Node"><a href="#Accessory-Node" class="headerlink" title="Accessory Node"></a>Accessory Node</h2><p>Accessory node acts like a secondary driver node connected to our deformer so they can influence the deformation. In the sample code, our accessory node is a locator which when we connects its world matrix, it will change our meshâs deformation when translating.</p>
<h2 id="Custom-Dependency-Node-vs-Custom-Deformer-Node"><a href="#Custom-Dependency-Node-vs-Custom-Deformer-Node" class="headerlink" title="Custom Dependency Node vs. Custom Deformer Node"></a>Custom Dependency Node vs. Custom Deformer Node</h2><p><strong>Registration:</strong> In our previous chapter, we register our node using <strong>registerNode()</strong> with node type: <strong>omMPx.MPxNode.kDependNode</strong>, in deformer node, we use <strong>omMPx.MPxNode.kDeformerNode</strong> as our node type.</p>
<p><strong>Inheritence:</strong> We now inherit our class from <strong>omMPx.MPxDeformerNode</strong> instead of <strong>omMPxNode</strong><br>thereâs still <strong>compute()</strong> in MPxDeformerNode class, but we want to write our deformation algorithm in <strong>deform()</strong>.</p>
<p><strong>Accessory Node:</strong> <strong>accessoryNodeSetup(self, dagModifier)</strong> and <strong>accessoryAttribute(self)</strong> is overrided to allow us to control accessory node along with our deformer.</p>
<p><br/></br></p>
<h1 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h1><h3 id="step-1-Declare-attribute-Same-as-last-chapter"><a href="#step-1-Declare-attribute-Same-as-last-chapter" class="headerlink" title="step 1: Declare attribute (Same as last chapter)"></a>step 1: Declare attribute (Same as last chapter)</h3><h3 id="step-2-Initialize-Node"><a href="#step-2-Initialize-Node" class="headerlink" title="step 2: Initialize Node"></a>step 2: Initialize Node</h3><p><strong>Node Creator</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nodeCreator</span>():</span></span><br><span class="line">    <span class="keyword">return</span> mpx.asMPxPtr(MyDeformer())</span><br></pre></td></tr></table></figure>
<p>Only API 1.0 is available.</p>
<p><strong>Node Initializer</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nodeInitializer</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;1: create reference to numericAttribute and matrixAttribute function sets&#x27;&#x27;&#x27;</span></span><br><span class="line">    numericAttrFn = om.MFnNumericAttribute()</span><br><span class="line">    matrixAttrFn = om.MFnMatrixAttribute()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 2: create attribute using the function set&#x27;&#x27;&#x27;</span></span><br><span class="line">    MyDeformer.inNumAttr = numericAttrFn.create(<span class="string">&#x27;num&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, om.MFnNumericData.kFloat, <span class="number">0.0</span>)</span><br><span class="line">    numericAttrFn.setMin(-<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setMax(<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setReadable(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    MyDeformer.inMatAttr = numericAttrFn.create(<span class="string">&#x27;matrix&#x27;</span>, <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">    matrixAttrFn.setStorable(<span class="literal">False</span>)</span><br><span class="line">    matrixAttrFn.setConnectable(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 2.5: access built-in attribute using OpenMayaMpx.cvar.MPxGeometryFilter_outputGeom&#x27;&#x27;&#x27;</span></span><br><span class="line">    outputGeom = mpx.cvar.MPxGeometryFilter_outputGeom</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 3: attach attribute&#x27;&#x27;&#x27;</span></span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.inNumAttr)</span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.inMatAttr)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 4: add circuit (relationship in-&gt;out)&#x27;&#x27;&#x27;</span></span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.inNumAttr, ouputGeom)</span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.inMatAttr, ouputGeom)</span><br><span class="line"></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27; 5: make attribute paintable&#x27;&#x27;&#x27;</span></span><br><span class="line">	cmds.makePaintable(nodeName, <span class="string">&#x27;weights&#x27;</span>, attrType=<span class="string">&#x27;multiFloat&#x27;</span>, shapeMode=<span class="string">&#x27;deformer&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>we access the output Geometry attribute so we can later add relationship to it.</p>
<p><strong>RegisterNode</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDeformNode)</span><br></pre></td></tr></table></figure>
<p><strong>De-registerNode</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplugin.deregisterNode(nodeID)</span><br></pre></td></tr></table></figure>
<h3 id="step-3-Initialize-Node-ï¼Actual-Deform-Algorithmï¼"><a href="#step-3-Initialize-Node-ï¼Actual-Deform-Algorithmï¼" class="headerlink" title="step 3: Initialize Node ï¼Actual Deform Algorithmï¼"></a>step 3: Initialize Node ï¼Actual Deform Algorithmï¼</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNode</span>(<span class="params">om.MPxDeformNode</span>):</span></span><br><span class="line">    inNumAttr = om.MObject()</span><br><span class="line">    inMatAttr = om.MObject()</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		om.MPxDeformNode.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deform</span>(<span class="params">self, dataBlock, geomIterator, localToWorldMatrix, geomIndex</span>):</span></span><br><span class="line">        <span class="comment"># step 1: access built-in attribute value using attribute name and attribute handle</span></span><br><span class="line">        envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope</span><br><span class="line">        envelopeHandle = dataBlock.inputValue(envelopeAttr)</span><br><span class="line">        envelopeValue = envelopeHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.5: access custom attribute value</span></span><br><span class="line">        inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr)</span><br><span class="line">        inNumValue = inNumHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.55: access custom translate value connected to an accessory node</span></span><br><span class="line">        inMatHandle = dataBlock.inputValue(MyDeformer.inMatAttr)</span><br><span class="line">        inMatValue = inNumHandle.asMatrix()</span><br><span class="line">        transMatrix = om.MTransformationMatrix(inMatValue)  <span class="comment"># matrix type</span></span><br><span class="line">        translateValue = transMatrix.getTranslation(om.MSpace.kObject)  <span class="comment"># vector type</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2: access input mesh</span></span><br><span class="line">        inputMesh = self.getDeformerInputGeom(dataBlock, geomIndex)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2.5: access mesh normals</span></span><br><span class="line">        meshFn = om.MFnMesh(inputMesh)</span><br><span class="line">        normalVectorArray = om.MFloatVectorArray()  <span class="comment"># create float vector array to store normal vector</span></span><br><span class="line">        meshFn.getVertexNormals(<span class="literal">False</span>, normalVectorArray, om.MSpace.kObject)  <span class="comment"># (average normal or not?, the array to store, normal space)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 3: iterate the mesh vertices and deform it</span></span><br><span class="line">        newVertexPosArray = om.MPointArray()  <span class="comment"># to store new vertices position</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> geomIterator.isDone():</span><br><span class="line">            vertexPos = geomIterator.position()</span><br><span class="line">            vertexIndex = geomIterator.index()</span><br><span class="line">            normalVector = om.MVector(normalVectorArray[vertexIndex])</span><br><span class="line">            <span class="comment"># built-in function weightValue(dataBlock, geomIndex, vertexIndex)</span></span><br><span class="line">            weight = self.weightValue(dataBlock, geomIndex, vertexIndex)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># vertexPos.x = vertexPos.x + [calculation of normalVector.x and translateValue[0]] * envelopeValue * weight</span></span><br><span class="line">            newVertexPosArray.append(vertexPos)</span><br><span class="line">            geomIterator.<span class="built_in">next</span>()</span><br><span class="line">        geomIterator.setAllPositions(newVertexPosArray)</span><br></pre></td></tr></table></figure>
<p>âTo access a value from an attribute, we use <strong>handle = dataBlock.input/outputValue(MyNode.attr)</strong></p>
<p>if we have a custom attribute <strong>âinNumAttrâ:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr)<br>&nbsp;&nbsp;&nbsp;&nbsp;inNumValue = inNumHandle.asFloat()<br>if we have a built-in attribte <strong>âenvelopeâ</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;# we first get our attribute name âenvelopeâ<br>&nbsp;&nbsp;&nbsp;&nbsp;envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope<br>&nbsp;&nbsp;&nbsp;&nbsp;envelopeHandle = dataBlock.inputValue(envelopeAttr)<br>&nbsp;&nbsp;&nbsp;&nbsp;envelopeValue = envelopeHandle.asFloat()</p>
<p>âTo get normal for individual vertices on our input mesh, we first need to obtain our input mesh using our own function: <strong>getDeformerInputGeom(self, dataBlock, geomIndex)</strong>. And using mesh function set MeshFnâs <strong>getVertexNormals()</strong> we store the normal vector in <strong>om.MFloatVectorArray()</strong> type array.</p>
<p>âTo deform our mesh: we use the geometry iterator to perform iteration on each mesh vertex and re-calculate its position. We combine the use of <strong>geoIterator.position()</strong> and <strong>geomIterator.setPosition(point)</strong> or <strong>geomIterator.setAllPositions(pointArray)</strong>.</p>
<p>â  To access weight value on each vertex, we use built-in function <strong>weightValue(dataBlock, geomIndex, vertexIndex)</strong>. In which, <strong>geomIndex</strong> is provided in <strong>deform()</strong> and <strong>vertexIndex</strong> is from <strong>geomIterator</strong>.</p>
<h3 id="Step-3-1-Get-in-Mesh"><a href="#Step-3-1-Get-in-Mesh" class="headerlink" title="Step 3.1: Get in-Mesh"></a>Step 3.1: Get in-Mesh</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDeformerInputGeom</span>(<span class="params">self, dataBlock, geomIndex</span>):</span></span><br><span class="line">    inputAttr = mpx.cvar.MPxGeometryFilter_input</span><br><span class="line">    inputHandle = dataBlock.outputArrayValue(inputAttr)  <span class="comment"># use outputArray instead of inputArray to avoid re-computation</span></span><br><span class="line">    inputHandle.jumpToElement(geomIndex)</span><br><span class="line">    inputElementHandle = inputHandle.outputValue()</span><br><span class="line"></span><br><span class="line">    inputGeomAttr = mpx.cvar.MPxGeometryFilter_inputGeom</span><br><span class="line">    inputGeomHandle = inputElementHandle.child(inputGeomAttr)  <span class="comment"># this is different from how we usually get handler</span></span><br><span class="line">    inputGeomMesh = inputGeomHandle.asMesh()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inputGeomMesh</span><br></pre></td></tr></table></figure>
<p>At this point, I canât fully interpret the meaning of this segment.</p>
<h3 id="Step-4-Accessory-Node"><a href="#Step-4-Accessory-Node" class="headerlink" title="Step 4: Accessory Node"></a>Step 4: Accessory Node</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accessoryNodeSetup</span>(<span class="params">self, dagModifier</span>):</span></span><br><span class="line">    <span class="comment"># step1: create the accessory node using the supplied dagModifier</span></span><br><span class="line">    locator = dagModifier.createNode(<span class="string">&#x27;locator&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2: access accessory node&#x27;s attribute(can&#x27;t use mplug type, has to be mobject type)</span></span><br><span class="line">    <span class="comment"># access dependency node function set</span></span><br><span class="line">    dependNodeFn = om.MFnDependencyNode(locator)</span><br><span class="line">    matrixPlug = dependNodeFn.findPlug(<span class="string">&#x27;worldMatrix&#x27;</span>)  <span class="comment"># this returns mplug type attribute, we need mobject type attribute</span></span><br><span class="line">    matrixAttr = matrixPlug.attribute()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step3: connect mobject type(required) together</span></span><br><span class="line">    <span class="comment"># param: accessory node(mobject), accessory attr(mobject), deformer node(mobject: using self.thisMObject()), deformer attr(mobject)</span></span><br><span class="line">    mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;now the accessory node&#x27;s worldMatrix is driving to the custom in-matrix of the deformer node&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> mConnectStatus</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accessoryAttribute</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment"># returns the deformer node attribute connected</span></span><br><span class="line">    <span class="keyword">return</span> MyDeformer.inMatAttr</span><br></pre></td></tr></table></figure>
<p>The dagModifer is supplied in the accessory node. We use dagModifierâs connect function to connect the accessory nodeâs attribute to our deformer nodeâs attribute. In this case, we have accessoryâs attribute: worldMatrix (a built-in attribute obtained from <strong>MFnDependencyNode.findPlug())</strong> and our custom defined <strong>MyDeformer.inMatAttr.</strong></p>
<p>One thing to note is that, the <strong>.connect()</strong> only takes MObject which we cannot supply MPlug type object <strong>matrixPlug = â¦findPlug(âattributeNameâ)</strong>, we perform additional step <strong>matrixAttr = matrixPlug.attribute()</strong> to get the MObject type attribute.</p>
<p>Now we supply <strong>.connect()</strong> with parameters: accessory node (MObject type), accessory nodeâs attribute (MObject type), deformer node (MObject type) and deformer nodeâs attribute (MObject type) as follow:<strong>mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr)</strong></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-11-11</span><i class="fa fa-tag"></i><a class="tag" href="/categories/learning-log/" title="learning log">learning log </a><a class="tag" href="/tags/maya/" title="maya">maya </a><a class="tag" href="/tags/python/" title="python">python </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2019/11/11/maya-api-3/,Xingyu Lei,Maya Python API (3. Custom Deformer),;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/11/19/verlet-integration/" title="Verlet Integration">prev_post</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/11/10/maya-api-2/" title="Maya Python API (2. Custom Node)">next_post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>