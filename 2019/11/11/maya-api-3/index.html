<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Xingyu Lei, wzaxzt@gmail.com"><title>Maya Python API (3. Custom Deformer) · Xingyu Lei</title><meta name="description" content="General FormatCustom deformer SampleAPI 1.0
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575"><meta name="keywords" content="Tech, Art"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Xingyu Lei</a></h3><div class="description"><p>Personal Blog</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/sheldonlei"><i class="fa fa-github"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Maya Python API (3. Custom Deformer)</a></h3></div><div class="post-content"><h1 id="General-Format"><a href="#General-Format" class="headerlink" title="General Format"></a>General Format</h1><h3 id="Custom-deformer-Sample"><a href="#Custom-deformer-Sample" class="headerlink" title="Custom deformer Sample"></a>Custom deformer Sample</h3><p>API 1.0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> maya.cmds <span class="keyword">as</span> cmds</span><br><span class="line"><span class="keyword">import</span> maya.OpenMaya <span class="keyword">as</span> om</span><br><span class="line"><span class="keyword">import</span> maya.OpenMayaMPx <span class="keyword">as</span> mpx</span><br><span class="line"></span><br><span class="line">nodeName = <span class="string">&#x27;myFirstDeformer&#x27;</span></span><br><span class="line">nodeID = om.MTypeId(<span class="number">0x55555</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDeformer</span>(<span class="params">mpx.MPxDeformerNode</span>):</span></span><br><span class="line">    amplitudeAttr = om.MObject()</span><br><span class="line">    displacementAttr = om.MObject()</span><br><span class="line">    matrixAttr = om.MObject()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        mpx.MPxDeformerNode.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deform</span>(<span class="params">self, dataBlock, geomIterator, localToWorldMatrix, geomIndex</span>):</span></span><br><span class="line">        <span class="comment"># step 1: access built-in attribute value using attribute name and attribute handle</span></span><br><span class="line">        envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope</span><br><span class="line">        envelopeHandle = dataBlock.inputValue(envelopeAttr)</span><br><span class="line">        envelopeValue = envelopeHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.5: access custom attribute value</span></span><br><span class="line">        amplitudeHandle = dataBlock.inputValue(MyDeformer.amplitudeAttr)</span><br><span class="line">        amplitudeValue = amplitudeHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        displacementHandle = dataBlock.inputValue(MyDeformer.displacementAttr)</span><br><span class="line">        displacementValue = displacementHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.55: access custom attribute value connected to an accessory node</span></span><br><span class="line">        matrixHandle = dataBlock.inputValue(MyDeformer.matrixAttr)</span><br><span class="line">        matrixValue = matrixHandle.asMatrix()</span><br><span class="line">        transMatrix = om.MTransformationMatrix(matrixValue)  <span class="comment"># matrix type</span></span><br><span class="line">        translateValue = transMatrix.getTranslation(om.MSpace.kObject)  <span class="comment"># vector type</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2: access input mesh</span></span><br><span class="line">        inputMesh = self.getDeformerInputGeom(dataBlock, geomIndex)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2.5: access mesh normals</span></span><br><span class="line">        meshFn = om.MFnMesh(inputMesh)</span><br><span class="line">        normalVectorArray = om.MFloatVectorArray()  <span class="comment"># create float vector array to store normal vector</span></span><br><span class="line">        meshFn.getVertexNormals(<span class="literal">False</span>, normalVectorArray, om.MSpace.kObject)  <span class="comment"># (average normal or not?, the array to store, normal space)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 3: iterate the mesh vertices and deform it</span></span><br><span class="line">        newVertexPosArray = om.MPointArray()  <span class="comment"># to store new vertices position</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> geomIterator.isDone():</span><br><span class="line">            vertexPos = geomIterator.position()</span><br><span class="line">            vertexIndex = geomIterator.index()</span><br><span class="line">            normalVector = om.MVector(normalVectorArray[vertexIndex])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># get weight from weightPainting and multiply it to the deform, this is done inside</span></span><br><span class="line">            <span class="comment"># built-in function weightValue(dataBlock, geomIndex, vertexIndex)</span></span><br><span class="line">            weight = self.weightValue(dataBlock, geomIndex, vertexIndex)</span><br><span class="line"></span><br><span class="line">            vertexPos.x = vertexPos.x + math.sin(vertexIndex + displacementValue + translateValue[<span class="number">0</span>]) * normalVector.x * amplitudeValue * envelopeValue * weight</span><br><span class="line">            vertexPos.y = vertexPos.y + math.sin(vertexIndex + displacementValue + translateValue[<span class="number">0</span>]) * normalVector.y * amplitudeValue * envelopeValue * weight</span><br><span class="line">            vertexPos.z = vertexPos.z + math.sin(vertexIndex + displacementValue + translateValue[<span class="number">0</span>]) * normalVector.z * amplitudeValue * envelopeValue * weight</span><br><span class="line">            newVertexPosArray.append(vertexPos)</span><br><span class="line">            geomIterator.<span class="built_in">next</span>()</span><br><span class="line">        geomIterator.setAllPositions(newVertexPosArray)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># override built-in function that allows to create accessory node along with deformer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accessoryNodeSetup</span>(<span class="params">self, dagModifier</span>):</span></span><br><span class="line">        <span class="comment"># step1: create the accessory node using the supplied dagModifier</span></span><br><span class="line">        locator = dagModifier.createNode(<span class="string">&#x27;locator&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step2: access accessory node&#x27;s attribute(can&#x27;t use mplug type, has to be mobject type)</span></span><br><span class="line">        <span class="comment"># access dependency node function set</span></span><br><span class="line">        dependNodeFn = om.MFnDependencyNode(locator)</span><br><span class="line">        matrixPlug = dependNodeFn.findPlug(<span class="string">&#x27;worldMatrix&#x27;</span>)  <span class="comment"># this returns mplug type attribute, we need mobject type attribute</span></span><br><span class="line">        matrixAttr = matrixPlug.attribute()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step3: connect mobject type(required) together</span></span><br><span class="line">        <span class="comment"># param: accessory node(mobject), accessory attr(mobject), deformer node(mobject: using self.thisMObject()), deformer attr(mobject)</span></span><br><span class="line">        mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.matrixAttr)</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;now the accessory node&#x27;s worldMatrix is driving to the in-matrix of the deformer node&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> mConnectStatus</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accessoryAttribute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># returns the deformer node attribute connected</span></span><br><span class="line">        <span class="keyword">return</span> MyDeformer.matrixAttr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDeformerInputGeom</span>(<span class="params">self, dataBlock, geomIndex</span>):</span></span><br><span class="line">        inputAttr = mpx.cvar.MPxGeometryFilter_input</span><br><span class="line">        inputHandle = dataBlock.outputArrayValue(inputAttr)  <span class="comment"># use outputArray instead of inputArray to avoid re-computation</span></span><br><span class="line">        inputHandle.jumpToElement(geomIndex)</span><br><span class="line">        inputElementHandle = inputHandle.outputValue()</span><br><span class="line"></span><br><span class="line">        inputGeomAttr = mpx.cvar.MPxGeometryFilter_inputGeom</span><br><span class="line">        inputGeomHandle = inputElementHandle.child(inputGeomAttr)  <span class="comment"># this is different from how we usually get handler</span></span><br><span class="line">        inputGeomMesh = inputGeomHandle.asMesh()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputGeomMesh</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nodeCreator</span>():</span></span><br><span class="line">    <span class="comment"># return pointer to instance of our deformer node class</span></span><br><span class="line">    <span class="keyword">return</span> mpx.asMPxPtr(MyDeformer())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nodeInitializer</span>():</span></span><br><span class="line">    <span class="comment"># step1: define attribute function set (numericAttr &amp; matrixAttr)</span></span><br><span class="line">    numericAttrFn = om.MFnNumericAttribute()</span><br><span class="line">    matrixAttrFn = om.MFnMatrixAttribute()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2: create custom attribute and set its property</span></span><br><span class="line">    MyDeformer.amplitudeAttr = numericAttrFn.create(<span class="string">&#x27;ampplitude&#x27;</span>, <span class="string">&#x27;amp&#x27;</span>, om.MFnNumericData.kFloat, <span class="number">0.0</span>)</span><br><span class="line">    numericAttrFn.setMin(-<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setMax(<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setReadable(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    MyDeformer.displacementAttr = numericAttrFn.create(<span class="string">&#x27;displacement&#x27;</span>, <span class="string">&#x27;dis&#x27;</span>, om.MFnNumericData.kFloat, <span class="number">0.0</span>)</span><br><span class="line">    numericAttrFn.setMin(-<span class="number">5.0</span>)</span><br><span class="line">    numericAttrFn.setMax(<span class="number">5.0</span>)</span><br><span class="line">    numericAttrFn.setReadable(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    MyDeformer.matrixAttr = matrixAttrFn.create(<span class="string">&#x27;matrix&#x27;</span>, <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">    matrixAttrFn.setStorable(<span class="literal">False</span>)</span><br><span class="line">    matrixAttrFn.setConnectable(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2.5: access built-in attribute using OpenMayaMpx.cvar.MPxGeometryFilter_outputGeom</span></span><br><span class="line">    outputGeom = mpx.cvar.MPxGeometryFilter_outputGeom</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step3: attach attribute</span></span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.amplitudeAttr)</span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.displacementAttr)</span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.matrixAttr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step4: add circuit (relationship)</span></span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.amplitudeAttr, outputGeom)</span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.displacementAttr, outputGeom)</span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.matrixAttr, outputGeom)</span><br><span class="line"></span><br><span class="line">    cmds.makePaintable(nodeName, <span class="string">&#x27;weights&#x27;</span>, attrType=<span class="string">&#x27;multiFloat&#x27;</span>, shapeMode=<span class="string">&#x27;deformer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initializePlugin</span>(<span class="params">mobject</span>):</span></span><br><span class="line">    mplugin = mpx.MFnPlugin(mobject)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Parameter: node_name, node_id, node_creatorFunc, node_initFuc, nodeType(common type include-kDeformerNode, kDependNode)</span></span><br><span class="line">        mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, mpx.MPxNode.kDeformerNode)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        sys.stderr(<span class="string">&#x27;fail to register node: &#x27;</span> + nodeName)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uninitializePlugin</span>(<span class="params">mobject</span>):</span></span><br><span class="line">    mplugin = mpx.MFnPlugin(mobject)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mplugin.deregisterNode(nodeID)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        sys.stderr(<span class="string">&#x27;fail to de-register node: &#x27;</span> + nodeName)</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<p><br/></br></p>
<h2 id="Node-MPxDeformerNode-is-only-available-in-API-2-0"><a href="#Node-MPxDeformerNode-is-only-available-in-API-2-0" class="headerlink" title="Node: MPxDeformerNode is only available in API 2.0"></a>Node: MPxDeformerNode is only available in API 2.0</h2><p><br/></br></p>
<h2 id="Custom-Attribute-vs-Built-in-Attribute"><a href="#Custom-Attribute-vs-Built-in-Attribute" class="headerlink" title="Custom Attribute vs. Built-in Attribute"></a>Custom Attribute vs. Built-in Attribute</h2><p>In the last chapter, we know how to create custom numeric type attribute using <strong>MFnNumericAttribute</strong>. Sometimes in our node, we want to access existing built-in attribute. We do so by using <strong>OpenMayaMPx.cvar.MPxDeformerNode_(attributeName)</strong> before Maya 2016, we use <strong>OpenMayaMPx.cvar.MPxGeometryFilter_(attributeName)</strong> after 2016.</p>
<h2 id="Obtain-Input-Geometry"><a href="#Obtain-Input-Geometry" class="headerlink" title="Obtain Input Geometry"></a>Obtain Input Geometry</h2><p>In the sample code, we define our custom function <strong>getDeformerInputGeom(self, dataBlock, geomIndex)</strong> to obtain the input mesh to the deformer node. We will discuss this later.</p>
<h2 id="Accessory-Node"><a href="#Accessory-Node" class="headerlink" title="Accessory Node"></a>Accessory Node</h2><p>Accessory node acts like a secondary driver node connected to our deformer so they can influence the deformation. In the sample code, our accessory node is a locator which when we connects its world matrix, it will change our mesh’s deformation when translating.</p>
<h2 id="Custom-Dependency-Node-vs-Custom-Deformer-Node"><a href="#Custom-Dependency-Node-vs-Custom-Deformer-Node" class="headerlink" title="Custom Dependency Node vs. Custom Deformer Node"></a>Custom Dependency Node vs. Custom Deformer Node</h2><p><strong>Registration:</strong> In our previous chapter, we register our node using <strong>registerNode()</strong> with node type: <strong>omMPx.MPxNode.kDependNode</strong>, in deformer node, we use <strong>omMPx.MPxNode.kDeformerNode</strong> as our node type.</p>
<p><strong>Inheritence:</strong> We now inherit our class from <strong>omMPx.MPxDeformerNode</strong> instead of <strong>omMPxNode</strong><br>there’s still <strong>compute()</strong> in MPxDeformerNode class, but we want to write our deformation algorithm in <strong>deform()</strong>.</p>
<p><strong>Accessory Node:</strong> <strong>accessoryNodeSetup(self, dagModifier)</strong> and <strong>accessoryAttribute(self)</strong> is overrided to allow us to control accessory node along with our deformer.</p>
<p><br/></br></p>
<h1 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h1><h3 id="step-1-Declare-attribute-Same-as-last-chapter"><a href="#step-1-Declare-attribute-Same-as-last-chapter" class="headerlink" title="step 1: Declare attribute (Same as last chapter)"></a>step 1: Declare attribute (Same as last chapter)</h3><h3 id="step-2-Initialize-Node"><a href="#step-2-Initialize-Node" class="headerlink" title="step 2: Initialize Node"></a>step 2: Initialize Node</h3><p><strong>Node Creator</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nodeCreator</span>():</span></span><br><span class="line">    <span class="keyword">return</span> mpx.asMPxPtr(MyDeformer())</span><br></pre></td></tr></table></figure>
<p>Only API 1.0 is available.</p>
<p><strong>Node Initializer</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nodeInitializer</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;1: create reference to numericAttribute and matrixAttribute function sets&#x27;&#x27;&#x27;</span></span><br><span class="line">    numericAttrFn = om.MFnNumericAttribute()</span><br><span class="line">    matrixAttrFn = om.MFnMatrixAttribute()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 2: create attribute using the function set&#x27;&#x27;&#x27;</span></span><br><span class="line">    MyDeformer.inNumAttr = numericAttrFn.create(<span class="string">&#x27;num&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, om.MFnNumericData.kFloat, <span class="number">0.0</span>)</span><br><span class="line">    numericAttrFn.setMin(-<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setMax(<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setReadable(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    MyDeformer.inMatAttr = numericAttrFn.create(<span class="string">&#x27;matrix&#x27;</span>, <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">    matrixAttrFn.setStorable(<span class="literal">False</span>)</span><br><span class="line">    matrixAttrFn.setConnectable(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 2.5: access built-in attribute using OpenMayaMpx.cvar.MPxGeometryFilter_outputGeom&#x27;&#x27;&#x27;</span></span><br><span class="line">    outputGeom = mpx.cvar.MPxGeometryFilter_outputGeom</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 3: attach attribute&#x27;&#x27;&#x27;</span></span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.inNumAttr)</span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.inMatAttr)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 4: add circuit (relationship in-&gt;out)&#x27;&#x27;&#x27;</span></span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.inNumAttr, ouputGeom)</span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.inMatAttr, ouputGeom)</span><br><span class="line"></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27; 5: make attribute paintable&#x27;&#x27;&#x27;</span></span><br><span class="line">	cmds.makePaintable(nodeName, <span class="string">&#x27;weights&#x27;</span>, attrType=<span class="string">&#x27;multiFloat&#x27;</span>, shapeMode=<span class="string">&#x27;deformer&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>we access the output Geometry attribute so we can later add relationship to it.</p>
<p><strong>RegisterNode</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDeformNode)</span><br></pre></td></tr></table></figure>
<p><strong>De-registerNode</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplugin.deregisterNode(nodeID)</span><br></pre></td></tr></table></figure>
<h3 id="step-3-Initialize-Node-（Actual-Deform-Algorithm）"><a href="#step-3-Initialize-Node-（Actual-Deform-Algorithm）" class="headerlink" title="step 3: Initialize Node （Actual Deform Algorithm）"></a>step 3: Initialize Node （Actual Deform Algorithm）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNode</span>(<span class="params">om.MPxDeformNode</span>):</span></span><br><span class="line">    inNumAttr = om.MObject()</span><br><span class="line">    inMatAttr = om.MObject()</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		om.MPxDeformNode.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deform</span>(<span class="params">self, dataBlock, geomIterator, localToWorldMatrix, geomIndex</span>):</span></span><br><span class="line">        <span class="comment"># step 1: access built-in attribute value using attribute name and attribute handle</span></span><br><span class="line">        envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope</span><br><span class="line">        envelopeHandle = dataBlock.inputValue(envelopeAttr)</span><br><span class="line">        envelopeValue = envelopeHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.5: access custom attribute value</span></span><br><span class="line">        inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr)</span><br><span class="line">        inNumValue = inNumHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.55: access custom translate value connected to an accessory node</span></span><br><span class="line">        inMatHandle = dataBlock.inputValue(MyDeformer.inMatAttr)</span><br><span class="line">        inMatValue = inNumHandle.asMatrix()</span><br><span class="line">        transMatrix = om.MTransformationMatrix(inMatValue)  <span class="comment"># matrix type</span></span><br><span class="line">        translateValue = transMatrix.getTranslation(om.MSpace.kObject)  <span class="comment"># vector type</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2: access input mesh</span></span><br><span class="line">        inputMesh = self.getDeformerInputGeom(dataBlock, geomIndex)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2.5: access mesh normals</span></span><br><span class="line">        meshFn = om.MFnMesh(inputMesh)</span><br><span class="line">        normalVectorArray = om.MFloatVectorArray()  <span class="comment"># create float vector array to store normal vector</span></span><br><span class="line">        meshFn.getVertexNormals(<span class="literal">False</span>, normalVectorArray, om.MSpace.kObject)  <span class="comment"># (average normal or not?, the array to store, normal space)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 3: iterate the mesh vertices and deform it</span></span><br><span class="line">        newVertexPosArray = om.MPointArray()  <span class="comment"># to store new vertices position</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> geomIterator.isDone():</span><br><span class="line">            vertexPos = geomIterator.position()</span><br><span class="line">            vertexIndex = geomIterator.index()</span><br><span class="line">            normalVector = om.MVector(normalVectorArray[vertexIndex])</span><br><span class="line">            <span class="comment"># built-in function weightValue(dataBlock, geomIndex, vertexIndex)</span></span><br><span class="line">            weight = self.weightValue(dataBlock, geomIndex, vertexIndex)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># vertexPos.x = vertexPos.x + [calculation of normalVector.x and translateValue[0]] * envelopeValue * weight</span></span><br><span class="line">            newVertexPosArray.append(vertexPos)</span><br><span class="line">            geomIterator.<span class="built_in">next</span>()</span><br><span class="line">        geomIterator.setAllPositions(newVertexPosArray)</span><br></pre></td></tr></table></figure>
<p>–To access a value from an attribute, we use <strong>handle = dataBlock.input/outputValue(MyNode.attr)</strong></p>
<p>if we have a custom attribute <strong>‘inNumAttr’:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr)<br>&nbsp;&nbsp;&nbsp;&nbsp;inNumValue = inNumHandle.asFloat()<br>if we have a built-in attribte <strong>‘envelope’</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;# we first get our attribute name ‘envelope’<br>&nbsp;&nbsp;&nbsp;&nbsp;envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope<br>&nbsp;&nbsp;&nbsp;&nbsp;envelopeHandle = dataBlock.inputValue(envelopeAttr)<br>&nbsp;&nbsp;&nbsp;&nbsp;envelopeValue = envelopeHandle.asFloat()</p>
<p>–To get normal for individual vertices on our input mesh, we first need to obtain our input mesh using our own function: <strong>getDeformerInputGeom(self, dataBlock, geomIndex)</strong>. And using mesh function set MeshFn’s <strong>getVertexNormals()</strong> we store the normal vector in <strong>om.MFloatVectorArray()</strong> type array.</p>
<p>–To deform our mesh: we use the geometry iterator to perform iteration on each mesh vertex and re-calculate its position. We combine the use of <strong>geoIterator.position()</strong> and <strong>geomIterator.setPosition(point)</strong> or <strong>geomIterator.setAllPositions(pointArray)</strong>.</p>
<p>–  To access weight value on each vertex, we use built-in function <strong>weightValue(dataBlock, geomIndex, vertexIndex)</strong>. In which, <strong>geomIndex</strong> is provided in <strong>deform()</strong> and <strong>vertexIndex</strong> is from <strong>geomIterator</strong>.</p>
<h3 id="Step-3-1-Get-in-Mesh"><a href="#Step-3-1-Get-in-Mesh" class="headerlink" title="Step 3.1: Get in-Mesh"></a>Step 3.1: Get in-Mesh</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDeformerInputGeom</span>(<span class="params">self, dataBlock, geomIndex</span>):</span></span><br><span class="line">    inputAttr = mpx.cvar.MPxGeometryFilter_input</span><br><span class="line">    inputHandle = dataBlock.outputArrayValue(inputAttr)  <span class="comment"># use outputArray instead of inputArray to avoid re-computation</span></span><br><span class="line">    inputHandle.jumpToElement(geomIndex)</span><br><span class="line">    inputElementHandle = inputHandle.outputValue()</span><br><span class="line"></span><br><span class="line">    inputGeomAttr = mpx.cvar.MPxGeometryFilter_inputGeom</span><br><span class="line">    inputGeomHandle = inputElementHandle.child(inputGeomAttr)  <span class="comment"># this is different from how we usually get handler</span></span><br><span class="line">    inputGeomMesh = inputGeomHandle.asMesh()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inputGeomMesh</span><br></pre></td></tr></table></figure>
<p>At this point, I can’t fully interpret the meaning of this segment.</p>
<h3 id="Step-4-Accessory-Node"><a href="#Step-4-Accessory-Node" class="headerlink" title="Step 4: Accessory Node"></a>Step 4: Accessory Node</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accessoryNodeSetup</span>(<span class="params">self, dagModifier</span>):</span></span><br><span class="line">    <span class="comment"># step1: create the accessory node using the supplied dagModifier</span></span><br><span class="line">    locator = dagModifier.createNode(<span class="string">&#x27;locator&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2: access accessory node&#x27;s attribute(can&#x27;t use mplug type, has to be mobject type)</span></span><br><span class="line">    <span class="comment"># access dependency node function set</span></span><br><span class="line">    dependNodeFn = om.MFnDependencyNode(locator)</span><br><span class="line">    matrixPlug = dependNodeFn.findPlug(<span class="string">&#x27;worldMatrix&#x27;</span>)  <span class="comment"># this returns mplug type attribute, we need mobject type attribute</span></span><br><span class="line">    matrixAttr = matrixPlug.attribute()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step3: connect mobject type(required) together</span></span><br><span class="line">    <span class="comment"># param: accessory node(mobject), accessory attr(mobject), deformer node(mobject: using self.thisMObject()), deformer attr(mobject)</span></span><br><span class="line">    mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;now the accessory node&#x27;s worldMatrix is driving to the custom in-matrix of the deformer node&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> mConnectStatus</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accessoryAttribute</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment"># returns the deformer node attribute connected</span></span><br><span class="line">    <span class="keyword">return</span> MyDeformer.inMatAttr</span><br></pre></td></tr></table></figure>
<p>The dagModifer is supplied in the accessory node. We use dagModifier’s connect function to connect the accessory node’s attribute to our deformer node’s attribute. In this case, we have accessory’s attribute: worldMatrix (a built-in attribute obtained from <strong>MFnDependencyNode.findPlug())</strong> and our custom defined <strong>MyDeformer.inMatAttr.</strong></p>
<p>One thing to note is that, the <strong>.connect()</strong> only takes MObject which we cannot supply MPlug type object <strong>matrixPlug = …findPlug(‘attributeName’)</strong>, we perform additional step <strong>matrixAttr = matrixPlug.attribute()</strong> to get the MObject type attribute.</p>
<p>Now we supply <strong>.connect()</strong> with parameters: accessory node (MObject type), accessory node’s attribute (MObject type), deformer node (MObject type) and deformer node’s attribute (MObject type) as follow:<strong>mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr)</strong></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-11-11</span><i class="fa fa-tag"></i><a class="tag" href="/categories/learning-log/" title="learning log">learning log </a><a class="tag" href="/tags/maya/" title="maya">maya </a><a class="tag" href="/tags/python/" title="python">python </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2019/11/11/maya-api-3/,Xingyu Lei,Maya Python API (3. Custom Deformer),;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/11/19/verlet-integration/" title="Verlet Integration">prev_post</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/11/10/maya-api-2/" title="Maya Python API (2. Custom Node)">next_post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>