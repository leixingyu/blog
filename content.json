{"meta":{"title":"Tech Art Learning","subtitle":"","description":"","author":"Xingyu Lei","url":"https://www.xingyulei.com","root":"/"},"pages":[{"title":"404 Page Not Found","date":"2022-04-10T15:19:15.970Z","updated":"2022-04-10T15:19:15.970Z","comments":false,"path":"/404.html","permalink":"https://www.xingyulei.com/404.html","excerpt":"","text":""},{"title":"Categories","date":"2022-04-10T15:19:42.148Z","updated":"2022-04-10T15:19:42.148Z","comments":false,"path":"categories/index.html","permalink":"https://www.xingyulei.com/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2022-02-20T17:44:36.144Z","updated":"2022-02-20T17:44:36.144Z","comments":false,"path":"about/index.html","permalink":"https://www.xingyulei.com/about/index.html","excerpt":"","text":"Technical Artist | PlayStation Jan 2021 - Present Research Assistant | Purdue University Sept 2018 - Dec 2020 Procedural animation system development in Unity using C# Motion capture retargeting automation Character rigging automation Character FX TD | Blur Studio May 2020 - July 2020 Refactor tools for the new CFX pipeline Create character cloth and hair simulation in Maya Character FX Intern | Blur Studio Jun 2019 - Aug 2019 Develop pipeline tools for the CFX department Create character cloth and hair simulation in Maya and 3ds Max Works Placeholder Placeholder"},{"title":"Books","date":"2022-04-10T15:41:13.790Z","updated":"2022-04-10T15:41:13.790Z","comments":false,"path":"books/index.html","permalink":"https://www.xingyulei.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.031Z","comments":true,"path":"links/index.html","permalink":"https://www.xingyulei.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-23T03:34:50.419Z","updated":"2021-02-07T16:58:04.032Z","comments":false,"path":"repository/index.html","permalink":"https://www.xingyulei.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-23T03:34:50.357Z","updated":"2021-02-07T16:58:04.032Z","comments":false,"path":"tags/index.html","permalink":"https://www.xingyulei.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Run Command Prompt and Powershell as Admin (Python)","slug":"py-admin","date":"2022-03-19T04:00:00.000Z","updated":"2022-03-20T19:26:07.465Z","comments":true,"path":"post/py-admin/","link":"","permalink":"https://www.xingyulei.com/post/py-admin/","excerpt":"","text":"Table of Contents Introduction User Account Control(UAC) Using subprocess Using ShellExecute Using runas in Command Prompt Using PowerShell -Verb Runas Redirect Output Run Python as Admin References Introduction We often find ourselves needing to automate tasks on Windows machine, Although there are many Python libraries out there that supports some common Windows operations and even cross-platforms. It is really hard to substitute Window’s Command Prompt and PowerShell, as they are extremely useful in cases where we need to access different Windows components, configure settings and troubleshooting. User Account Control (UAC) Standard user accounts are for day-to-day activities with less permission, while the administrator account has elevated access for all features. For my personal machine, I’m operating on admin account all time (as the sole user). But Windows, for security reasons, still treats most of my actions as standard account. It only elevates to admin privilege when my operations want to make internal changes to Windows settings and my machine. The UAC feature when enabled, prompts the user when such action occurred and request for admin access. Additionally, for standard user, it means they need to ask for administrator account login. When the sign in is an administrator type account When the sign in is a standard type account Now, in terms of task automation in Python, we’ll also want to figure out how to run certain operations with Admin privilege. Using subprocess Like most of us, I have been using subprocess to evoke cmd.exe or powershell.exe as desired by passing arguments as list into the function. Command Prompt: command = ['cmd.exe', '/c', &lt;argument&gt;] PowerShell: command = ['powershell.exe', '-command', &lt;argument&gt;] 12345678910import subprocessdef runCmd(*args): p = subprocess.Popen( *args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT ) out, error = p.communicate() return out, error But this doesn’t grant the process with admin privilege, and won’t notify us with UAC. How to achieve this? here are some ways to do it. Using ShellExecute runas 12345678910import ctypescommands = u&#x27;/k echo hi&#x27;ctypes.windll.shell32.ShellExecuteW( None, u&quot;runas&quot;, u&quot;cmd.exe&quot;, commands, None, 1 ) runas from the Windows API launches an application as Administrator. User Account Control (UAC) will prompt the user for consent to run the application elevated or enter the credentials of an administrator account used to run the application. What about a more pythonic approach? Using runas in Command Prompt runas application runs command as a different user; it is most commonly used but not limited to perform operation with administrator account for granting admin access. Note: the password is handled outside UAC, which may not be the desired behavior 1234command = [&#x27;cmd.exe&#x27;, &#x27;/c&#x27;, &#x27;runas&#x27;, &#x27;/user:administrator&#x27;, &#x27;regedit&#x27;]p = subprocess.Popen(command, stdin=subprocess.PIPE)p.stdin.write(&#x27;password&#x27;)p.communicate() Using PowerShell -Verb Runas This is my preferred method, since it is most flexible and also evokes UAC for admin access. Start-Process 1Start-Process &lt;executable&gt; -argumentlist &lt;arugments&gt; -Verb Runas Call operator (&amp;) with call operator, we are able to run commands not limited in the environment path, also not need to worry about spaces in our path. 1&amp; &#123;Start-Process &lt;executable&gt; -argumentlist &lt;arugments&gt; -Verb Runas&#125; -ExecutionPolicy Bypass Sometimes, a security setting will prevent PowerShell running a .ps1 file, and we’ll need to bypass execution policy: 1Start-Process &lt;executable&gt; -ExecutionPolicy Bypass -File &lt;file&gt; It is very obvious from the above example, we can basically use PowerShell to wrap around anything, including Command Prompt. 1Start-Process cmd.exe -argumentlist &#x27;/k &quot;dir&quot;&#x27; -Verb Runas To bundle everything together, a working example would look like this in Python: 123ps_command = &quot;&amp; &#123;&#123;Start-Process cmd.exe -argumentlist &#x27;/k \\&quot;dir\\&quot;&#x27; -Verb Runas&#125;&#125;&quot;command = [&#x27;powershell.exe&#x27;, &#x27;-command&#x27;, ps_command]runCmd(command) essentially using subprocess to run PowerShell in admin using -Verb Runas to execute command /k dir in Command Prompt (which also has elevated access). Redirect Output By doing the above, we are running an executable within a process. the sacrifice is that it is difficult to pass the output, but here’s a few workarounds: Output results to a file 1Start-Process cmd.exe -argumentlist &#x27;/c &quot;dir&quot;&#x27; -redirectStandardOutput &quot;C:\\Users\\xlei\\Desktop\\temp.txt&quot; Output result to the console Just the exit code: 12$output = Start-Process cmd.exe -argumentlist &#x27;/c &quot;dir&quot;&#x27; -PassThru -Wait$output.ExitCode A neat function I found here 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Start-ProcessWithOutput&#123; param ([string]$Path,[string[]]$ArgumentList) $Output = New-Object -TypeName System.Text.StringBuilder $Error = New-Object -TypeName System.Text.StringBuilder $psi = New-object System.Diagnostics.ProcessStartInfo $psi.CreateNoWindow = $true $psi.UseShellExecute = $false $psi.RedirectStandardOutput = $true $psi.RedirectStandardError = $true $psi.FileName = $Path if ($ArgumentList.Count -gt 0) &#123; $psi.Arguments = $ArgumentList &#125; $process = New-Object System.Diagnostics.Process $process.StartInfo = $psi [void]$process.Start() do &#123; if (!$process.StandardOutput.EndOfStream) &#123; [void]$Output.AppendLine($process.StandardOutput.ReadLine()) &#125; if (!$process.StandardError.EndOfStream) &#123; [void]$Error.AppendLine($process.StandardError.ReadLine()) &#125; Start-Sleep -Milliseconds 10 &#125; while (!$process.HasExited) #read remainder while (!$process.StandardOutput.EndOfStream) &#123; #write-verbose &#x27;read remaining output&#x27; [void]$Output.AppendLine($process.StandardOutput.ReadLine()) &#125; while (!$process.StandardError.EndOfStream) &#123; #write-verbose &#x27;read remaining error&#x27; [void]$Error.AppendLine($process.StandardError.ReadLine()) &#125; return @&#123;ExitCode = $process.ExitCode; Output = $Output.ToString(); Error = $Error.ToString(); ExitTime=$process.ExitTime&#125;&#125;$p = Start-ProcessWithOutput cmd.exe -argumentlist &#x27;/c &quot;dir&quot;&#x27;$p.ExitCode$p.Output$p.Error Run Python as Admin Running the whole python script in Admin, meaning that the subsequent processes will have admin access, if this is the behaviour you prefer. References Stack Exchange - Run .exe file via Python as Administrator Stack Overflow - How do I capture the output into a variable from an external process in PowerShell? Stack Overflow - Redirection of standard and error output appending to the same log file Stack Overflow - Powershell: Capturing standard out and error with Process object Windows Commandline - Windows runas command syntax and examples","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"windows","slug":"windows","permalink":"https://www.xingyulei.com/tags/windows/"}]},{"title":"IK FK Matching in Maya","slug":"maya-ik-fk-match","date":"2022-02-27T05:00:00.000Z","updated":"2022-03-12T16:36:36.536Z","comments":true,"path":"post/maya-ik-fk-match/","link":"","permalink":"https://www.xingyulei.com/post/maya-ik-fk-match/","excerpt":"","text":"Table of Contents Introduction FK Matching Script Maya Operation IK Matching Script Maya Operation Pole Vector: One Step Further Further Reading Transformation Matrix Translation Offset Rotation Offset Pre-multiplying Matrix Implementation Model Matrix Post-multiplying Matrix Decomposing Matrix Translation Scale Rotation References Introduction IK/FK matching refers to the ability to match any IK pose to FK pose and vice versa. But how does it work? I’m going to summarize the basic approaches I learned along the way. One of them is math-based, and the other being Maya operational-based, which utilizes Maya’s built-in constraint nodes, this is more straight-forward and easy as it does the calculation for you. Since we use controllers to drive joint movement in rigs, the general idea of a IK/FK matching is to reverse this process, and find the transformation of a controller based off the joint’s transformation. Note: There’s no one easy way to deal with all custom rig setups, this is due to operations like parenting, orienting joint and freezing transformation. Transformation offsets occurs between joint and controller, even in world space. I’ll cover these more complex scenarios as references here. FK Matching FK is all about matching rotation, given that FK controller constraints the corresponding joint’s orientation. Thus, in reverse, given the result joint’s transform, we should be able to find the FK controller’s rotation. And knowing how one of them works can translate to all the other joints and FKs (respectively, shoulder, elbow and wrist in arm and clavicle, knee and ankle in leg). Script obtain the world space rotation of the joint while it is still in IK mode 12# in IK moderotation = cmds.xform(jnt, ro=1, ws=1, q=1) switch to FK mode and apply the world space rotation onto the FK controller 123# in FK modedef snap_fk_to_jnt(ctrl, target_rotation): cmds.xform(ctrl, ro=target_rotation, ws=1) Maya Operation We can utilize Maya’s constraint to match rotation. Such as, in a three-chain setup, we could let IK joints to rotation constraint the FK controllers without maintaining offset. But for a single-chain setup with both FK and IK controllers sharing the joint, doing so will cause cycle evaluation. To get around this, we use a temporary empty transform node that is relatively parented under the joint. This temporary node (the match node) will be used to constraint the FK controller, and once the matching completes, we can safely delete the constraint and the match node itself. IK Matching IK Matching matches IK controller to the joint’s transform in FK mode. For IK handle, we need to match both the top joint’s (wrist or ankle) translation and rotation value; For IK pole vector, we only need to match the mid-joint’s (elbow or knee) translation. We already figured out how to acquire and match rotation in FK matching, which can be directly used in matching IK handle, so we’ll focus on how to match translation below. Script obtain the world space translation of the joint while it is still in FK mode 12# in FK modetranslation = cmds.xform(jnt, t=1, ws=1, q=1) switch to IK mode and apply the world space translation onto the IK Handle 123# in IK modedef snap_ik_to_jnt(ik, target_pos): cmds.xform(ik, t=target_pos, ws=1) Maya Operation Similar to FK matching, we create a match node that inherits the target joint’s transformation in FK mode; Then we use it to parent constraint the IK handles (position constraint the IK pole) without maintain offset. Once the IKs snaps to the target position, we then safely delete the constraint and the match node. Pole Vector: One Step Further In the example above, IK pole vector will directly snap on top of the elbow or knee joint. Doing so will achieve the IK matching effect, but we often want the pole vector to extend a little further outwards, this gives more room for animators and avoids joint flipping. To extend the pole vector outwards, we need to acquire the directional vector from mid-point of the root and top joint of the rig chain to the mid-joint. It is easier to achieve this through script: convert positional value to vector as Maya doesn’t support operation on position (represented as list[3]) 1234567root_vec = Vector3(root_pos)mid_vec = Vector3(mid_pos)top_vec = Vector3(top_pos)# alternatively, use maya&#x27;s built-in MVectorfrom maya.api import OpenMaya as omvec = om.MVector(pos[0], pos[1], pos[2]) find the mid-point between the root joint and the top joint 1mid_point = (root_vec + top_vec) * 0.5 find the directional vector from mid-point to the mid-joint 1pole_dir = mid_pos - mid_point the pole vector’s target position can be found by extending this directional vector beyond the mid-joint position with an arbitrary multiplier 1pole_pos = mid_pos + (pole_dir * multiplier) Further Reading The above matching logics aren’t bulletproof. What???!! Yeah, because not long after releasing my Snap tool, Squirrel Daph found the tool not behaving correctly and kindly sent me the rig for further testing. After some troubleshooting, I found that because I built the tool around my auto-generated rig, so there are many things I didn’t account for. The following sections aim to overcome some of my Snap tool’s previous limitations. Transformation Matrix Transformation matrix are commonly used in Computer Graphics, it can be used to represent an object’s transformation in 3D world; It is an extremely useful knowledge to have in terms of rigging. Maya has many built-in ways get the matrix representation of a node’s transformation. 1234def get_matrix(node, is_world=1): return om.MMatrix( cmds.xform(node, q=1, matrix=1, ws=is_world, os=not is_world) ) Converting the Maya matrix representation MMatrix to MTransformationMatrix, gives access to more built-in functions including decomposition. 1mxform_matrix = om.MTransformationMatrix(mmatrix) Or construct by using function set MFnTransform: 123456789def get_transform_matrix(dag_node): &quot;&quot;&quot; Get the local transformation matrix of a given dag node :param dag_node: om.MObject. input maya dag node :return: om.MTransformationMatrix. local transformation matrix &quot;&quot;&quot; fn_transform = om.MFnTransform(dag_node) return fn_transform.transformation() The differences between om.MMatrix and om.MTransformationMatrix: om.MMatrix constructed by cmds.xform has access to both local and world transformation matrix, but unable to track rotation greater than 360 degrees. om.MTransformationMatrix using MFnTransform only gets local transformation matrix, but it stores rotation information greater than 360 degrees. Translation Offset When there’s world space offset between IK controller and joint, we would want to account for the offset when calculating the IK result position. 12345jnt_pos = Vector(cmds.xform(jnt, ws=1, q=1, t=1))ik_pos = Vector(cmds.xform(ik, ws=1, q=1, t=1))offset = jnt_pos - ik_posik_target_pos = jnt_target_pos - offset Rotation Offset Rotational offset can be caused by axis in-alignment during constraints, we’ll need to use matrix multiplication to find it instead of simple vector math. Example of rotation offset between joint and controller Pre-multiplying Matrix Important: the order of matrix multiplication matters to get a unit matrix, instead of dividing matrix, we multiply its inverse matrix Joint transformation is the result of controller constraints, in which the constraint matrix serves as a pre-multiplication matrix. Mjoint=Mconst∗MctrlM_{joint} = M_{const} * M_{ctrl} Mjoint​=Mconst​∗Mctrl​ We are then able to get the constraint matrix by post-multiplying the inverse of controller matrix. Mjoint∗Mctrl−1=Mconst∗Mctrl∗Mctrl−1{M_{joint}} * M_{ctrl}^{-1} = M_{const} * M_{ctrl} * M_{ctrl}^{-1} Mjoint​∗Mctrl−1​=Mconst​∗Mctrl​∗Mctrl−1​ Mconst=Mjoint∗Mctrl−1M_{const} = {M_{joint}} * M_{ctrl}^{-1} Mconst​=Mjoint​∗Mctrl−1​ In the function below, the result matrix argument would be the joint matrix, and source matrix argument would be the controller matrix. 123456789def get_pre_mult_matrix(result_mat, source_mat): &quot;&quot;&quot; Get pre-multiplying matrix :param result_mat: om.MMatrix. the result matrix after multiplication :param source_mat: om.MMatrix. the source matrix used in pre multiplying :return: om.MMatrix. matrix used in pre multiplication &quot;&quot;&quot; return result_mat * source_mat.inverse() Similar process, we are able to find the target controller’s transform based off the rotational offset and the target joint transform. Mctrl=Mconst−1∗MjointM_{ctrl} = M_{const}^{-1} * {M_{joint}} Mctrl​=Mconst−1​∗Mjoint​ Implementation Bringing this back to the context of our IK matching process: We know the current controller rotation and current joint rotation, this will give us the constraint matrix (rotational offset), We also know the target joint rotation in world space, Therefore, we can convert this target joint rotation to target controller rotation in world space. Now through script: 123456789# step 1: obtain the constraint matrixcurrent_jnt_rot = matrix.get_matrix(jnt)current_fk_rot = matrix.get_matrix(fk)cons_mat = matrix.get_pre_mult_matrix(current_jnt_rot, current_fk_rot)# step 2: get controller&#x27;s target matrix target_ctrl_mat = om.MTransformationMatrix( cons_mat.inverse() * target_jnt_mat) We can later extract the rotation data from the transformation matrix. Model Matrix Model matrix converts transformation matrix from world space to object space, this has no direct usage in the IK/FK matching, as cmds.xform() already does the work for us. But it’s good to cover as it is very relevant. Post-multiplying Matrix Model matrix is a post-multiplying matrix: Mworld=Mlocal∗MmodelM_{world} = M_{local} * M_{model} Mworld​=Mlocal​∗Mmodel​ We now pre-multiply the inverse of the local transform matrix: Mlocal−1∗Mworld=Mlocal−1∗Mlocal∗MmodelM_{local}^{-1} * M_{world} = M_{local}^{-1} * M_{local} * M_{model} Mlocal−1​∗Mworld​=Mlocal−1​∗Mlocal​∗Mmodel​ Mmodel=Mlocal−1∗MworldM_{model} = M_{local}^{-1} *{M_{world}} Mmodel​=Mlocal−1​∗Mworld​ So similarly we can create the following function, with the result matrix argument being the world transform matrix, and source matrix argument being the local transform matrix. 123456789def get_post_mult_matrix(result_mat, source_mat): &quot;&quot;&quot; Get post multiplying matrix :param result_mat: om.MMatrix. the result matrix after multiplication :param source_mat: om.MMatrix. the source matrix used in post multiplying :return: om.MMatrix. matrix used in post multiplication &quot;&quot;&quot; return source_mat.inverse() * result_mat Decomposing Matrix Decomposing a transformation matrix (om.MTransformationMatrix) refers to acquiring translation, rotation and scale values as individual list[3] type. These values can now be applied using cmds.xform() either in local space or in world space depending on the input transformation matrix. Translation 1translation = matrix.translation(om.MSpace.kWorld) Scale 1scale = matrix.scale(om.MSpace.kWorld) Rotation Extract rotation in axis angles in default xyz rotation order. 1234import mathrot_vec = matrix.rotation().asVector()rotation = [math.degrees(angle) for angle in (rot_vec.x, rot_vec.y, rot_vec.z)] References Tech Artists Org - Convert world space coordinates to object space coordinates in Maya? Stack Exchange - Given this transformation matrix, how do I decompose it into translation, rotation and scale matrices? AK Eric - Find Euler rotation values of Maya matrix Maya Help - MFnTransform Class Reference Maya Help - MMatrix Class Reference Maya Help - MTransformationMatrix Class Reference","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"}]},{"title":"Using namedtuple","slug":"py-named-tuple","date":"2022-01-23T05:00:00.000Z","updated":"2022-02-21T22:32:26.358Z","comments":true,"path":"post/py-named-tuple/","link":"","permalink":"https://www.xingyulei.com/post/py-named-tuple/","excerpt":"","text":"Table of Contents Mutable and Hashable hash() and id() Why hash? Example NamedTuple Initialization Access and Edit Value Using _asdict() @dataclass Frozen Attribute Override __iter__() Subclassing namedtuple __new__() Constructor _slots_ Comparison between _dict_ and _slots_ I recently got side-tracked into exploring the basics of namedtuple() as I got a glimpse of its usage in our engineering codebase. Here’s my summary: Mutable and Hashable To understand the behavior of namedtuple(), it is best to also visit the concept of Python object’s mutability and hashability. These two concepts are closely linked. Hashability: an object’s is hashable when its hash value never changed during its lifetime Most of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable. Objects which are instances of user-defined classes are hashable by default Mutability: an object with a fixed value and cannot be altered is immutable (For example: int, float, string, tuple). in contrast, an object can keep its value while keeping its id() is mutable. (For example: list, dict) hash() and id() identity: id(), the identity of the two same value variables are the same If two objects (that exist at the same time) have the same identity, they’re actually two references to the same object. The is operator compares items by identity, a is b is equivalent to id(a) == id(b). hash value: hash(), hash value is based off an object’s value, and hash value must remain the same for the lifetime of the object. If an object is mutable, then it doesn’t make sense for it to have hash. The hash value is an integer which is used to quickly compare dictionary keys or sets. Why Hash? Hash values are very useful, as they enable quick look-up of values in a large collection of values, it’s commonly used in set and dict. with if x in elements:: In a list, Python needs to go through the whole list and compare x's value with each value in the list elements. In a set, Python keeps track of each element’s hash, Python will get the hash-value for x, look that up in an internal structure and find elements that have the same hash as x. It also means you can have non-hashable objects in a list, but not in a set or as keys in a dict. Example: There is no way to change an int object’s value without re-assigning (copy) it to a different object. 1234x = 5# id(x) is equal to 3054677212104x = 6# id(x) is equal to 3054677212080 But for list, you can edit its value after assignment while keeping its id() the same. (note: use list built-in function rather than re-assignment, this is the same for x.sort vs. x=sorted(x)) 123456x = [5]# ORIGINAL: id(x) is equal to 3054706521672x.append(6)# CORRECT: id(x) is equal to 3054706521672x = [5, 6]# WRONG: id(x) is equal to 3054713375816 NamedTuple A data class are just regular classes that are geared towards storing state, rather than containing a lot of logic, namedtuple() is one kind of data classes. Every time you create a class that mostly consists of attributes, you make a data class. With namedtuple(), you can create immutable sequence types that allow you to access their values using descriptive field names and the dot notation instead of unclear integer indices. Initialization typename: str, class name of the namedtuple field names: names that are used to access values in the namedtuple, it can be declared using any of the following: iterable of strings: [“a”, “b”, “c”] a string with name seperated by white spaces: “a b c” a string with name separated by commas: “a, b, c” Example: 12345678from collections import namedtuplePoint = namedtuple(&quot;Point&quot;, [&quot;x&quot;, &quot;y&quot;])&gt;&gt; Point# &lt;class &#x27;__main__.Point&#x27;&gt;&gt;&gt; Point(2, 4)# Point(x=2, y=4) Access and Edit Value It is very straight-forward to access a tuple’s attribute value using dot notation this gives namedtuple a great edge against dict or tuple. 12345Person = namedtuple(&#x27;Person&#x27;, &#x27;name children&#x27;)jj = Person(&#x27;Johnny J&#x27;, [&#x27;Tobby&#x27;])&gt;&gt; jj.children# [&#x27;Tobby&#x27;] Since namedtuple is immutable, you can’t assign value to its attribute; what you can do is to use ._replace(); and also, its value can be mutable, like a list. 12345678&gt;&gt; jj.children = [&#x27;Tobby&#x27;, &#x27;Wang&#x27;]# AttributeError: can&#x27;t set attribute&gt;&gt; jj.children.append(&#x27;Wang&#x27;)# Correct&gt;&gt; jj = jj._replace(name=&#x27;John J&#x27;)# Correct Using ._asdict() The built-in function ._asdict() converts namedtuple into a dictionary. 12345Person = namedtuple(&quot;Person&quot;, &quot;name age height&quot;)jane = Person(&quot;Jane&quot;, 25, 1.75)&gt;&gt; jane._asdict()# &#123;&#x27;name&#x27;: &#x27;Jane&#x27;, &#x27;age&#x27;: 25, &#x27;height&#x27;: 1.75&#125; @dataclass @dataclass came out after Python 3.7, which is similar to namedtuple, but they are mutable. thus, we can set value to a @dataclass attribute. 12345678910111213from dataclasses import dataclass@dataclassclass Person: name: str age: int country: str = &quot;Canada&quot;jane = Person(&quot;Jane&quot;, 25)&gt;&gt; jane.name = &quot;Jane Doe&quot;&gt;&gt; jane.name&#x27;Jane Doe&#x27; frozen attribute if we want @dataclass to behave like namedtuple with an un-editable “protected” attribute, just use @dataclass(frozen=True). override __iter__() @dataclass are also not iterable by default, unlike namedtuple. We can achieve that by implementing the special method .__iter__(): 1234567from dataclasses import astuple, dataclass@dataclassclass Person: ... def __iter__(self): return iter(astuple(self)) Subclassing namedtuple Subclassing namedtuple gives us additional functionality. 123456789101112BasePerson = namedtuple(&quot;BasePerson&quot;, &quot;name birthdate country&quot;)class Person(BasePerson): &quot;&quot;&quot;A namedtuple subclass to hold a person&#x27;s data.&quot;&quot;&quot; __slots__ = () def __repr__(self): return &quot;Name: &#123;&#125;, age: &#123;&#125; years old&quot;.format(self.name, self.age) @property def age(self): return (date.today() - self.birthdate).days // 365 In the above example, subclassing from namedtuple provides us better documentation (i.e. Person.__doc__), better string representation (i.e. print jane) and an extra property to access based off a Person’s instance attribute value. __new__() constructor Zechong Hu’s Blog - Inheritance for Python Namedtuples To override the constructor for namedtuple class with default value: 123456BasePerson = namedtuple(&quot;BasePerson&quot;, [&quot;name&quot;, &quot;birthdate&quot; ,&quot;country&quot;])class Person(BasePerson): __slots__ = () def __new__(cls, name, birthdate=&quot;2000.01.01&quot;, country=None): return super(Person, cls).__new__(cls, name, birthdate, country) __slots__ The special attribute __slots__ explicitly state what attribute you want your class instances to have. By default, when an instance (object) is created, __dict__ is used to store an object’s (writable) attributes. A dynamic dictionary: requires more memory takes longer time to create. Because namedtuple makes immutable instances that are lightweight, we need to prevent the creation of __dict__ to get the benefit while subclassing by setting __slots__ as empty tuple. In a more general note, please consider using __slots__ when creating tons of objects, this saves memory and time when instancing. Comparison __dict__ vs. __slots__ 123456789class Person(object): def __init__(self, name, age): self.name = name self.age = agejohn = Person(&#x27;john&#x27;, 15)&gt;&gt; john.__dict__# &#123;&#x27;age&#x27;: 15, &#x27;name&#x27;: &#x27;john&#x27;&#125; 123456789101112class Person(object): __slots__ = [&#x27;name&#x27;, &#x27;age&#x27;] def __init__(self, name, age): self.name = name self.age = agejohn = Person(&#x27;john&#x27;, 15)&gt;&gt; john.__slots__# [&#x27;name&#x27;, &#x27;age&#x27;]&gt;&gt; john.__dict__# AttributeError: &#x27;Person&#x27; object has no attribute &#x27;__dict__&#x27; Reference Python Docs - Glossary Medium megha mohan - Mutable vs Immutable Objects in Python Real Python - namedtuple Stack Overflow - What are data classes and how are they different from common classes? Geeks for Geesk - Use of __slots__ Stack Overflow - Usage of __slots__? Stack Overflow - Difference between hash() and id() Stack Overflow - Two variables in Python have same id, but not lists or tuples Stack Overflow - What does hash do in python?","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"style","slug":"style","permalink":"https://www.xingyulei.com/tags/style/"}]},{"title":"Communicate with Maya (2. Streaming Output)","slug":"maya-streaming","date":"2022-01-09T05:00:00.000Z","updated":"2022-03-06T16:46:05.608Z","comments":true,"path":"post/maya-streaming/","link":"","permalink":"https://www.xingyulei.com/post/maya-streaming/","excerpt":"","text":"Maya Connector I’ve combined the two parts together and created the end result: Maya Connector tool. The tool will utilize command port to send open streaming command, which establishes the connection and enables the callback. The output is being sent back to the tool and the output is updated in the GUI. Introduction Make sure to see Part 1 for more context in socket programming and maya command port Like mentioned in the previous blog, this chapter is independent for enabling output streaming, but would work even better with command port to send command and get active response from Maya. This kind of log streaming feature can be helpful not only for monitoring but for catching errors like when Maya crashes, or to connect with an IDE similar to PyCharm’s plugin MayaCharm and Sublime’s plugin MayaSublime Listening Server Separation I’ve been looking at Maya’s command port to see if the return message would be sufficient for debugging log, as command port already is a server. But it turns out that this approach is not recommended by many, as there’s little control on the return message as the TCP communication returns one message per command, more explained in the previous blog. The correct way suggested, and widely used is to stream Maya script output back to the external application. As shown in the graph, two separate communications are established instead of utilizing just the command port. external application (client) send command to Maya’s command port (server) where Maya would process normally. This is achieved through TCP to ensure no loss in sending command. Maya’s MCommandMessage callback triggers (client) send the latest output result to external application’s listening port (server). This is achieved through UDP to keep the connection fast and easy, but may result in lost in feedbacks (which isn’t that important) Procedures to establish listening server, need to use a different port number than the command port number if we are also connecting to it. 12345678910111213141516import socketSERVER = &#x27;127.0.0.1&#x27;PORT = 5051ADDR = (SERVER, PORT)server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)server.bind(ADDR)while True: data = server.recvfrom(1024) message = data[0] address = data[1] print(message) On the maya client side, there are two parts: setup MCommendMessage callback stream the data to the listening server 123456789101112131415161718192021222324252627import socketimport maya.OpenMaya as omSERVER = &#x27;127.0.0.1&#x27;PORT = 5051if &#x27;STREAM_CALLBACK&#x27; in globals(): try: om.MMessage.removeCallback(STREAM_CALLBACK) except RuntimeError: passSTREAM_CALLBACK = Nonedef openStream(addr=(SERVER, PORT)): global STREAM_CALLBACK print(&quot;Enable Streaming ScriptEditor at (&#123;&#125;:&#123;&#125;)\\n&quot;.format(addr[0], addr[1])) STREAM_CALLBACK = om.MCommandMessage.addCommandOutputCallback(streamToConsole, addr)def closeStream(): global STREAM_CALLBACK print(&quot;Disable Streaming ScriptEditor\\n&quot;) om.MMessage.removeCallback(STREAM_CALLBACK) STREAM_CALLBACK = None borrowed some code from MayaSublime for stringIO 1234567891011121314151617181920212223242526272829303132def streamToConsole(msg, mtype, addr): buf = StringIO() buf.seek(0) buf.truncate() buf.write(msg) buf.seek(0) # start with trying to send 8kb packets bufsize = 8*1024 # loop until the buffer is empty while True: while bufsize &gt; 0: # save our position in case we error and need to roll back pos = buf.tell() part = buf.read(bufsize) if not part: # buffer is empty. Nothing else to send return try: client.sendto(part, addr) except Exception as e: if e.errno == errno.EMSGSIZE: # we have hit a message size limit. # scale down and try the packet again bufsize /= 2 buf.seek(pos) continue # some other error raise # message sent without error break Message Type Command message type support: 1234567891011121314if mtype == om.MCommandMessage.kWarning: buf.write(&#x27;# Warning: &#x27;) buf.write(msg) buf.write(&#x27; #\\n&#x27;)elif mtype == om.MCommandMessage.kError: buf.write(&#x27;// Error: &#x27;) buf.write(msg) buf.write(&#x27; //\\n&#x27;)elif mtype == om.MCommandMessage.kResult: buf.write(&#x27;# Result: &#x27;) buf.write(msg) buf.write(&#x27; #\\n&#x27;)else: buf.write(msg) Logging GUI Like a logger, instead of sending output string to standard output, I created a QPlainTextEdit and use insertPlainText(string) to display it. We opened a thread to receive data, so that we still have control over the main tool, and can send command to maya if wanted. Note: we shouldn’t update the GUI in the listening thread, instead we emit a custom signal and pass the return message as argument, we then create a custom slot to handle GUI update. so instead of doing: 1234while True: data = server.recvfrom(1024) message = data[0] self.ui_text_edit.insertPlainText(message) we should be doing: 1234while True: data = server.recvfrom(1024) message = data[0] self.message_received.emit(message) Clean up During application close, we need to do the following clean up: send command to Maya to remove the callback close the tool’s UDP listening server end the thread to the listening server References Maya Help - OpenMaya.MCommandMessage Class Reference Google Groups - Extracting data from Output Window Github - MayaCharm Github - MayaSublime","categories":[{"name":"maya communication","slug":"maya-communication","permalink":"https://www.xingyulei.com/categories/maya-communication/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"},{"name":"socket","slug":"socket","permalink":"https://www.xingyulei.com/tags/socket/"},{"name":"threading","slug":"threading","permalink":"https://www.xingyulei.com/tags/threading/"}]},{"title":"Communicate with Maya (1. Command Port)","slug":"maya-commandport","date":"2021-12-17T05:00:00.000Z","updated":"2022-03-06T16:46:27.196Z","comments":true,"path":"post/maya-commandport/","link":"","permalink":"https://www.xingyulei.com/post/maya-commandport/","excerpt":"","text":"Maya Connector The end result of this two-part blog is the Maya Connector tool. This external standalone tool is able to send command to maya and receive real-time feedback from maya’s script editor output. Introduction If you are already familiar with maya command port and socket programming, skip to Part 2 for Maya output streaming. Although there are a lot of tools that can run internally in Maya which facilitate the pipeline. The capability of communicating (monitor and control) with Maya externally is very handy. Why? we sometime don’t need to interact with Maya GUI directly or have way too many maya instances to manage. examples are: sending cross-application remote command to active maya sessions or syncing between different maya sessions batch processing on either maya standalone sessions or active maya sessions This requires two components which I will be covering: command port: sending commands to maya to execute output streaming: actively listening/receiving maya outputs (next blog) These two parts can work independently, but are powerful as a whole. Also, references in creating maya standalone sessions Using cmds.commandPort() cmds.commandPort(): The command port comprises a socket to which a client program may connect Traditional socket connection provides the basic communication between client and server. But Maya’s built-in command port provides us a very convenient way of sending command for maya to execute. Procedures Open command port The port needs to be opened on Maya’s (server) end first in order for client to send command; ideally this would be achieved by adding a cmds.commandPort() open during Maya startup. 1234import maya.cmds as cmdsport = 5050if not cmds.commandPort(&quot;:&#123;&#125;&quot;.format(port), query=True): cmds.commandPort(name=&quot;:&#123;&#125;&quot;.format(port)) Send command through an external application the command sent can be either MEL or Python command which must be specified during the opening the port determined by sourceType flag 123456789101112131415import socket# the local hostHOST = &#x27;127.0.0.1&#x27; PORT = 5050ADDR = (HOST, PORT)def sendCommand(): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect(ADDR) command = &#x27;polyCube()&#x27; client.send(command) client.close() TCP Return Message We are using TCP for our communication protocol to guarantee command being sent when the connection is established successfully. Important: At this point, we are not attempting to use client.recv(xxx) for data returning from Maya, unless it’s a super simple single statement. Trying to use client.recv(xxx) will result in either None data returned or single return as it is the behaviour of TCP. See here Also sending command line by line is not reliable as there are no context between lines for Maya server to understand. Unless it’s super simple series of commands In order to receive output, we need a custom listening server to do that which is explained in Part 2. SourceType We are opening a default command port which takes MEL input, we don’t need to specify Python as source type, as we can just use python(&quot;[insert command here]&quot;) to wrap it into MEL, this can be blocks of independent codes or importing and executing python files. Mixed Quotation symbol Note that when doing a source type conversion with a string type command , quotation symbol may cause conflicts. the solution is to replace it with backslash before quotation symbol. 1command = &#x27;python(&quot;&#x27; + command.replace(r&#x27;&quot;&#x27;, r&#x27;\\&quot;&#x27;) + &#x27;&quot;)&#x27; Socket Programming Introduction It is also very helpful to know the basics of socket programming in Python to better understand how server and client communicates, and the difference between TCP and UDP, which will be used in the next part. This tutorial is very handy, and the following are a basic template for setting up client and server using socket and thread Reference Google Group - Receiving data from commandPort Stack Overflow - c socket programming, only receiving one line at a time CG Talk - Telnet or Socket: no result back from Maya Youtube - Python Socket Programming Tutorial","categories":[{"name":"maya communication","slug":"maya-communication","permalink":"https://www.xingyulei.com/categories/maya-communication/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"},{"name":"socket","slug":"socket","permalink":"https://www.xingyulei.com/tags/socket/"},{"name":"command port","slug":"command-port","permalink":"https://www.xingyulei.com/tags/command-port/"}]},{"title":"QEnum vs. QFlags","slug":"qt-enum-flag","date":"2021-12-06T05:00:00.000Z","updated":"2022-02-21T22:28:46.269Z","comments":true,"path":"post/qt-enum-flag/","link":"","permalink":"https://www.xingyulei.com/post/qt-enum-flag/","excerpt":"","text":"Introduction I often take Qt namespace for granted, it became a natural habit of setting a Qt parameter using Qt namespace, for instance: setting alignment for a QStandardItem 123item = QtGui.QStandardItem(&#x27;test&#x27;)item.setTextAlignment(QtCore.Qt.AlignRight)type(QtCore.Qt.AlignRight) Here, the Qt.AlignRight is an AlignmentFlag Enum type object which has a value of 0x0002 or 2, which creates the behavior of aligning with the right edge. Now, let’s try parsing the alignment of the QStandardItem again, using: 12align = item.textAlignment()type(align) this returns a PyQt5.QtCore.Alignment object, which we don’t really know the value of. And also note that it is not a AlignmentFlag object like previously. So, What’s the difference between these two, and how should I retrieve the namespace value? QEnum and QFlags QFlags is used to store combinations of Enum, which provides type checking safety. thus, Alignment QFlags type is simply a typedef for AlignmentFlag QEnum. Qt.AlignmentFlag is QEnum type; AlignmentFlag being the enum name Qt.Alignment is QFlags type; Alignment being the type name there’s also non-flag enums, which have the same type and enum name Example Declaration of both object types 12345678# &lt;class &#x27;PyQt5.QtCore.AlignmentFlag&#x27;&gt;align_flag = QtCore.Qt.AlignRightalign_flag_value = 2# &lt;class &#x27;PyQt5.QtCore.Alignment&#x27;&gt;align = QtCore.Qt.Alignment(align_flag)# or &lt;class &#x27;int&#x27;&gt;align = QtCore.Qt.Alignment(align_flag_value) As you can see, setAlignment() takes a Qt.Alignment parameter, which means that any combination of Qt.AlignmentFlag values, or int, is legal. 123456789item = QtGui.QStandardItem(&#x27;test&#x27;)# Alignment type is compatible with either int or AlignmentFlag(Enum)# &lt;class &#x27;PyQt5.QtCore.AlignmentFlag&#x27;&gt;item.setTextAlignment(QtCore.Qt.AlignRight)# or &lt;class &#x27;PyQt5.QtCore.Alignment&#x27;&gt;item.setTextAlignment(align)# or &lt;class &#x27;int&#x27;&gt;item.setTextAlignment(2) The return value is QFlags type, but it can be cast to an integer type to reveal its Enum value 12345# &lt;class &#x27;PyQt5.QtCore.Alignment&#x27;&gt;align = pathItem.textAlignment()# to get the Alignment value, convert the QFlags to intint(align) Parse Namespace and Value Mapping Still not sure what the Enum value means? you can either check the docs, or use this to print out a mapping of the namespace and its corresponding value 12345678910111213def enum_mapping(cls, enum): mapping = dict() for key in dir(cls): value = getattr(cls, key) if isinstance(value, enum): mapping[key] = value return mappingenum = enum_mapping(QtCore.Qt, QtCore.Qt.AlignmentFlag)# enum = enum_mapping(QtWidgets, QtWidgets.QStyle)for item in sorted(enum.items(), key=str): print(&#x27;%s: %s&#x27; % item) Reference GitHub - qutebrowser Qt Doc - QFlags Class Reference Qt Doc - QEnum/QFlag","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Find PID and End Process in Windows (Python)","slug":"py-end-process","date":"2021-10-25T04:00:00.000Z","updated":"2022-03-20T19:21:21.909Z","comments":true,"path":"post/py-end-process/","link":"","permalink":"https://www.xingyulei.com/post/py-end-process/","excerpt":"","text":"Table of Contents Introduction Main Body Bare Minimum Using os.system Using subprocess Using psutil Bonus Find Open Port Find Window Title Introduction Interacting with Windows shell to end process is very common, there are many ways to do so, like through the traditional batch script but to gain more flexibility, using python is probably a better idea. os.system is not the most elegant way to use, and it is meant to be replaced by subprocess subprocess comes with Python standard library and allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes psutil (python system and process utilities) is a cross-platform library for retrieving information on running processes and system utilization. However, it is a third-party library Bare Minimum the bare minimum command to kill process utilizes window’s taskkill; which doesn’t matter if you use os.system or subprocess 1234567import osPROCESS = &#x27;notepad.exe&#x27;STATUS = &#x27;running&#x27; # running or not respondingCMD = r&#x27;taskkill /fi &quot;IMAGENAME eq &#123;&#125;&quot; /fi &quot;STATUS eq &#123;&#125;&quot; &#x27;.format(PROCESS, STATUS)os.system(CMD) Using os.system Now consider a more flexible case where you want to gather information about the processes like its PID, and then proceed on ending the process. One of the downside of window shell command is that the output can’t be passed on to other command, the output is just text. Therefore, we output the text to a csv file which we will later process. 12345678910111213141516171819202122232425import csvimport osimport signalimport subprocessPROCESS = &#x27;notepad.exe&#x27;STATUS = &#x27;running&#x27; # running or not respondingTMP = r&#x27;&#123;&#125;/Desktop/tmp.txt&#x27;.format(os.environ[&#x27;userprofile&#x27;])CMD = r&#x27;tasklist /fi &quot;IMAGENAME eq &#123;&#125;&quot; /fi &quot;STATUS eq &#123;&#125;&quot; /fo &quot;csv&quot; &gt; &quot;&#123;&#125;&quot;&#x27;.format(PROCESS, STATUS, TMP)# output as csv formatos.system(CMD)with open(TMP, &#x27;r&#x27;) as temp: reader = csv.reader(temp) header = next(reader) pids = [int(row[1]) for row in reader]# kill processfor pid in pids: os.kill(pid, signal.SIGTERM) # or signal.SIGKILL print(&#x27;killed process with pid: &#123;&#125;&#x27;.format(pid))if os.path.exists(TMP): os.remove(TMP) Using subprocess With subprocess, we no longer need to create a temp file to store the output. Using psutil 1234567891011121314151617import psutilPROGRAM = r&#x27;maya.exe&#x27;def findProcess(name): procs = list() #Iterate over the all the running process for proc in psutil.process_iter(): try: if proc.name() == name and proc.status() == psutil.STATUS_RUNNING: pid = proc.pid procs.append(pid) except: pass return procsprocesses = findProcess(PROGRAM) we can find process start time by using 12import timestartTime = time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;, time.localtime(proc.create_time())) to kill process, either kill() or terminate() will work respectfully, SIGKILL or SIGTERM 1234p = psutil.Process(PID)p.terminate()p.kill()p.wait Bonus: Find Open Port (for socket connection) 123456process = psutil.Process(pid=PID)connections = process.connections(kind=&#x27;tcp4&#x27;)for c in [x for x in connections if x.status == psutil.CONN_LISTEN]: # gets the port number print(&#x27;port opened: &#123;&#125;&#x27;.format(c.laddr[-1])) Bonus: Find Main Window Title ctypes is a foreign function library for python, resulting a not-pythonic function Reference Microsoft Doc - tasklist ThisPointer - Python : Check if a process is running by name and find it’s Process ID (PID) Johannes Sasongko - Win32 Python: Getting all window titles Stack Overflow - Obtain Active window using Python Microsoft Docs - winuser.h header","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"windows","slug":"windows","permalink":"https://www.xingyulei.com/tags/windows/"}]},{"title":"State Machine in Unity Scripting API","slug":"unity-api-statemachine","date":"2021-08-29T04:00:00.000Z","updated":"2021-12-18T20:55:45.530Z","comments":true,"path":"post/unity-api-statemachine/","link":"","permalink":"https://www.xingyulei.com/post/unity-api-statemachine/","excerpt":"","text":"Introduction This post is not about state machine basic, rather how we would setup/access state machine parameters. There is a higher level Animator class to access a part of the animator features, but we need to use Unity’s Animations package in order to dive deeper. 1using UnityEditor.Animations; There’s a lot of parts composing Unity’s Animator: Layer, Parameter, State machine (and everything inside it including states of different kind, transition between states), there are of course multiple parameters inside a single state. The examples in this post is only about accessing states and state machines, as the rest is translatable. We start from the root: Base layer, if you think about it, a layer is essentially a state machine. Inside this root state machine are sets of states (including blend tree/state/sub-state machine) 12// getting the base layer state machineAnimatorStateMachine rootStateMachine = controller.layers[0].stateMachine; (Base Layer) Next up, a very confusing part of the scripting process are the definition of AnimatorStateMachine vs. ChildAnimatorStateMachine and AnimatorState vs. ChildAnimatorState. I really wish Unity provides internal ways to cast these to each other. To summarize: ChildAnimatorStateMachine[] and ChildAnimatorState[] is used in conjunction with Arrays as AnimatorStateMachine.states and AnimatorStateMachine.stateMachines will return the previous mentioned type. Instead of casting, they have an internal property ChildAnimatorStateMachine.stateMachine and ChildAnimatorState.state which respectively returns AnimatorStateMachine and AnimatorState type object States All states (state or. state with blendtree inside) 1234567891011121314151617181920212223ChildAnimatorState[] childStates = rootStateMachine.states;foreach(var childState in childStates)&#123; AnimatorState state = childState.state; print(state.name); // state with blendtree try &#123; var blendTree = (BlendTree)state.motion; foreach (var child in blendTree.children) &#123; print(&quot;\\t&quot; + child.motion.name); &#125; &#125; // simple state catch &#123; print(&quot;\\t&quot; + state.motion.name); &#125;&#125; (Simple state only contains a single clip) (BlendTree nested in a state) Sub-state machine 12345678910111213141516ChildAnimatorStateMachine[] childSubStateMachines = rootStateMachine.stateMachines;foreach(var childSubStateMachine in childSubStateMachines)&#123; // Convert `ChildAnimatorStateMachine` to `AnimatorStateMachine` AnimatorStateMachine subStateMachine = childSubStateMachine.stateMachine; print(subStateMachine.name); // all states in idle sub state machine ChildAnimatorState[] states = subStateMachine.states; foreach (var childState in states) &#123; print(&quot;\\t&quot; + childState.state.name); &#125;&#125; (Essentially, another sub layer of state machine) Reference Unity Manual - State Machine Basics Unity Scripting API - AnimatorStateMachine Unity Scripting API - Animator.Play","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://www.xingyulei.com/tags/unity/"},{"name":"c#","slug":"c","permalink":"https://www.xingyulei.com/tags/c/"}]},{"title":"How to Resize QPixmap","slug":"qt-pixmap-scale","date":"2021-08-22T04:00:00.000Z","updated":"2022-03-05T02:16:36.024Z","comments":true,"path":"post/qt-pixmap-scale/","link":"","permalink":"https://www.xingyulei.com/post/qt-pixmap-scale/","excerpt":"","text":"Intro During my attempts to create custom alignment push buttons, I encountered an issue with icon having jagged looking (even if with low resolution). I use a custom paintEvent() drawing QPixmap, and this happens when I use scaled() to resize my pixmap. I noticed the icon does not have the jagged look with the built-in setIcon() and setIconSize in QPushButton. So I know there’s some wrong with my approach. The Test To really show out the difference, I first reduce the resolution of my image. 12345low_rez = QtCore.QSize(40, 40)high_rez = QtCore.QSize(400, 400)pixmap = QtGui.QPixmap(path)pixmap = pixmap.scaled(low_rez) I then increase the resolution back to normal. The default scale uses FastTransformation 1pixmap = pixmap.scaled(high_rez) This is the result: The Solution I’ve searched many forums and people were all saying: enable the SmoothTransformation, I tried but didn’t work. Later on I found out that the Qt translation to Python has a mis-match keyword argument: so instead of transformMode=Qt.SmoothTransformation, it should actually be mode=Qt.SmoothTransformation So here’s the solution: 12345pixmap = pixmap.scaled( high_rez, aspectRatioMode=QtCore.Qt.KeepAspectRatio, mode=QtCore.Qt.SmoothTransformation) and result: Extra I also found post saying it might be some settings with the QPainter, but it is not the issue for me. 1234painter = QtGui.QPainter(self)painter.setRenderHint(QtGui.QPainter.Antialiasing, True)painter.setRenderHint(QtGui.QPainter.SmoothPixmapTransform, True)painter.drawPixmap(self.pixmap) Reference Qt Documentation - QPixmap Class","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Qt Left-align Icon, Center-align Text in Python","slug":"qt-button-alignment","date":"2021-08-21T04:00:00.000Z","updated":"2022-03-05T02:12:57.701Z","comments":true,"path":"post/qt-button-alignment/","link":"","permalink":"https://www.xingyulei.com/post/qt-button-alignment/","excerpt":"","text":"Introduction I recently needed to display a series of buttons for my shelf tool, the problem I’m having with this is that although every button has an icon and text label, they are displayed as different width. Using center-align made it look not uniform. Should I go with left-align? Well, there are buttons with relatively longer label and some with shorter ones, so it doesn’t look nice either with empty spaces on the right side. So the solution is obvious, separate the alignment of the icon and the label: the icon stays left-align to give a clear sign of broader, and the label would be center-align to make the width look uniform. (Left: default center align, Center: left align, Right: custom align) In the following section, I will demonstrate three methods of achieving this custom alignment effect: Overriding QPushButton paintEvent() This method subclass from QPushButton and override the paintEvent() and sizeHint() to extend how a button is drawn; The alignment of content of the button is default to center-aligned, but we make the pixmap to be drawn on the left-side (5px margin against the left border) With this method, we no longer use QIcon, we use QPixmap instead; that is why we created a custom setPixmap() method to our MyButton to give user access to the pixmap being drawn. Custom layout inside pushbutton Here is another interesting approach: this method defaults its style to left-aligned, but it only contains the icon. What about the push button label(text)? It is actually a QLabel placed in the QPushButton layout, and being vertically center-aligned; To modify the push button text, use setText() to the label inside the button layout, instead of the button. Use QProxyStyle I haven’t personally test it because my Qt python binding doesn’t have QProxyStyle included but it’s worth putting it here in case someone is able to try it. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ProxyStyle(QtWidgets.QProxyStyle): def drawControl(self, element, option, painter, widget=None): if element == QtWidgets.QStyle.CE_PushButtonLabel: icon = QtGui.QIcon(option.icon) option.icon = QtGui.QIcon() super(ProxyStyle, self).drawControl(element, option, painter, widget) if element == QtWidgets.QStyle.CE_PushButtonLabel: if not icon.isNull(): iconSpacing = 4 mode = ( QtGui.QIcon.Normal if option.state &amp; QtWidgets.QStyle.State_Enabled else QtGui.QIcon.Disabled ) if ( mode == QtGui.QIcon.Normal and option.state &amp; QtWidgets.QStyle.State_HasFocus ): mode = QtGui.QIcon.Active state = QtGui.QIcon.Off if option.state &amp; QtWidgets.QStyle.State_On: state = QtGui.QIcon.On window = widget.window().windowHandle() if widget is not None else None pixmap = icon.pixmap(window, option.iconSize, mode, state) pixmapWidth = pixmap.width() / pixmap.devicePixelRatio() pixmapHeight = pixmap.height() / pixmap.devicePixelRatio() iconRect = QtCore.QRect( QtCore.QPoint(), QtCore.QSize(pixmapWidth, pixmapHeight) ) iconRect.moveCenter(option.rect.center()) iconRect.moveLeft(option.rect.left() + iconSpacing) iconRect = self.visualRect(option.direction, option.rect, iconRect) iconRect.translate( self.proxy().pixelMetric( QtWidgets.QStyle.PM_ButtonShiftHorizontal, option, widget ), self.proxy().pixelMetric( QtWidgets.QStyle.PM_ButtonShiftVertical, option, widget ), ) painter.drawPixmap(iconRect, pixmap)if __name__ == &quot;__main__&quot;: app = QtWidgets.QApplication(sys.argv) app.setStyle(&#x27;fusion&#x27;) proxy_style = ProxyStyle(app.style()) app.setStyle(proxy_style) w = QtWidgets.QWidget() lay = QtWidgets.QVBoxLayout(w) icons = [ app.style().standardIcon(standardIcon) for standardIcon in ( QtWidgets.QStyle.SP_MediaPlay, QtWidgets.QStyle.SP_MediaPause, QtWidgets.QStyle.SP_MediaSeekBackward, QtWidgets.QStyle.SP_MediaSeekForward, ) ] for text, icon in zip(&quot;Play Pause Backward Forward&quot;.split(), (icons)): button = QtWidgets.QPushButton(text) button.setIcon(icon) lay.addWidget(button) w.show() sys.exit(app.exec_()) Reference Stack Overflow - QPushButton icon aligned left with text centered Stack Overflow - qpushbutton icon left alignment text center alignment","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Qt Detect Double-Click and Hover Effect","slug":"qt-detect-click","date":"2021-08-08T04:00:00.000Z","updated":"2022-03-13T16:13:16.599Z","comments":true,"path":"post/qt-detect-click/","link":"","permalink":"https://www.xingyulei.com/post/qt-detect-click/","excerpt":"","text":"Introduction I want to showcase some examples that I used to create push button with custom behaviours. (Double click button) (Button hover effect) Double Click Problem with MouseButtonDblClick Hey, I thought this would be easy, since Qt offers a built-in event type: QEvent.MouseButtonDblClick. But the issue is it couldn’t distinguish a single click vs. a double click. Which means, the single click event will also be invoked when double-clicked. Solution using timeout Subclass QPushButton and override eventFilter() Using eventFilter() eventFilter() takes three argument, a QObject that the filter is installed on, a QObject that is being watched, and a reference to a QEvent type object to be filtered. Be sure to add self.installEventFilter(self) so to override event filtering. Now it’s only the matter of adding condition logic to filter out different event types such as QEvent.MouseButtonPress and QEvent.MouseButtonDblClick with event.type() We can also filter which button is being used using event.button(). timeout Using a built-in timer from Qt QTimer(), we are able to fire off timer events between our clicks. A timeout signal is fired after a certain interval we defined using setInterval(). the timeout() method is then used to determine what custom signal to emit. Custom Signal Note that I created three custom signals for three different clicking type I want to register. 123right_clicked = QtCore.Signal()left_clicked = QtCore.Signal()double_clicked = QtCore.Signal() This enhanced the usability of the click behaviour, meaning that this extended QPushbutton can tell whether the user did a single left or right click or a double click. In my example above, I wrapped all the click events in the class itself. But in the main application, we can also instantiate MyButton and connect click event to method of our choice. 123btn = MyButton(&#x27;Button1&#x27;)btn.doubled_clicked.connect(func1)btn.right_clicked.connect(func2) Hover Effect As a bonus, I want to include a “Button” with custom hover effect, but it is technically a QLabel object with extended functionality, which is being used in my SnapTool. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class HoverBtn(QtWidgets.QLabel): clicked = QtCore.Signal(QtCore.QObject) def __init__(self, parent): super(HoverBtn, self).__init__(parent) style = &quot;&quot;&quot; QFrame&#123; border-radius: 25px; border-width: 2px; border-style: solid; border-color: rgb(20, 20, 20); background-color: rgb(170, 170, 170); &#125; &quot;&quot;&quot; self.installEventFilter(self) self.setStyleSheet(style) def eventFilter(self, obj, event): if event.type() == QtCore.QEvent.Enter: self.set_outline(1) return True elif event.type() == QtCore.QEvent.Leave: self.set_outline(0) return True if event.type() == QtCore.QEvent.MouseButtonPress \\ and event.button() == QtCore.Qt.LeftButton: self.clicked.emit(self) return True return False def set_outline(self, status): &quot;&quot;&quot; Update widget stylesheet when highlight &quot;&quot;&quot; style = self.styleSheet() border_pattern = r&#x27;border-color\\: rgb\\(\\d+, \\d+, \\d+\\)&#x27; dark = &#x27;border-color: rgb(20, 20, 20)&#x27; light = &#x27;border-color: rgb(21, 255, 9)&#x27; if status == 1: style = re.sub(border_pattern, light, style) elif status == 0: style = re.sub(border_pattern, dark, style) self.setStyleSheet(style) The hover effect is achieved by swapping stylesheet properties, and the rest of the event filtering is very similar to the previous double click button. Reference Qt Centre - Double Click Capturing Stack Overflow - Pyqt Mouse MouseButtonDblClick event","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"},{"name":"template","slug":"template","permalink":"https://www.xingyulei.com/tags/template/"}]},{"title":"Qt Connect Signal in For Loop","slug":"qt-signal-in-for-loop","date":"2021-04-17T04:00:00.000Z","updated":"2022-01-24T04:01:12.117Z","comments":true,"path":"post/qt-signal-in-for-loop/","link":"","permalink":"https://www.xingyulei.com/post/qt-signal-in-for-loop/","excerpt":"","text":"Introduction We often need to create ui elements on the fly, sometimes we do it in something like a for loop. An example would be creating a series of QPushButton and connect them to a function through different argument values. An example is shown below: 1234567891011121314151617class Demo(QtWidgets.QWidget): def __init__(self, parent=None): super(Demo, self).__init__(parent) # initialization object layout = QtWidgets.QVBoxLayout() for index in range(6): pushbutton = QtWidgets.QPushButton(&#x27;button &#123;&#125;&#x27;.format(index)) pushbutton.clicked.connect(lambda: self.trigger(index)) layout.addWidget(pushbutton) self.setLayout(layout) @staticmethod def trigger(index): print(&#x27;button &#123;&#125; clicked&#x27;.format(index)) Here I created six QPushButton and when I click them it should output which button is being clicked. But if you run this script and try to click each button it will always output “button 5 clicked” (aka, the last button). It is safely to assume that the argument passed during the for loop always result in the last index. Explanation Based on a kind response from stackoverflow: lambdas do not store the value of button when it is defined. The code describing the lambda function is parsed and compiled but not executed until you actually call the lambda. Therefore, when a button is clicked, the current value of that variable is used (the last index). What’s the solution? Lambda with solid variable Passing solid variable to the lambda 1pushbutton.clicked.connect(lambda _, i=index: self.trigger(index=i)) Note that we created another temporary variable before index as the first argument passed in the lambda will always return as False. Because Qt defines the signal QAbstractButton.clicked to take a single argument with a default value of False. Since your lambda is handling that signal, it gets called with False. Partial approach Use functools.partial also works 12from functools import partialpushbutton.clicked.connect(partial(self.trigger, index)) Note that in some cases where wrappers are being used in trigger function, it could be trickier to use this as oppose to lambda Reference Stack Overflow - First lambda capture of local variable always False Stack Overflow - Connecting multiples signal/slot in a for loop in pyqt","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Qt Custom Widget, Dialog, MessageBox (no .ui file)","slug":"qt-template-no-ui","date":"2021-02-11T05:00:00.000Z","updated":"2021-12-18T20:55:12.386Z","comments":true,"path":"post/qt-template-no-ui/","link":"","permalink":"https://www.xingyulei.com/post/qt-template-no-ui/","excerpt":"","text":"UI Module without .ui file There is a different between inheriting from QWidget class vs QMainWindow Inheriting from QWidget: 12345678910111213141516class InheritQWidget(QtWidgets.QWidget): def __init__(self, parent=None): super(InheritQWidget, self).__init__(parent) # initialization object layout = QtWidgets.QGridLayout() listWidget = QtWidgets.QListWidget() #treeWidget = QtWidgets.QTreeWidget() # set # treeWidget.setParent(listWidget) layout.addWidget(listWidget) self.setLayout(layout) listWidget.addItem(&#x27;item A&#x27;) listWidget.addItem(&#x27;item B&#x27;) Inheriting from QMainWindow 123456789101112131415161718class InheritQMainWindow(QtWidgets.QMainWindow): # Window inherits from QMainWindow the layout is already defined # to accommodate any toolbars or any other QMainWindow component # use the setCentralWidget() to accommodate this def __init__(self, parent=None): super(InheritQMainWindow, self).__init__(parent) # initialization object widget = QtWidgets.QWidget() layout = QtWidgets.QGridLayout() # set self.setCentralWidget(widget) widget.setLayout(layout) label = QtWidgets.QLabel(&#x27;test&#x27;) layout.addWidget(label, 0, 0) Custom Dialog Sometimes you need a quick window to display some information, but the built-in qt message boxes aren’t suitable for the job. Custom Widget You can choose to create a widget class, but also for saving time, you can create a temporary custom widget example: Couple of things worth noting: correctly initialize the widget self.customWidget = QtWidgets.QWidget() will allow widget be child of the main window, thus allow widget to close when main window is closed so not customWidget = QtWidgets.QWidget() or self.customWidget = QtWidgets.QWidget(self) use getattr in combination with QStyle and name of the built-in icon use win.setAttribute(QtCore.Qt.WA_DeleteOnClose) to make sure the child widget is killed after main window is closed, because default close only hides window objects self.customWidget.show() is the core command to call it to display Custom QMessageBox add custom buttons to the QMessageBox layout 123456789101112131415dialog = QtWidgets.QMessageBox()dialog.setText(&quot;Overwrite?&quot;)dialog.setIcon(QtWidgets.QMessageBox.Critical)yes_btn = dialog.addButton(&quot;Yes!&quot;, QtWidgets.QMessageBox.YesRole)no_btn = dialog.addButton(&quot;No&quot;, QtWidgets.QMessageBox.NoRole)abort_btn = dialog.addButton(&quot;Abort&quot;, QtWidgets.QMessageBox.RejectRole)dialog.exec_()if dialog.clickedButton() == yes_btn: print(&quot;yes&quot;)elif dialog.clickedButton() == no_btn: print(&quot;no&quot;)elif dialog.clickedButton() == abort_btn: print(&quot;abort&quot;) Don’t use the return value of QMessageBox::exec, as it only makes sense for standard buttons. Also don’t rely on buttonRole as multiple buttons could be sharing the same role. Reference Programiz - Python getattr() GUIS - Q&amp;A: Are there any built-in QIcons?","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"},{"name":"template","slug":"template","permalink":"https://www.xingyulei.com/tags/template/"}]},{"title":"Qt Context Menu Template (Menu, Submenu and Action)","slug":"qt-template-context-menu","date":"2021-02-05T05:00:00.000Z","updated":"2022-01-24T04:01:23.398Z","comments":true,"path":"post/qt-template-context-menu/","link":"","permalink":"https://www.xingyulei.com/post/qt-template-context-menu/","excerpt":"","text":"Reference Stack Overflow - How to add submenu in Qt","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"},{"name":"template","slug":"template","permalink":"https://www.xingyulei.com/tags/template/"}]},{"title":"How to Underscore in Python","slug":"py-dunder","date":"2021-01-23T05:00:00.000Z","updated":"2021-12-18T20:49:32.418Z","comments":true,"path":"post/py-dunder/","link":"","permalink":"https://www.xingyulei.com/post/py-dunder/","excerpt":"","text":"Underscore Naming Single Leading Underscore: _var Indicating a name is protected, for internal use. Not enforced by python interpreter Double Leading Underscore: __var Indicating a name is private. Enforced by interpreter, attempt to call it will trigger AttributeError Double Leading Trailing Underscore: __var__ Special methods (magic methods) defined by python language, avoid naming your own attribute Single Trailing Underscore: var_ Avoid naming conflict with python keywords Single Underscore: _ Temporary variable name, variables that are never used Example: 1234a, b, c, d = ([] for _ in range(4))for _ in random_list: some_operation() Reference Dan Bader - The Meaning of Underscores in Python Tutorials Teacher - Python - Public, Protected, Private Members","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"}]},{"title":"Qt Custom Sorting","slug":"qt-sorting","date":"2021-01-23T05:00:00.000Z","updated":"2022-02-13T23:13:23.892Z","comments":true,"path":"post/qt-sorting/","link":"","permalink":"https://www.xingyulei.com/post/qt-sorting/","excerpt":"","text":"Sorting Overview Sorting happens a lot in qt viewports like list, table and tree. Using convenience class such as item-based widget provides limited sorting options. One common thing may occur when you are sorting items is the widget treats their value as string instead of int, which will result incorrect ordering 12345678910111213141516list = [&quot;3&quot;, &quot;1&quot;, &quot;2&quot;, &quot;20&quot;, &quot;92&quot;, &quot;89&quot;, &quot;40&quot;, &quot;10&quot;, &quot;11&quot;]if __name__ == &#x27;__main__&#x27;: app = QtWidgets.QApplication(sys.argv) mywidget = QtWidgets.QTableWidget() mywidget.insertColumn(0) for index in range(len(list)): mywidget.insertRow(index) value = list[index] item = QtWidgets.QTableWidgetItem(value) mywidget.setItem(index, 0, item) mywidget.sortItems(0, QtCore.Qt.AscendingOrder) mywidget.show() sys.exit(app.exec_()) This will sort the list of items based on their string, so the order will be: 1234- 1- 10- 11- 2 instead of 123- 1- 2- ... So naturally, you would need to specify the item value as integer type, but you cannot instantiate item with integer, but setData() will work 1234# intead of item = QtWidgets.QTableWidgetItem(int(value))# do thisitem.setData(QtCore.Qt.ItemDataRole, int(value)) Now everything will sort by numeric order Custom Sorting (Operator override) What if you need more than numeric value for your data, for example, when displaying frame number, you would like to include frame range too. Like frame 1, frame 2, frame 3-7, frame 8, frame 9-14. It looks like using string is the only option. This time you need to override value compare operator for these value, that is making your own item class like the following example the __lt__ is the less than operator (&lt;) Everything should behave correctly Custom Sorting (QSortFilterProxyModel Class) https://doc-snapshots.qt.io/qtforpython-5.15/PySide2/QtCore/QSortFilterProxyModel.html Reference Stack Overflow - Is it possible to sort numbers in a QTreeWidget column?","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"}]},{"title":"Understanding Python Imports","slug":"py-import","date":"2021-01-16T05:00:00.000Z","updated":"2022-02-21T22:33:09.790Z","comments":true,"path":"post/py-import/","link":"","permalink":"https://www.xingyulei.com/post/py-import/","excerpt":"","text":"Table of Contents from import vs. import What does __init__.py do? Example Dot Notation in Import Import Order Intra-package Import an import Import Same Module Multiple Times from ... import vs. import Always avoid wildcard imports like such: 1from my_module import * # don&#x27;t use this Instead, use regular import like: 1import my_module # use this Why? using wildcard import will pollute namespaces Using wildcard import will not import names with a leading underscore (unless the module defines an __all__ list) PEP8 recommend using regular import What does __init__.py do? __init__.py is used to specify a package, when import is trying to find the modules, But it is not required: meaning a package without __init__.py, The system can still find the modules after configuring appropriate PYTHONPATH using sys.path.append. __init__.py is executed after importing the package, I’ve seen sub-directory being imported by appending as environment variable within __init__.py Example: so instead of using import project.foo.bar for the following structure: 123456project&#x2F; __init__.py foo&#x2F; __init__.py bar&#x2F; b.py inside the __init__.py, we could do a sys.path.append(PATH_TO_BAR) so with this file structure, you can just do import project they could even add the import statement for you in the __init__.py, although it is not transparent. 12345project&#x2F; __init__.py foo&#x2F; bar&#x2F; b.py Note: Whatever gets appended last overrides the previous env variable, so import to the same name module will find the latest append Dot Notation (.) in Import 12345678910parent&#x2F; __init__.py file.py one&#x2F; __init__.py anotherfile.py two&#x2F; __init__.py three&#x2F; __init__.py Each dot in your import will refer to something inside the package, could be another package or a module. But it can’t be a class. Import python modules could look like: import parent.file or import parent.one.anotherfile From … import classes or functions look like this: from parent.file import class which gives you direct access to the class namespace, but not the example above. Import Order Based on PEP8, imports should be grouped by the following order: Standard library import Related third-party import Local application/library specific import What is Standard Library Imports? Standard library are installed automatically by Python installer, full documentation link is here: https://docs.python.org/3/library/ What is the order after grouping? There is no specific rules, but based on common preferences, use alphabetical order, with import first and from … import after 12345import abcimport defimport xfrom g import ggfrom x import xx Intra-package In a structure like this, how would you do import from another directory? say from module-x.py import module-a 12345678910top-package&#x2F; __init__.py sub-package-a&#x2F; __init__.py module-x.py module-y.py sub-package-b&#x2F; __init__.py module-a.py module-b.py Here’s some examples doing relative imports in module-x 123456import module-yfrom . import module-yfrom .module-y import classAfrom .. import sub-package-bfrom ..subpackage-b import module-afrom ..subpackage-b.module-a import classB Import an import It is a common practice in C# to use import module or static class to stores all the global variables used for settings, or even all the modules. In Python it would be something like: constant.py 1234567891011121314import module_aimport module_bimport module_cGLOBAL_VAR_MAX = 50GLOBAL_VAR_MIN = 10GLOBAL_VAR_TIMEOUT = 2000GLOBAL_NAME = r&#x27;random name&#x27;# or evenclass Constant(object): gravity = 9.8 is_true = True With this setup, all the module in the same project would just import the constant module and have access to all the imports and variable. I thought this was a neat way to make code cleaner by getting rid of all the duplicated imports that might happen. there are also some voices against it: based on the style guide: Constants are usually defined on a module level also, suggestions have mentioned to refrain from using class as it could be instantiated which makes no sense. unless there’s a valid reason for all those modules to be collected under a common name. If not, then they should be kept separately. This is due to documentation, as other people open your file, they don’t get information on what is getting imported (what is needed) Same module import multiple times So if multiple files are importing the same module separately, does python optimize the import? Yes, python modules are considered as singletons, no matter how many times you import them they get initialized only once. unless reload is being called Reference Stack Overflow - constants in Python: at the root of the module or in a namespace inside the module? Stack Overflow - in python, do you need to import modules in each split file? Stack Overflow - Python: Importing an “import file” Stack Overflow - Does python optimize modules when they are imported multiple times? Stack Overflow - Why can I import successfully without init.py? Stack Overflow - relative path not working even with init.py","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"style","slug":"style","permalink":"https://www.xingyulei.com/tags/style/"}]},{"title":"Verlet Integration in Unity","slug":"verlet-integration","date":"2020-11-19T05:00:00.000Z","updated":"2022-01-23T03:13:43.945Z","comments":true,"path":"post/verlet-integration/","link":"","permalink":"https://www.xingyulei.com/post/verlet-integration/","excerpt":"","text":"Introduction When simulating a particle movement, we naturally think of Euler integration, where the position of the particle can be expressed as such: (free falling motion) x=0.5∗g∗t2x = 0.5*g*t^2 x=0.5∗g∗t2 This is an extremely easy use case. The position of the particle can be represented using a function of time. But in real life, a particle can be affected by multiple forces (and even unstabled force caused non-constant acceleration) and Euler integration also has inaccurate estimation when time step is very large. In my understanding, the use of Verlet is good for complex particle movement. What it essentially does is relate force with position rather than velocity. The process first calculate the current particle position and the position one step back: velocity=X current −X previous ;velocity = X~current~-X~previous~; velocity=X current −X previous ; X previous =X current ;X current =X current +velocityX~previous~ = X~current~; X~current~ = X~current~+velocity X previous =X current ;X current =X current +velocity This works magically, here’s some sample code to help understand it, and a Demo. 1234// without other influence, the following updates the particle positionvelocity = posNow - posOld;posOld = posNow;posNow += velocity; Calculate Force What if we want to add gravity to the particle like the free falling above? Just add the acceleration to the current position, and the change will add-up on the next integration. The following also applies to forces like friction. 1posNow += GRAVITY; // not sure if we should multipy Time.deltatime Constraint Constraint are usually in the form of constraining particles to a specific distance, like spring. When mulitple constraints acts on single particle, one constraint will affect the other. To solve this, loop the constraint multiple time for each time step. 123456789101112131415161718192021222324252627for (int count = 0; count &lt; ITERATION; count++)&#123; Constriants();&#125;// constraint on rope to make fixed distance between segmentsvoid Constriants()&#123; for(int index = 0; index &lt; segment-1; index++) &#123; float distance = (currentSeg.posNow - nextSeg.posNow).magnitude; float error = Mathf.Abs(distance - ropeDist); Vector2 changeDir = Vector2.zero; if (distance &gt; ropeDist) changeDir = (currentSeg.posNow - nextSeg.posNow).normalized; else if (distance &lt; ropeDist) changeDir = (nextSeg.posNow - currentSeg.posNow).normalized; Vector2 changeAmount = changeDir * error; if (index == 0) nextSeg.posNow += changeAmount; else&#123; currentSeg.posNow -= changeAmount * 0.5f; nextSeg.posNow += changeAmount * 0.5f; &#125; &#125;&#125; Collision Penalty based system or projection collision reaction 12345678910111213141516171819// example for bounding box collisionVector2 velocity = posNow - posOld;if (posNow.x &gt; screenWidth)&#123; posNow.x = screenWidth; posOld.x = posNow.x + velocity.x;&#125;else if (posNow.x &lt; 0)&#123; posNow.x = 0; posOld.x = posNow.x + velocity.x;&#125;if (posNow.y &gt; screenWidth)&#123; posNow.y = screenWidth; posOld.y = posNow.y + velocity.y;&#125;else if (posNow.y &lt; 0)&#123; posNow.y = 0; posOld.y = posNow.y + velocity.y;&#125; Resources Gamedev.net - A Verlet based approach for 2D game physics Youtube - Coding Math: Episode 36 - Verlet Integration Part I Youtube - 2D Rope Tutorial - Make Swinging Rope in Unity (Verlet Integration) Wikipedia - Velocity Verlet","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://www.xingyulei.com/tags/unity/"},{"name":"c#","slug":"c","permalink":"https://www.xingyulei.com/tags/c/"}]},{"title":"Learning Graphics Basics","slug":"graphics-learning","date":"2020-09-16T04:00:00.000Z","updated":"2022-01-24T03:57:35.001Z","comments":true,"path":"post/graphics-learning/","link":"","permalink":"https://www.xingyulei.com/post/graphics-learning/","excerpt":"","text":"Glossary Wikipedia - Computer Graphics Glossary Shader: programs running on gpu that describes general computation (vertex transformation: vertex shader; shading calculation: fragment shader) G-buffer: a screen space representation of geometry and material information (e.g. color, normal, position/depth) Fragment: is the corresponding pixel generated by geometric primitives, but a pixel on screen can be a product of more than one fragment due to Z-buffering, blending etc. Vertex lighting vs. Per-pixel lighting Vertex Lighting Lighting is computed per-vertex calculation happens in the vertex shader lighting/color information is then linearly interpolated across faces and rasterized it is cheaper, faster (since there are fewer vertices compared to pixels) but noticeable artifact with low-poly objects Per-Pixel Lighting Lighting is computed per-pixel/fragment (but what is this exactly? see the example below) Calculation happens in the fragment shader normal information (passed from vertex shader) is interpolated on the faces, lighting/color is calculated and rasterized. it is more expensive but less artifact Example of a per-pixel lighting shader Vertex Shader 123456789101112131415161718#version 330 corelayout (location &#x3D; 0) in vec3 aPos;layout (location &#x3D; 1) in vec3 aNormal;out vec3 FragPos;out vec3 Normal;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos &#x3D; vec3(model * vec4(aPos, 1.0)); Normal &#x3D; mat3(transpose(inverse(model))) * aNormal; gl_Position &#x3D; projection * view * vec4(FragPos, 1.0);&#125; Fragment Shader 123456789101112131415161718192021222324252627282930313233#version 330 coreout vec4 FragColor;in vec3 Normal; in vec3 FragPos; uniform vec3 lightPos; uniform vec3 viewPos; uniform vec3 lightColor;uniform vec3 objectColor;void main()&#123; &#x2F;&#x2F; ambient float ambientStrength &#x3D; 0.1; vec3 ambient &#x3D; ambientStrength * lightColor; &#x2F;&#x2F; diffuse vec3 norm &#x3D; normalize(Normal); vec3 lightDir &#x3D; normalize(lightPos - FragPos); float diff &#x3D; max(dot(norm, lightDir), 0.0); vec3 diffuse &#x3D; diff * lightColor; &#x2F;&#x2F; specular float specularStrength &#x3D; 0.5; vec3 viewDir &#x3D; normalize(viewPos - FragPos); vec3 reflectDir &#x3D; reflect(-lightDir, norm); float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), 32); vec3 specular &#x3D; specularStrength * spec * lightColor; vec3 result &#x3D; (ambient + diffuse + specular) * objectColor; FragColor &#x3D; vec4(result, 1.0);&#125; As you can see, fragment position and normal information are passed into the fragment shader from vertex shader (where the pre-compute happens), the lighting calculation (Phong lighting) is calculated per-fragment. On a related note: gpu cost are related to 1. how many vertices are passed in to the gpu from buffer and 2. how complex the lighting calculation is in the fragment shader (this could be the algorithm/model complexity, and the number of passes); Forward vs. Deferred Rendering Forward Rendering The standard, out-of-the-box rendering technique Geometries are passed to gpu, going through vertex shader and fragment shader, with each geometry and each light computed separately one at a time to form the final render. Render complexity: O(num of geometry fragments * num of lights) Deferred Rendering Render is deferred until all geometry has been processed Geometries are passed to gpu, going through vertex shader and fragment shader (without lighting pass), final rendering is computed/combined with multiple render passes (one pass for getting all geometry information to G-buffer, second pass for compute lighting based on the G-buffer). Render complexity: O(screen resolution * num of lights) Discussion Everything all comes down to lighting, as gpu can easily handle vertex information, but the most expensive are lighting calculation which can easily slow down the rendering. Forward rendering iterates and compute each fragments of each geometry, no matter if it overlaps or is hidden by other fragments. So for each pixel, we could have already run multiple fragment shaders. This is where deferred rendering come in handy, the G-buffer stores information such as color, normal and depth. The lighting later on can know how to produce the final render by combining all the information (For example: depth test can also cull out all the fragments that are being obscured). So essentially, each pixel only runs a single fragment shader. Rasterization vs. Ray tracing The forward, deferred rendering techniques are all in the realm of rasterization, which is the most popular and traditional real-time rendering technique. With the advance of hardware, ray tracing, which is computationally demanding (usually used in films/animation) can now be used in real-time video games. Rasterization We gather objects information and projects each one by one on screen (per fragment), fragment shader computes the final color of every fragment to form pixels on screen. The fundamental of rasterizing is that for each object/geometry, we look at (rasterize it) it’s verts/triangles to cover pixels. So, as discussed in deferred rendering, every object is drawn but not all of them are displayed on screen. This overdraw can be accelerated by using deferred shading’s depth test. Ray tracing We cast rays from our eyes (camera) for each pixel and gather information of those rays as they travel through/intersects with objects and interacts with lights to form the final render on screen. The fundamental of ray tracing is that for each pixel, we look at (shoot a ray) each object/geometry to see how they contribute to the color of that pixel. As for ray tracing, we need to shoot many rays for each pixel, and more when there are reflection and refraction. One way to accelerate this is to use bounding volume. Discussion The most significant difference in visual is that ray tracing is physically more accurate than rasterization, thus more realistic. Which is more apparent in dynamic environment with objects that reflects and refract. Rasterization needs many estimation techniques to handle lighting and shadowing such as more render passes, baked light map, cubemap reflection, but ray tracing gets all the results out of the box. Reference Envato tuts+ - Forward Rendering vs. Deferred Rendering Learn OpenGL - Deferred Shading Wikipedia - Deferred Lighting Learn OpenGL - Basic Lighting Knowww - Per-vertex vs. per-fragment lighting Unity Forum - What’s the difference between per-pixel and per-vertex lit in Forward Rendering? Youtube - OpenGL Fragment Shaders | How Do Fragment Shaders Work? Nvidia - Ray Tracing Essentials Stack Exchange - Mirror Reflections: Ray Tracing or Rasterization? Quora - What is the difference between ray tracing and very high shader details?","categories":[{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"}],"tags":[{"name":"graphic programming","slug":"graphic-programming","permalink":"https://www.xingyulei.com/tags/graphic-programming/"}]},{"title":"Maya API (3. Custom Deformer)","slug":"maya-api-deformer","date":"2019-11-11T05:00:00.000Z","updated":"2021-12-18T20:48:17.267Z","comments":true,"path":"post/maya-api-deformer/","link":"","permalink":"https://www.xingyulei.com/post/maya-api-deformer/","excerpt":"","text":"API 1.0 custom deformer Example Note: MPxDeformerNode is only available in API 2.0 Custom Attribute vs. Built-in Attribute In the last chapter, we know how to create custom numeric type attribute using MFnNumericAttribute. Sometimes in our node, we want to access existing built-in attribute. We do so by using OpenMayaMPx.cvar.MPxDeformerNode_(attributeName) before Maya 2016, we use OpenMayaMPx.cvar.MPxGeometryFilter_(attributeName) after 2016. Obtain Input Geometry In the sample code, we define our custom function getDeformerInputGeom(self, dataBlock, geomIndex) to obtain the input mesh to the deformer node. We will discuss this later. Accessory Node Accessory node acts like a secondary driver node connected to our deformer so they can influence the deformation. In the sample code, our accessory node is a locator which when we connects its world matrix, it will change our mesh’s deformation when translating. Custom Dependency Node vs. Custom Deformer Node Registration: In our previous chapter, we register our node using registerNode() with node type: omMPx.MPxNode.kDependNode, in deformer node, we use omMPx.MPxNode.kDeformerNode as our node type. Inheritance: We now inherit our class from omMPx.MPxDeformerNode instead of omMPxNode there’s still compute() in MPxDeformerNode class, but we want to write our deformation algorithm in deform(). Accessory Node: accessoryNodeSetup(self, dagModifier) and accessoryAttribute(self) is override to allow us to control accessory node along with our deformer. Procedure Step 1: Declare attributes (Same as last chapter) Step 2: Initialize Node Node Creator 12def nodeCreator(): return mpx.asMPxPtr(MyDeformer()) Only API 1.0 is available. Node Initializer 12345678910111213141516171819202122232425262728def nodeInitializer(): # 1: create reference to numericAttribute and matrixAttribute function sets numericAttrFn = om.MFnNumericAttribute() matrixAttrFn = om.MFnMatrixAttribute() # 2: create attribute using the function set MyDeformer.inNumAttr = numericAttrFn.create(&#x27;num&#x27;, &#x27;n&#x27;, om.MFnNumericData.kFloat, 0.0) numericAttrFn.setMin(-1.0) numericAttrFn.setMax(1.0) numericAttrFn.setReadable(False) MyDeformer.inMatAttr = numericAttrFn.create(&#x27;matrix&#x27;, &#x27;m&#x27;) matrixAttrFn.setStorable(False) matrixAttrFn.setConnectable(True) # 2.5: access built-in attribute using OpenMayaMpx.cvar.MPxGeometryFilter_outputGeom outputGeom = mpx.cvar.MPxGeometryFilter_outputGeom # 3: attach attribute MyDeformer.addAttribute(MyDeformer.inNumAttr) MyDeformer.addAttribute(MyDeformer.inMatAttr) # 4: add circuit (relationship in-&gt;out) MyDeformer.attributeAffects(MyDeformer.inNumAttr, ouputGeom) MyDeformer.attributeAffects(MyDeformer.inMatAttr, ouputGeom) # 5: make attribute paintable cmds.makePaintable(nodeName, &#x27;weights&#x27;, attrType=&#x27;multiFloat&#x27;, shapeMode=&#x27;deformer&#x27;) we access the output Geometry attribute so we can later add relationship to it. RegisterNode 1mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDeformNode) De-registerNode 1mplugin.deregisterNode(nodeID) Step 3: Initialize Node （Actual Deform Algorithm） 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyNode(om.MPxDeformNode): inNumAttr = om.MObject() inMatAttr = om.MObject() def __init__(self): om.MPxDeformNode.__init__(self) def deform(self, dataBlock, geomIterator, localToWorldMatrix, geomIndex): # step 1: access built-in attribute value using attribute name and attribute handle envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope envelopeHandle = dataBlock.inputValue(envelopeAttr) envelopeValue = envelopeHandle.asFloat() # step 1.5: access custom attribute value inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr) inNumValue = inNumHandle.asFloat() # step 1.55: access custom translate value connected to an accessory node inMatHandle = dataBlock.inputValue(MyDeformer.inMatAttr) inMatValue = inNumHandle.asMatrix() transMatrix = om.MTransformationMatrix(inMatValue) # matrix type translateValue = transMatrix.getTranslation(om.MSpace.kObject) # vector type # step 2: access input mesh inputMesh = self.getDeformerInputGeom(dataBlock, geomIndex) # step 2.5: access mesh normals meshFn = om.MFnMesh(inputMesh) normalVectorArray = om.MFloatVectorArray() # create float vector array to store normal vector meshFn.getVertexNormals(False, normalVectorArray, om.MSpace.kObject) # (average normal or not?, the array to store, normal space) # step 3: iterate the mesh vertices and deform it newVertexPosArray = om.MPointArray() # to store new vertices position while not geomIterator.isDone(): vertexPos = geomIterator.position() vertexIndex = geomIterator.index() normalVector = om.MVector(normalVectorArray[vertexIndex]) # built-in function weightValue(dataBlock, geomIndex, vertexIndex) weight = self.weightValue(dataBlock, geomIndex, vertexIndex) # vertexPos.x = vertexPos.x + [calculation of normalVector.x and translateValue[0]] * envelopeValue * weight newVertexPosArray.append(vertexPos) geomIterator.next() geomIterator.setAllPositions(newVertexPosArray) To access a value from an attribute, we use handle = dataBlock.input/outputValue(MyNode.attr) if we have a custom attribute inNumAttr: inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr) inNumValue = inNumHandle.asFloat() if we have a built-in attribte envelope: we first get our attribute name envelope envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope envelopeHandle = dataBlock.inputValue(envelopeAttr) envelopeValue = envelopeHandle.asFloat() To get normal for individual vertices on our input mesh, we first need to obtain our input mesh using our own function: getDeformerInputGeom(self, dataBlock, geomIndex). And using mesh function set MeshFn’s getVertexNormals() we store the normal vector in om.MFloatVectorArray() type array. To deform our mesh: we use the geometry iterator to perform iteration on each mesh vertex and re-calculate its position. We combine the use of geoIterator.position() and geomIterator.setPosition(point) or geomIterator.setAllPositions(pointArray). To access weight value on each vertex, we use built-in function weightValue(dataBlock, geomIndex, vertexIndex). In which, geomIndex is provided in deform() and vertexIndex is from geomIterator. Step 3.1: Get in-Mesh 1234567891011def getDeformerInputGeom(self, dataBlock, geomIndex): inputAttr = mpx.cvar.MPxGeometryFilter_input inputHandle = dataBlock.outputArrayValue(inputAttr) # use outputArray instead of inputArray to avoid re-computation inputHandle.jumpToElement(geomIndex) inputElementHandle = inputHandle.outputValue() inputGeomAttr = mpx.cvar.MPxGeometryFilter_inputGeom inputGeomHandle = inputElementHandle.child(inputGeomAttr) # this is different from how we usually get handler inputGeomMesh = inputGeomHandle.asMesh() return inputGeomMesh At this point, I can’t fully interpret the meaning of this segment. Step 4: Accessory Node 1234567891011121314151617181920def accessoryNodeSetup(self, dagModifier): # step1: create the accessory node using the supplied dagModifier locator = dagModifier.createNode(&#x27;locator&#x27;) # step2: access accessory node&#x27;s attribute(can&#x27;t use mplug type, has to be mobject type) # access dependency node function set dependNodeFn = om.MFnDependencyNode(locator) matrixPlug = dependNodeFn.findPlug(&#x27;worldMatrix&#x27;) # this returns mplug type attribute, we need mobject type attribute matrixAttr = matrixPlug.attribute() # step3: connect mobject type(required) together # param: accessory node(mobject), accessory attr(mobject), deformer node(mobject: using self.thisMObject()), deformer attr(mobject) mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr) # now the accessory node&#x27;s worldMatrix is driving to the custom in-matrix of the deformer node return mConnectStatusdef accessoryAttribute(self): # returns the deformer node attribute connected return MyDeformer.inMatAttr The dagModifer is supplied in the accessory node. We use dagModifier’s connect function to connect the accessory node’s attribute to our deformer node’s attribute. In this case, we have accessory’s attribute: worldMatrix (a built-in attribute obtained from MFnDependencyNode.findPlug()) and our custom defined MyDeformer.inMatAttr. One thing to note is that, the .connect() only takes MObject which we cannot supply MPlug type object matrixPlug = ...findPlug('attributeName'), we perform an additional step matrixAttr = matrixPlug.attribute() to get the MObject type attribute. Now we supply .connect() with parameters: an accessory node (MObject type), accessory node’s attribute (MObject type), deformer node (MObject type) and deformer node’s attribute (MObject type) as follows: mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr) Reference Chad Vernon - Maya API Programming","categories":[{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Maya API (2. Custom Node)","slug":"maya-api-node","date":"2019-11-10T05:00:00.000Z","updated":"2021-12-18T20:48:53.264Z","comments":true,"path":"post/maya-api-node/","link":"","permalink":"https://www.xingyulei.com/post/maya-api-node/","excerpt":"","text":"API 2.0 custom node example Data block (MDataBlock) Data block refers the entire container of a node. This container stores all the values for each attribute of the node. The datablock of this node is provided in the compute() function. Plug (MPlug) Plug is the outer plug of the node which provides the connections to other node’s plug. The MPlug usually connects the plug from another node and the value of a certain attribute of this node. The plug is also provided in the compute() function Data handle (MDataHandle) Data handle usually stores an attribute’s value. We can set a value to an attribute using MDataHandle.setType(value), and get an attribute’s value using **value = MDataHandle.asType()**. Procedure Step 1: Declare attributes (MObject) in the class 123456789class MyNode(om.MPxNode): inAttr = om.MObject() outAttr = om.MObject() def __init__(self): om.MPxNode.__init__(self) def compute(self, plug, dataBlock): pass inAttr refers to the input attribute that we are creating, outAttr refers to the output attribute that we are creating. Both are declared as MObject() type. We will later access them using MyNode.inAttr and MyNode.outAttr. Step 2: Initialize Node Node Creator 12def nodeCreator(): return MyNode() Node Creator in API 2.0 directly returns an instance to the class, API 1.0 uses a pointer like in command plugin. Node Initializer 123456789101112131415161718def nodeInitializer(): &#x27;&#x27;&#x27;1: create reference to attribute function set such as numericAttribute&#x27;&#x27;&#x27; numericAttrFn = om.MFnNumericAttribute() &#x27;&#x27;&#x27; 2: create attribute using the function set&#x27;&#x27;&#x27; MyNode.inAttr = numericAttrFn.create(&#x27;in&#x27;, &#x27;i&#x27;, om.MFnNumericData.kFloat, 1.0) numericAttrFn.readable = True numericAttrFn.writable = True MyNode.outAttr = numericAttrFn.create(&#x27;out&#x27;, &#x27;o&#x27;, om.MFnNumericData.kFloat) numericAttrFn.readable = True numericAttrFn.writable = False &#x27;&#x27;&#x27; 3: attach attribute&#x27;&#x27;&#x27; MyNode.addAttribute(MyNode.inAttr) MyNode.addAttribute(MyNode.outAttr) &#x27;&#x27;&#x27; 4: add circuit (relationship in-&gt;out)&#x27;&#x27;&#x27; MyNode.attributeAffects(MyNode.inAttr, MyNode.outAttr) MFnNumericAttribute provides the function sets to create an attribute for numeric type attribute. There’s also MFnMatrixAttribute to create matrix type attribute and so on. Using the function set’s create() function, we add parameters for attribute’s long name, short name, data type, and default value (optional). This returns a MObject type attribute which is attached to the function set. We store it in the attribute declared earlier in the class. Set the attribute’s property using function set, such as readable, writable, hidden, storable, connectable (In API1.0, use like this numericAttrFn.setReadable(True)) Using the MyNode.addAttribute(MyNode.inAttr) to attach an attribute to the node Using the MyNode.attributeAffects(MyNode.inAttr, MyNode.outAttr) to design the affect relationship between attributes, in this case, change of inAttr will affect `outAttr. RegisterNode 1mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDependNode, nodeClassify) Parameters: name of the node, id of the node, node creator function, node initializer function, node type (DependNode or DeformNode…), node classification (utility, shading…) Example: nodeID = om.MTypeId(0x55555) nodeClassify = 'utility/general' De-registerNode 1mplugin.deregisterNode(nodeID) Step 3: Initialize Node 12345678910111213141516171819202122232425class MyNode(om.MPxNode): inAttr = om.MObject() outAttr = om.MObject() def __init__(self): om.MPxNode.__init__(self) def compute(self, plug, dataBlock): if plug == MyNode.outAttr: # 1: get datablock handle (inputValue returns MDataHandle type object) inHandle = dataBlock.inputValue(MyNode.inAttr) outHandle = dataBlock.outputValue(MyNode.outAttr) # 2: extract input value from the handle inValue = inHandle.asFloat() # 3: create logic and set output value outValue = inValue * 2 outHandle.setFloat(outValue) # 4: mark output plug as clean outHandle.setClean() else: return om.kUnknownParameter When MyNode.outAttr is dirty (meaning it needs to recompute), we use if plug == MyNode.outAttr: to identify this certain plug. (this if statement will work, even if plug is MPlug type and MyNode.outAttr is MObject type) We have already identified what input attribute is affecting this plug, in order to retrieve the value of this input, we need to attach a data handle on the data block specifying this certain input attribute we want to retrive. Therefore, we have handle = dataBlock.input/outputValue(MyNode.attr) Next, we use value = handle.asFloat() and handle.setFloat(value) to get and set the value from and to the attribute. (float type as example) Last, we mark the current plug as clean, by setClean() to the outHandle Reference Chad Vernon - Maya API Programming","categories":[{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Maya API (1. Command Plugin with Flags)","slug":"maya-api-command","date":"2019-11-09T05:00:00.000Z","updated":"2021-12-18T20:46:49.676Z","comments":true,"path":"post/maya-api-command/","link":"","permalink":"https://www.xingyulei.com/post/maya-api-command/","excerpt":"","text":"Definition: “Flags” vs “Argument” Take this as an example: cmds.group('circle1', 'sphere1', name='group1') circle1 and sphere1 are arguments name is the flag and group1 is the value Another example: cmds.polyCube(sx=10, axis=[0, 0, 1]) no argument is specified sx is the flag’s short name, subdivisionX is the flag’s long name [0, 0, 1] is axis flag’s value, each individual number is called parameters Procedure Step 1: Declare flag name outside the class 12345firstFlagShortName = &#x27;-f&#x27;firstFlagLongName = &#x27;-first&#x27;secondFlagShortName = &#x27;-s&#x27;secondFlagLongName = &#x27;-second&#x27;# more flags ... Step 2: Add flag and argument in syntax creator outside of class (this syntax creator will be further included in the plugin initialize function) 1234567891011121314151617def syntaxCreator(): &quot;&quot;&quot; create a OpenMaya.MSyntax object to store flags and argument &quot;&quot;&quot; syntax = om.MSyntax() # add flags with short name, long name, and value type syntax.addFlag(firstFlagShortName, firstFlagLongName, om.MSyntax.kDouble) syntax.addFlag(secondFlagShortName, secondFlagLongName, (om.MSyntax.kDouble, om.MSyntax.kDouble, om.MSyntax.kDouble)) # add more flags ... # add argument using MSyntax.addArg() function # add argument is not discussed, refer to document later return syntax Step 3: Parsing flags, called inside the class’s doIt function 123456789101112131415def parseArguments(self, args): &quot;&quot;&quot; instantiate MArgParser object, self.syntax() refers to the syntax created in step 2 &quot;&quot;&quot; argData = om.MArgParser(self.syntax(), args) # check if certain flags are set if argData.isFlagSet(firstFlagShortName): firstValue = argData.flagArgumentString(firstFlagShortName, 0) if argData.isFlagSet(secondFlagShortName): secondParam0 = argData.flagArgumentInt(secondFlagShortName, 0) secondParam1 = argData.flagArgumentInt(secondFlagShortName, 1) secondParam2 = argData.flagArgumentInt(secondFlagShortName, 2) # parse more flags ... Reference Chad Vernon - Maya API Programming","categories":[{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Maya API (0. Introduction)","slug":"maya-api-intro","date":"2019-11-08T05:00:00.000Z","updated":"2021-12-18T20:48:36.153Z","comments":true,"path":"post/maya-api-intro/","link":"","permalink":"https://www.xingyulei.com/post/maya-api-intro/","excerpt":"","text":"Overview Different from Maya Command, Maya API offers more low level access to Maya’s feature. You can think of Maya in multiple layers: Bottom Layer: System OS Maya Core: The entire Maya program written in C++ Maya API: Designated API exposed to developers, which can access Maya Core Maya Command: Helper Functions calling multiple Maya API Maya GUI: User graphics interface While Maya Command (MEL/Python) is most commonly used to write scripts, because it has fast prototyping and easy to learn. The downside is that it is often slow and can’t offer low level access to Maya Core. Maya API on the other hand, is complicated, but offers faster speed and most flexibility. It comes with Python and C++. Python API has version 1.0 and 2.0. Difference Between Python API vs C++ API API1.0 vs 2.0 API 1.0 (Before 2012) has acess to more features offered in C++ API 2.0 faster and more pythonic, but some class such as OpenMayaFX, OpenMayaDeformerNode is not supported. General Format Difference import module 1.0 has a seperate maya.OpenMayaMPx along with maya.OpenMaya 2.0 has maya.api.OpenMaya including the original MPx command maya_useNewAPI 2.0 use this function to declare using API 2.0 cmd creator 1.0 uses a MPx pointer object to point to instance of the class 2.0 director returns the instance of the class other syntax difference will be discussed later Reference Chad Vernon - Maya API Programming","categories":[{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Tutorial - Run Maya in Batch Mode","slug":"maya-batch-mode","date":"2019-10-09T04:00:00.000Z","updated":"2022-01-24T03:56:18.815Z","comments":true,"path":"post/maya-batch-mode/","link":"","permalink":"https://www.xingyulei.com/post/maya-batch-mode/","excerpt":"","text":"Step 1. Import standalone module 12import maya.standalonemaya.standalone.initialize(name=&#x27;python&#x27;) sometimes, import error could occur 1ImportError: No module named maya.standalone Solution check your python interpreter, it should match the maya python2 version. I changed my project interpreter in my pycharm setting. setup system environment variable, like the following if error still occurs, please check your maya directory 1234567891011121314151617181920import sysimport osMAYA_LOCATION = &quot;C:/Program Files/Autodesk/Maya2018&quot;PYTHON_LOCATION = MAYA_LOCATION + &quot;/Python/Lib/site-packages&quot;os.environ[&quot;MAYA_LOCATION&quot;] = MAYA_LOCATIONos.environ[&quot;PYTHONPATH&quot;] = PYTHON_LOCATIONsys.path.append(MAYA_LOCATION)sys.path.append(PYTHON_LOCATION)sys.path.append(MAYA_LOCATION+&quot;/bin&quot;)sys.path.append(MAYA_LOCATION+&quot;/lib&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python/DLLs&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python/Lib&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python/Lib/plat-win&quot;)sys.path.append(MAYA_LOCATION+&quot;/Python/Lib/lib-tk&quot;)print(&#x27;\\n&#x27;.join(sys.path)) Step 2. Add functions Let’s add a test function to our standalone script. 1234567891011121314def test(): import maya.cmds as cmds # full path to your Maya file to OPEN maya_file_to_open = r&quot;C:\\Users\\Lei\\Desktop\\test.ma&quot; # Open your file cmds.file(maya_file_to_open, o=True) # full path to your Maya file to IMPORT maya_file_to_import = r&quot;C:\\Users\\Lei\\Desktop\\import.ma&quot; # Import the file. the variable &quot;nodes&quot; will hold the names of all nodes imported, just in case. cmds.file(maya_file_to_import, i=True, type=&quot;mayaAscii&quot;) render = r&quot;C:\\Users\\Lei\\Desktop\\te.ma&quot; cmds.file(rename=render) cmds.file(force=True, save=True, options=&#x27;v=1;p=17&#x27;, type=&#x27;mayaBinary&#x27;) print(&#x27;a&#x27;) This test function opens a maya file on my desktop and import a maya file and save out as another file. Step 3. Executing through mayapy execute from command line to do so, make sure to add mayapy to your system environment variable. in system variable: add C:\\Program Files\\Autodesk\\Maya2018\\bin to Path open command prompt, and enter mayapy [directory/firstStandalone.py] execute using subprocess you can do it without going to command line, but by executing another .py using subprocess 1234567import subprocesscommand = &#x27;mayapy [directory/firstStandalone.py]&#x27;process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)process.wait()print(process.returncode) # this return the message from cmd Step 4. Standalone script with arguments Sometimes, we would want to pass arguments to our standalone script get argument as variable using sys.argv 1234import sysfile_path = sys.argv[1]file_name = sys.argv[2] Example from Toadstorm Nerdblog: 1234567891011121314151617181920212223242526272829import subprocessmaya_path = &#x27;directory/mayapy.exe&#x27; # mayapy or full path to mayapy.exescript_path = &#x27;directory/firstStandalone.py&#x27;def add_layer(file_names,layer_name): for file_name in file_names: command = r&#x27;mayapy &#123;&#125; &#123;&#125; &#123;&#125;&#x27;.format( script_path, file_name, layer_name ) process = subprocess.Popen( command, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) process.wait() print(process.returncode) # this return the message from cmd if __name__ == &#x27;__main__&#x27;: # define a list of filenames to iterate through files = [&#x27;file1&#x27;, &#x27;file2&#x27;, &#x27;file3&#x27;] render_layer = &#x27;a new render layer&#x27; # run procedure, assuming you&#x27;ve already defined it add_layer(files, render_layer) Reference Tech-Artist Org - Import maya.standalone problem Stack Overflow - use external python script to open maya and run another script inside maya Stack Overflow - How to use an external interpreter for Maya? Toadstorm Nerdblog - Python in Maya Standalone","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"}]},{"title":"Qt General Template","slug":"qt-template","date":"2019-01-16T05:00:00.000Z","updated":"2022-03-13T01:43:05.713Z","comments":true,"path":"post/qt-template/","link":"","permalink":"https://www.xingyulei.com/post/qt-template/","excerpt":"","text":"Import Qt Module Either using PyQt/PySide or a custom binding, but the import is similar 12from Qt import QtCore, QtGui, QtWidgetsfrom Qt import _loadUi Parented to Maya main window by default Qt window is not parented to Maya application 123456789101112from shiboken2 import wrapInstancedef get_maya_main_window(): import maya.OpenMayaUI main_window_ptr = maya.OpenMayaUI.MQtUtil.mainWindow() return wrapInstance(long(main_window_ptr), QtWidgets.QMainWindow)class ModuleUI(QtWidgets.QDialog): def __init__(self, parent=get_maya_main_window()): super(ModuleUI, self).__init__(parent) _loadUi(UI_PATH, self) self.setWindowFlags(QtCore.Qt.Window) Using QApplication Launch as standalone application using QApplication, or if a QApplication exist, there’s no need to instantiate it. use QtWidgets.QApplication.instance() to check 12345678910if __name__ == &#x27;__main__&#x27;: import sys if QtWidgets.QApplication.instance(): window = ConfigEditor() window.show() else: app = QtWidgets.QApplication(sys.argv) window = ConfigEditor() window.show() sys.exit(app.exec_()) Make Window Dockable Instantiate Widget When the UI has no parent (Maya main window), it will get instantly destroyed by the garbage collector, unless you keep an instance: 12345678# in the show functiondef show(): window = ModuleUI() window.show() return window# in maya script editorwin = moduleName.show() or using global variable to store the instance 1234567def show(): global window window = ModuleUI() window.show()# in maya script editormoduleName.show() Default Close Widget by default, closing the widget is hiding it not destroying the object 12345678def show(): window = ModuleUI() try: window.close() except: pass window.setAttribute(QtCore.Qt.WA_DeleteOnClose) window.show() or alternatively: 1234567def show(): if cmds.window(&#x27;ModuleUI&#x27;, q=1, exists=1): cmds.deleteUI(&#x27;ModuleUI&#x27;) global window window = ModuleUI() window.setObjectName(&#x27;ModuleUI&#x27;) window.show() Error in PyCharm When this error occurs, it is due to MayaDevKit environment MayaDevKit allows maya python command auto-completion, remove it from PyCharm 12app &#x3D; QtWidgets.QApplication(sys.argv)TypeError: &#39;NoneType&#39; object is not callable Reference Reddit - PyQt5 - Why do I get an Empty Window? Stack Overflow - pycharm use pyside2 TypeError: ‘NoneType’ object is not callable","categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"}],"tags":[{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"},{"name":"template","slug":"template","permalink":"https://www.xingyulei.com/tags/template/"}]}],"categories":[{"name":"tech summary","slug":"tech-summary","permalink":"https://www.xingyulei.com/categories/tech-summary/"},{"name":"learning log","slug":"learning-log","permalink":"https://www.xingyulei.com/categories/learning-log/"},{"name":"maya communication","slug":"maya-communication","permalink":"https://www.xingyulei.com/categories/maya-communication/"},{"name":"maya python api","slug":"maya-python-api","permalink":"https://www.xingyulei.com/categories/maya-python-api/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.xingyulei.com/tags/python/"},{"name":"windows","slug":"windows","permalink":"https://www.xingyulei.com/tags/windows/"},{"name":"style","slug":"style","permalink":"https://www.xingyulei.com/tags/style/"},{"name":"maya","slug":"maya","permalink":"https://www.xingyulei.com/tags/maya/"},{"name":"socket","slug":"socket","permalink":"https://www.xingyulei.com/tags/socket/"},{"name":"threading","slug":"threading","permalink":"https://www.xingyulei.com/tags/threading/"},{"name":"command port","slug":"command-port","permalink":"https://www.xingyulei.com/tags/command-port/"},{"name":"pyqt","slug":"pyqt","permalink":"https://www.xingyulei.com/tags/pyqt/"},{"name":"unity","slug":"unity","permalink":"https://www.xingyulei.com/tags/unity/"},{"name":"c#","slug":"c","permalink":"https://www.xingyulei.com/tags/c/"},{"name":"template","slug":"template","permalink":"https://www.xingyulei.com/tags/template/"},{"name":"graphic programming","slug":"graphic-programming","permalink":"https://www.xingyulei.com/tags/graphic-programming/"}]}